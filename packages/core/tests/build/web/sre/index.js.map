{"version":3,"file":"index.js","sources":["../src/subsystems/AgentManager/AgentRequest.class.ts","../src/types/SRE.types.ts","../src/utils/general.utils.ts","../src/utils/date-time.utils.ts","../src/utils/string.utils.ts","../src/utils/base64.utils.ts","../src/utils/data.utils.ts","../src/utils/cli.utils.ts","../src/utils/url.utils.ts","../src/utils/validation.utils.ts","../src/config.ts","../src/helpers/Log.helper.ts","../src/Core/DummyConnector.ts","../src/Core/Connector.class.ts","../src/Core/SystemEvents.ts","../src/Core/ConnectorsService.ts","../src/subsystems/AgentManager/EmbodimentSettings.class.ts","../src/subsystems/AgentManager/AgentSettings.class.ts","../src/types/ACL.types.ts","../src/subsystems/Security/AccessControl/AccessRequest.class.ts","../src/subsystems/Security/AccessControl/AccessCandidate.class.ts","../src/subsystems/Security/AccessControl/ACL.class.ts","../src/subsystems/IO/Storage.service/SmythFS.class.ts","../src/helpers/BinaryInput.helper.ts","../src/helpers/JsonContent.helper.ts","../src/utils/numbers.utils.ts","../src/helpers/TypeChecker.helper.ts","../src/Components/Component.class.ts","../src/subsystems/Security/Vault.service/Vault.helper.ts","../src/helpers/TemplateString.helper.ts","../src/Components/APIEndpoint.class.ts","../src/Components/APIOutput.class.ts","../src/subsystems/LLMManager/models.ts","../src/subsystems/LLMManager/LLM.helper.ts","../src/Components/PromptGenerator.class.ts","../src/Components/APICall.class.ts","../src/Components/VisionLLM.class.ts","../src/Components/DataSourceLookup.class.ts","../src/subsystems/IO/VectorDB.service/Vectors.helper.ts","../src/Components/DataSourceIndexer.class.ts","../src/Components/LogicAtLeast.class.ts","../src/Components/LogicAtMost.class.ts","../src/Core/AgentProcess.helper.ts","../src/subsystems/MemoryManager/LLMContext.ts","../src/constants.ts","../src/helpers/OpenApiParser.helper.ts","../src/helpers/Conversation.helper.ts","../src/Components/AgentPlugin.class.ts","../src/Components/LLMAssistant.class.ts","../src/Components/index.ts","../src/Components/FSleep.class.ts","../src/Components/FHash.class.ts","../src/Components/FEncDec.class.ts","../src/Components/FTimestamp.class.ts","../src/Components/DataSourceCleaner.class.ts","../src/Components/JSONFilter.class.ts","../src/Components/LogicAND.class.ts","../src/Components/LogicOR.class.ts","../src/Components/LogicXOR.class.ts","../src/subsystems/AgentManager/AgentLogger.class.ts","../src/subsystems/MemoryManager/RuntimeContext.ts","../src/subsystems/AgentManager/AgentRuntime.class.ts","../src/subsystems/AgentManager/OSResourceMonitor.ts","../src/subsystems/AgentManager/Agent.class.ts","../src/Core/SmythRuntime.class.ts","../src/subsystems/Security/SecureConnector.class.ts","../src/subsystems/IO/Storage.service/StorageConnector.ts","../src/subsystems/IO/Storage.service/connectors/S3Storage.class.ts","../src/subsystems/IO/Storage.service/index.ts","../src/subsystems/LLMManager/paramMappings.ts","../src/subsystems/LLMManager/LLM.service/LLMConnector.ts","../src/subsystems/LLMManager/LLM.service/connectors/Echo.class.ts","../src/subsystems/LLMManager/LLM.service/connectors/OpenAI.class.ts","../src/subsystems/LLMManager/LLM.service/connectors/GoogleAI.class.ts","../src/subsystems/LLMManager/LLM.service/connectors/AnthropicAI.class.ts","../src/subsystems/LLMManager/LLM.service/index.ts","../src/subsystems/MemoryManager/Cache.service/CacheConnector.ts","../src/subsystems/MemoryManager/Cache.service/connectors/RedisCache.class.ts","../src/subsystems/MemoryManager/Cache.service/index.ts","../src/subsystems/Security/Vault.service/VaultConnector.ts","../src/subsystems/Security/Vault.service/connectors/JSONFileVault.class.ts","../src/subsystems/Security/Vault.service/index.ts","../src/subsystems/Security/Account.service/AccountConnector.ts","../src/subsystems/Security/Account.service/index.ts","../src/subsystems/AgentManager/AgentData.service/AgentDataConnector.ts","../src/subsystems/AgentManager/AgentData.service/connectors/CLIAgentDataConnector.class.ts","../src/subsystems/AgentManager/AgentData.service/connectors/LocalAgentDataConnector.class.ts","../src/subsystems/AgentManager/AgentData.service/index.ts","../src/subsystems/IO/VectorDB.service/VectorDBConnector.ts","../src/subsystems/IO/VectorDB.service/connectors/PineconeVectorDB.class.ts","../src/subsystems/IO/VectorDB.service/index.ts","../src/subsystems/IO/CLI.service/CLIConnector.ts","../src/subsystems/IO/CLI.service/index.ts","../src/subsystems/IO/NKV.service/NKVConnector.ts","../src/subsystems/IO/NKV.service/connectors/NKVRedis.class.ts","../src/subsystems/IO/NKV.service/index.ts","../src/Core/boot.ts","../src/index.ts"],"sourcesContent":["export default class AgentRequest {\n    public headers: any;\n    public body: any;\n    public query: any;\n    public params: any;\n    public method: string = 'GET';\n    public path: string = '';\n    public sessionID: string = '';\n    public res: Response | null = null;\n    public req: Request | null = null;\n    public files: any[] = [];\n    public _agent_authinfo: any;\n    constructor(req?: AgentRequest | string[] | any) {\n        if (!req) return;\n        this.headers = JSON.parse(JSON.stringify(req.headers || {}));\n        this.body = JSON.parse(JSON.stringify(req.body || req.data || {}));\n        this.query = JSON.parse(JSON.stringify(req.query || {}));\n        this.params = JSON.parse(JSON.stringify(req.params || {}));\n\n        if (req.url) {\n            const parsedUrl = new URL(req.url || '');\n            this.path = parsedUrl.pathname;\n        }\n        if (req.path) this.path = req.path;\n\n        this.method = req.method;\n\n        this.sessionID = req.sessionID;\n        this.files = req.files || [];\n        this._agent_authinfo = req._agent_authinfo;\n\n        this.req = req instanceof AgentRequest ? req?.req : req;\n        this.res = req?.res || null;\n    }\n    header(name: string) {\n        return this.headers[name.toLowerCase()];\n    }\n}\n","import { AgentDataService } from '@sre/AgentManager/AgentData.service';\nimport { CLIService } from '@sre/IO/CLI.service';\nimport { NKVService } from '@sre/IO/NKV.service';\nimport { StorageService } from '@sre/IO/Storage.service';\nimport { VectorDBService } from '@sre/IO/VectorDB.service';\nimport { LLMService } from '@sre/LLMManager/LLM.service';\nimport { CacheService } from '@sre/MemoryManager/Cache.service';\nimport { AccountService } from '@sre/Security/Account.service';\nimport { VaultService } from '@sre/Security/Vault.service';\n\nexport type TServiceRegistry = {\n    Storage?: StorageService;\n    VectorDB?: VectorDBService;\n    Cache?: CacheService;\n    LLM?: LLMService;\n    Vault?: VaultService;\n    Account?: AccountService;\n    AgentData?: AgentDataService;\n    CLI?: CLIService;\n    NKV?: NKVService;\n};\n\nexport enum TConnectorService {\n    Storage = 'Storage',\n    VectorDB = 'VectorDB',\n    Cache = 'Cache',\n    LLM = 'LLM',\n    Vault = 'Vault',\n    Account = 'Account',\n    AgentData = 'AgentData',\n    CLI = 'CLI',\n    NKV = 'NKV',\n}\n\nexport type SREConnectorConfig = {\n    Connector: string;\n    Default?: boolean;\n    Settings?: {\n        [hashedOwnerKey: string]: any;\n    };\n};\n\nexport type SREConfig = {\n    [key in TConnectorService]?: SREConnectorConfig[] | SREConnectorConfig;\n};\n","import pLimit from 'p-limit';\nexport function uid() {\n    return (Date.now() + Math.random()).toString(36).replace('.', '').toUpperCase();\n}\n\n/**\n * this function is used to check if a class is a subclass of another class\n * @param subClass\n * @param superClass\n * @returns\n */\nexport function isSubclassOf(subClass: any, superClass: any): boolean {\n    if (typeof subClass !== 'function' || typeof superClass !== 'function') {\n        return false;\n    }\n\n    let prototype = Object.getPrototypeOf(subClass.prototype);\n    let depth = 10;\n\n    while (prototype && depth >= 0) {\n        if (prototype === superClass.prototype) {\n            return true;\n        }\n        prototype = Object.getPrototypeOf(prototype);\n        depth++;\n    }\n\n    return false;\n}\n\n/**\n * Processes an array of tasks concurrently with a specified concurrency limit.\n *\n * @template T - The type of the result returned by each task.\n *\n * @param {(() => Promise<T>)[]} tasks - An array of functions that return promises.\n * Each function represents a task to be processed.\n * @param {number} [maxConcurrentTasks=10] - The maximum number of concurrent tasks.\n *\n * @returns {Promise<T[]>} - A promise that resolves to an array of results.\n * Only successfully fulfilled promises are included in the result array.\n *\n * @throws {TypeError} - Throws an error if the tasks parameter is not an array of functions.\n *\n * @example\n * const tasks = [\n *     () => await processFile('file1.txt'),\n *     () => await processFile('file2.txt'),\n *     () => await processFile('file3.txt'),\n * ];\n *\n * const maxConcurrentTasks = 2;\n *\n * processWithConcurrencyLimit(tasks, maxConcurrentTasks)\n *     .then(results => console.log(results)) // Array of results from the fulfilled promises\n *     .catch(error => console.error(error));\n *\n * @note Currently, this function ignores tasks that fail to process.\n *       Only successfully fulfilled promises are included in the result array.\n *       To improve this behavior, we could add an option to control whether to exit the function if a task fails.\n */\nexport async function processWithConcurrencyLimit<T>(tasks: (() => Promise<T>)[], maxConcurrentTasks: number = 10): Promise<T[]> {\n    const limit = pLimit(maxConcurrentTasks);\n\n    const limitedTasks = tasks.map((task) => limit(task));\n\n    const results = await Promise.allSettled(limitedTasks);\n\n    // Filter for successfully fulfilled promises and extract their values\n    const validResults = results.flatMap((result) => (result.status === 'fulfilled' ? [result.value] : []));\n\n    return validResults;\n}\n\nexport const detectURLSourceType = (url: string) => {\n    const urlObj = new URL(url);\n    const ext = urlObj.pathname.split('.').pop();\n\n    switch (ext) {\n        case 'pdf':\n            return 'PDF';\n        case 'xml':\n            return 'SITEMAP';\n        case 'html':\n        case 'htm':\n        case 'txt':\n            return 'WEBPAGE';\n        case 'doc':\n        case 'docx':\n            return 'WORD';\n        default:\n            return 'WEBPAGE';\n    }\n};\n","export function getCurrentFormattedDate() {\n    const date = new Date();\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based\n    const day = String(date.getDate()).padStart(2, '0');\n    const hours = String(date.getHours()).padStart(2, '0');\n    const minutes = String(date.getMinutes()).padStart(2, '0');\n    const seconds = String(date.getSeconds()).padStart(2, '0');\n    return `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n}\n\nexport function getDayFormattedDate() {\n    const date = new Date();\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based\n    const day = String(date.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n}\n\nexport function delay(ms) {\n    return new Promise((r) => setTimeout(r, ms));\n}\n","/**\n * perform a replace operation on a string asynchronously\n * @param str\n * @param regex\n * @param asyncFn\n * @returns\n */\nexport async function asyncReplace(str, regex, asyncFn) {\n    const matches = [];\n    let match;\n\n    // Find all matches and store them in an array\n    while ((match = regex.exec(str)) !== null) {\n        matches.push(match);\n    }\n\n    // Process each match asynchronously\n    const replacements = await Promise.all(\n        matches.map(async (match) => {\n            // Call the async function with all match groups\n            return asyncFn(...match);\n        })\n    );\n\n    // Reassemble the string with replacements\n    let result = '';\n    let lastIndex = 0;\n\n    matches.forEach((match, index) => {\n        result += str.slice(lastIndex, match.index) + replacements[index];\n        lastIndex = match.index + match[0].length;\n    });\n\n    // Append the remaining part of the string\n    result += str.slice(lastIndex);\n\n    return result;\n}\n\nexport function isValidString(str: string): boolean {\n    return str && typeof str === 'string';\n}\n","import { fileTypeFromBuffer } from 'file-type';\nimport { isValidString } from './string.utils';\n\n/**\n * This function converts a text string to a base64 URL.\n * @param text\n * @returns\n */\nexport function textToBase64Url(text) {\n    // Create a Buffer from the string\n    const buffer = Buffer.from(text, 'utf-8');\n\n    // Convert the Buffer to a base64 string\n    const base64String = buffer.toString('base64');\n\n    // Construct the data URL\n    const base64Url = `data:text/plain;base64,${base64String}`;\n\n    return base64Url;\n}\n\n//=== Legacy code below ===\n//@Forhad the functions below need to be reviewed and refactored\n\n/**\n * Remove all whitespace characters and literal \\n and \\s sequences\n *\n * @note It's common practice to split base64 data into multiple lines for better readability and to avoid issues with systems that can't handle very long lines. So we need to clean up newline characters from the base64 data before processing it.\n * @param {string} str - The input string.\n * @returns {string} The input string with all newline characters and escaped newline strings removed.\n */\nfunction cleanBase64(str: string): string {\n    return str.replace(/\\s|\\\\n|\\\\s/g, '');\n}\n\n/**\n * Checks if the input is a data URL.\n *\n * @param {string} input - The input string.\n * @returns {boolean} True if the input is a data URL, false otherwise.\n */\nexport function isDataUrl(input: string): boolean {\n    // Data URL pattern: data:[<mediatype>][;base64],<data>\n    const dataUrlPattern = /^data:([\\w+\\-\\.]+\\/[\\w+\\-\\.]+);base64,(.*)$/;\n\n    return dataUrlPattern.test(input);\n}\n\n/**\n * Checks if the given string is a valid Base64-encoded string.\n *\n * @param {string} str - The string to check.\n * @returns {boolean} True if the string is a valid Base64-encoded string, false otherwise.\n */\nexport function isRawBase64(str: string): boolean {\n    if (!isValidString(str)) return false;\n\n    const cleanedBase64Data = cleanBase64(str);\n\n    // Sometimes words like 'male' and hashes like md5, sha1, sha256, sha512 are detected as base64\n    if (cleanedBase64Data.length < 128) return false;\n\n    try {\n        const buffer = Buffer.from(cleanedBase64Data, 'base64');\n\n        // ignoring trailing padding ensures that the comparison is based on the actual content, not the padding\n        return buffer.toString('base64').replace(/=+$/, '') === cleanedBase64Data.replace(/=+$/, '');\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Parses a Base64-encoded string or data URL and extracts the MIME type and cleaned data.\n *\n * @param {string} input - The Base64-encoded string or data URL.\n * @returns {Promise<{ mimetype: string; data: string }>} An object containing the MIME type and the cleaned Base64 data.\n * @throws {Error} If the input is invalid.\n */\nexport async function parseBase64(input: string): Promise<{ mimetype: string; data: string }> {\n    try {\n        if (isDataUrl(input)) {\n            return parseDataUrl(input);\n        }\n\n        if (!isRawBase64(input)) {\n            throw new Error('Invalid base64 data!');\n        }\n\n        return await parseRawBase64(input);\n    } catch (error) {\n        throw new Error(`Error parsing base64 data: ${error.message}`);\n    }\n}\n\n/**\n * Parses a Base64-encoded data URL and extracts the MIME type and cleaned data.\n *\n * @param {string} input - The Base64-encoded data URL.\n * @returns {{ mimetype: string; data: string }} An object containing the MIME type and the cleaned Base64 data.\n * @throws {Error} If the input is invalid.\n */\nfunction parseDataUrl(input: string): { mimetype: string; data: string } {\n    const dataUrlPattern = /^data:([\\w+\\-\\.]+\\/[\\w+\\-\\.]+);base64,(.*)$/;\n    const matches = input.match(dataUrlPattern);\n\n    if (!matches) {\n        throw new Error('Invalid data URL!');\n    }\n\n    const [, mimetype, data] = matches;\n\n    if (!isRawBase64(data)) {\n        throw new Error('Invalid base64 data!');\n    }\n\n    return { mimetype, data: cleanBase64(data) };\n}\n\n/**\n * Parses a raw Base64-encoded string and extracts the MIME type and cleaned data.\n *\n * @param {string} input - The raw Base64-encoded string.\n * @returns {Promise<{ mimetype: string; data: string }>} An object containing the MIME type and the cleaned Base64 data.\n */\nasync function parseRawBase64(input: string): Promise<{ mimetype: string; data: string }> {\n    const cleanedData = cleanBase64(input);\n    const mimetype = await identifyMimetypeFromRawBase64(cleanedData);\n\n    return { mimetype, data: cleanedData };\n}\n\n/**\n * Identifies the MIME type from a raw Base64-encoded string.\n *\n * This function cleans the input Base64 string, converts it to a buffer, and then identifies the MIME type\n * using the `fileTypeFromBuffer` function.\n *\n * @param {string} data - The raw Base64-encoded string from which to identify the MIME type.\n * @returns {Promise<string>} A promise that resolves to the MIME type of the data, or an empty string if the MIME type cannot be determined.\n *\n * @throws {Error} If an error occurs during the process, it logs the error and returns an empty string.\n */\nexport async function identifyMimetypeFromRawBase64(data: string): Promise<string> {\n    try {\n        const cleanedData = cleanBase64(data);\n\n        // Convert the base64 string back to a Buffer\n        const buffer = Buffer.from(cleanedData, 'base64');\n\n        const type = await fileTypeFromBuffer(buffer);\n\n        return type?.mime || '';\n    } catch (error) {\n        throw new Error(`Error identifying MIME type from base64 data: ${error?.message}`);\n    }\n}\n\n/**\n * Identifies the MIME type from a raw Base64-encoded string.\n *\n * This function cleans the input Base64 string, converts it to a buffer, and then identifies the MIME type\n * using the `fileTypeFromBuffer` function.\n *\n * @param {string} data - The raw Base64-encoded string from which to identify the MIME type.\n * @returns {Promise<string>} A promise that resolves to the MIME type of the data, or an empty string if the MIME type cannot be determined.\n *\n * @throws {Error} If an error occurs during the process, it logs the error and returns an empty string.\n */\nexport async function identifyMimeTypeFromBase64(input: string): Promise<string> {\n    try {\n        const { data } = await parseBase64(input);\n\n        const buffer = Buffer.from(data, 'base64');\n\n        const type = await fileTypeFromBuffer(buffer);\n\n        return type?.mime || '';\n    } catch (error) {\n        throw new Error(`Error identifying MIME type from base64 data: ${error?.message}`);\n    }\n}\n\n/**\n * Calculates the size of a Base64-encoded string in bytes.\n *\n * This function validates the input string to ensure it is a valid Base64-encoded string,\n * converts it to a buffer, and then returns the byte length of the buffer.\n *\n * @param {string} str - The Base64-encoded string whose size is to be calculated.\n * @returns {number} The size of the Base64-encoded string in bytes.\n *\n * @throws {Error} If the input string is not a valid Base64-encoded string or if an error occurs during conversion.\n */\nexport function getSizeOfBase64(str: string): number {\n    if (!isValidString(str)) {\n        throw new Error('Invalid Base64 data!');\n    }\n\n    try {\n        const buffer = Buffer.from(str, 'base64');\n        return buffer.byteLength;\n    } catch (error) {\n        throw new Error(`Invalid Base64 data! ${error.message}`);\n    }\n}\n\n/**\n * Generates a Base64 Data URL from a raw Base64-encoded string.\n *\n * This function validates the input Base64 string, removes any newline characters,\n * and constructs a Data URL with the specified MIME type.\n *\n * @param {string} data - The raw Base64-encoded string to be converted into a Data URL.\n * @param {string} [mimetype='application/octet-stream'] - The MIME type of the data. Defaults to 'application/octet-stream'.\n * @returns {string} The generated Base64 Data URL.\n *\n * @throws {Error} If the input string is not a valid Base64-encoded string.\n */\nexport function makeBase64Url(data: string, mimetype: string = 'application/octet-stream'): string {\n    if (!isValidString(data)) {\n        throw new Error('Invalid Base64 data!');\n    }\n\n    // Remove any newline characters from the Base64 string\n    const cleanedData = data.replace(/\\n/g, '');\n\n    // Construct and return the Data URL\n    return `data:${mimetype};base64,${cleanedData}`;\n}\n","import { Readable } from 'stream';\nimport { isRawBase64 } from './base64.utils';\nimport { isBinaryFileSync } from 'isbinaryfile';\n\n// Helper function to convert stream to buffer\nexport async function streamToBuffer(stream: Readable): Promise<Buffer> {\n    const chunks: Buffer[] = [];\n    for await (const chunk of stream) {\n        chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk);\n    }\n    return Buffer.concat(chunks);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n// == Helpers from Legacy Smyth implementation ==============================================\n// FIXME : below functions should probably be converted to a validator\n\n//export declare function isBinaryFile(file: string | Buffer, size?: number): Promise<boolean>;\n//export declare function isBinaryFileSync(file: string | Buffer, size?: number): boolean;\nconst binaryMimeTypes = ['image/', 'audio/', 'video/', 'application/pdf', 'application/zip', 'application/octet-stream'];\n\nexport function dataToBuffer(data: any): Buffer | null {\n    let bufferData;\n    switch (true) {\n        case data instanceof ArrayBuffer:\n            bufferData = Buffer.from(new Uint8Array(data));\n            break;\n        case ArrayBuffer.isView(data) && !(data instanceof DataView):\n            bufferData = Buffer.from(new Uint8Array(data.buffer));\n            break;\n        case data instanceof DataView:\n            bufferData = Buffer.from(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\n            break;\n        case Buffer.isBuffer(data):\n            bufferData = data;\n            break;\n        case typeof data === 'string':\n            bufferData = Buffer.from(data, 'utf-8');\n            break;\n        default:\n            return null;\n    }\n\n    return bufferData;\n}\n\nexport const getSizeFromBinary = (data: any) => {\n    const buffer = dataToBuffer(data);\n    if (!buffer) return 0;\n    return buffer.byteLength;\n};\n\nexport const isPlainObject = (data: any): boolean => {\n    return (\n        typeof data === 'object' &&\n        data !== null &&\n        !Array.isArray(data) &&\n        Object.prototype.toString.call(data) === '[object Object]' &&\n        data.constructor === Object\n    );\n};\n\n// isBuffer checks if the provided data is a Buffer object in Node.js.\nexport const isBuffer = (data: any): boolean => {\n    try {\n        return Buffer.isBuffer(data);\n    } catch {\n        // Buffer.isBuffer throws error when non-array Object is passed\n        return false;\n    }\n};\n\n// isBinaryMimeType checks if the provided mimetype indicates binary data.\nexport const isBinaryMimeType = (mimetype): boolean => {\n    if (mimetype) {\n        return binaryMimeTypes.some((type) => mimetype.startsWith(type));\n    }\n    return false;\n};\n\n// isBinaryData checks if the provided data is binary.\n// If the data is a Buffer, ArrayBuffer, TypedArray, or DataView, it checks if it contains binary data.\nexport const isBinaryData = (data): boolean => {\n    // To prevent returning true when we have emojis in the string like \"Hello ðŸ˜€\"\n    if (typeof data === 'string') return false;\n\n    try {\n        const buffer = dataToBuffer(data);\n        if (!buffer) return false;\n        return isBinaryFileSync(buffer, buffer.byteLength);\n    } catch (error) {\n        return false;\n    }\n};\nexport function isUrl(str: string): boolean {\n    if (typeof str !== 'string') return false;\n    // This regex checks for protocol, hostname, domain, port (optional), path (optional), and query string (optional)\n    //const regex = /^(https?:\\/\\/)([^\\s.]+\\.[^\\s]{2,})(:[0-9]{1,5})?(\\/[^\\s]*)?(\\?[^\\s]*)?$/i;\n    const regex = /^([a-zA-Z0-9]+:\\/\\/)([^\\s.]+\\.[^\\s]{2,})(:[0-9]{1,5})?(\\/[^\\s]*)?(\\?[^\\s]*)?$/i;\n\n    return regex.test(str);\n}\n\nexport const isSmythFileObject = (data: any): boolean => {\n    return !!(typeof data === 'object' && data !== null && data?.url && isUrl(data?.url) && 'size' in data && 'mimetype' in data);\n};\n\nexport const isBufferObject = (data: Record<string, any>): boolean => {\n    if (!data) return false;\n\n    return typeof data === 'object' && data !== null && data?.buffer && isBuffer(data.buffer) && 'size' in data && 'mimetype' in data;\n};\n\nexport const isBase64Object = (data: Record<string, any>): boolean => {\n    if (!data) return false;\n\n    return typeof data === 'object' && data !== null && data?.base64 && isRawBase64(data.base64) && 'size' in data && 'mimetype' in data;\n};\n","/**\n * This function parses the command line arguments and returns an object with the parsed values.\n * The expected format is --file ./path/to/file.txt or --settings key1=value1 key2=value2\n * Examples:\n *  --file ./path/to/file.txt : calling parseCLIArgs('file', process.argv) will return {file: './path/to/file.txt'}\n *  --settings key1=value1 key2=value2 : calling parseCLIArgs('settings', process.argv) will return {settings: {key1: 'value1', key2: 'value2'}}\n *  it can also parse multiple arguments at once, for example:\n *      parseCLIArgs(['file', 'settings'], process.argv) will return {file: './path/to/file.txt', settings: {key1: 'value1', key2: 'value2'}}\n *\n * @param argList the argument to parse\n * @param argv the command line arguments, usually process.argv\n * @returns parsed arguments object\n */\n\nexport function parseCLIArgs(argList: string | Array<string>, argv?: Array<string>): Record<string, any> {\n    if (!argv) argv = process.argv;\n    const args = argv;\n    const result = {};\n    const mainArgs = Array.isArray(argList) ? argList : [argList];\n    mainArgs.forEach((mainArg) => {\n        const mainArgIndex = args.indexOf(`--${mainArg}`);\n        if (mainArgIndex !== -1) {\n            const values: any = [];\n            for (let i = mainArgIndex + 1; i < args.length; i++) {\n                if (args[i].startsWith('--')) break;\n                values.push(args[i]);\n            }\n\n            if (values.length === 1 && values[0].includes('=')) {\n                const keyValuePairs = {};\n                const [key, ...valParts] = values[0].split('=');\n                const val = valParts.join('=').replace(/^\"|\"$/g, '');\n                keyValuePairs[key] = val;\n                result[mainArg] = keyValuePairs;\n            } else if (values.length === 1) {\n                result[mainArg] = values[0];\n            } else if (values.length > 1) {\n                const keyValuePairs = {};\n                values.forEach((value) => {\n                    const [key, ...valParts] = value.split('=');\n                    const val = valParts.join('=').replace(/^\"|\"$/g, '');\n                    keyValuePairs[key] = val;\n                });\n                result[mainArg] = keyValuePairs;\n            }\n        }\n    });\n\n    return result;\n}\n\n/**\n * List all cli main arguments\n * example : node index.js --file ./path/to/file.txt --settings key1=value1 key2=value2\n * calling getMainArgs(process.argv) will return ['file', 'settings']\n */\nexport function getMainArgs(argv?: Array<string>): Array<string> {\n    if (!argv) argv = process.argv;\n    const args = argv;\n    const result = [];\n    for (let i = 2; i < args.length; i++) {\n        if (args[i].startsWith('--')) {\n            result.push(args[i].replace(/^--/, ''));\n        }\n    }\n\n    return result;\n}\n","import axios from 'axios';\nimport { fileTypeFromBuffer } from 'file-type';\n\nexport async function getMimeTypeFromUrl(url: string): Promise<string> {\n    try {\n        // Fetch the first 4100 bytes of the URL content\n        const { data } = await axios.get(url, {\n            responseType: 'arraybuffer',\n            headers: { Range: 'bytes=0-4096' },\n        });\n\n        // Use file-type to determine the MIME type from the binary data\n        const type = await fileTypeFromBuffer(data);\n\n        return type ? type.mime : '';\n    } catch (error) {\n        throw new Error(`Error fetching the MIME type: ${error.message}`);\n    }\n}\n","interface RangeValidationArgs {\n    min?: number;\n    max?: number;\n}\n\n/**\n * Custom validation function to check if a string contains only specified characters.\n * @param {string} value - The string to validate.\n * @returns {string} - The validated string.\n */\nexport function validateCharacterSet(value: string): boolean {\n    if (value === '') return true;\n    // Check for {{sometext}} structures and split the string\n    const parts = value.split(/(\\{\\{[^}]+\\}\\})/).filter(Boolean);\n\n    for (const part of parts) {\n        if (part.startsWith('{{') && part.endsWith('}}')) {\n            // Check if the content inside {{...}} is not empty\n            const innerContent = part.slice(2, -2).trim();\n            if (innerContent === '') {\n                return false; // Empty content inside {{...}}\n            }\n        } else {\n            // Check for valid characters outside of {{...}}\n            if (!/^[a-zA-Z0-9\\-_.]+$/.test(part)) {\n                return false; // Invalid characters found\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Validates whether a given string value can be converted to an integer that falls within a specified range.\n * This function is designed to be used as a custom validator in Joi schemas.\n *\n * @param {RangeValidationArgs} args - An object containing optional 'min' and 'max' properties to define the range.\n * @returns {Function} A function that takes a string value and a Joi helper object, and performs the validation.\n *\n * The validation function first converts the string value to a number. It then checks if the number is within the\n * specified range (if provided). If the value is not a number or falls outside the range, it throws an error with a\n * descriptive message.\n *\n * The error message includes the field name for clarity, using the label from the Joi schema if available.\n */\nexport const validateInteger = (args: RangeValidationArgs) => {\n    return (value: string, helpers: any) => {\n        const numValue = Number(value);\n        const fieldName = helpers.schema._flags.label || helpers.state.path[helpers.state.path.length - 1];\n\n        // Check if the value is a number\n        if (isNaN(numValue)) {\n            throw new Error(`The value for '${fieldName}' must be a number`);\n        }\n\n        // Range validations\n        if (args.min !== undefined && args.max !== undefined) {\n            if (numValue < args.min || numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be from ${args.min} to ${args.max}`);\n            }\n        } else if (args.min !== undefined) {\n            if (numValue < args.min) {\n                throw new Error(`The value for '${fieldName}' must be greater or equal to ${args.min}`);\n            }\n        } else if (args.max !== undefined) {\n            if (numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be less or equal to ${args.max}`);\n            }\n        }\n\n        return value; // Value is valid\n    };\n};\n","import dotenv from 'dotenv';\ndotenv.config();\n//FIXME : this is a legacy structure from Smyth SaaS we need to convert it to a Service/Connector structure\nconst config = {\n    env: {\n        LOG_LEVEL: process.env.LOG_LEVEL || 'none',\n        LOG_FILTER: process.env.LOG_FILTER || '',\n\n        OPENAI_API_KEY: process.env.OPENAI_API_KEY,\n        ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,\n\n        DATA_PATH: process.env.DATA_PATH,\n\n        NODE_ENV: process.env?.NODE_ENV,\n\n        AGENT_DOMAIN: process.env?.AGENT_DOMAIN,\n\n        AGENT_DOMAIN_PORT: process.env?.AGENT_DOMAIN_PORT,\n        CODE_SANDBOX_URL: process.env?.CODE_SANDBOX_URL,\n        TOGETHER_AI_API_URL: process.env?.TOGETHER_AI_API_URL,\n\n        REDIS_SENTINEL_HOSTS: process.env?.REDIS_SENTINEL_HOSTS || '',\n        REDIS_MASTER_NAME: process.env?.REDIS_MASTER_NAME,\n        REDIS_PASSWORD: process.env?.REDIS_PASSWORD,\n\n        AWS_ACCESS_KEY_ID: process.env.AWS_ACCESS_KEY_ID,\n        AWS_SECRET_ACCESS_KEY: process.env.AWS_SECRET_ACCESS_KEY,\n        AWS_S3_REGION: process.env.AWS_S3_REGION,\n        AWS_S3_BUCKET_NAME: process.env.AWS_S3_BUCKET_NAME,\n\n        PINECONE_API_KEY: process.env.PINECONE_API_KEY,\n        PINECONE_INDEX_NAME: process.env.PINECONE_INDEX_NAME,\n    },\n    agent: {\n        ENDPOINT_PREFIX: '/api',\n    },\n};\n\nexport default config;\n","import 'dotenv/config';\nimport winston from 'winston';\nimport Transport from 'winston-transport';\nimport { parseCLIArgs } from '../utils';\nimport config from '@sre/config';\n\nwinston.addColors({\n    error: 'red',\n    warn: 'yellow',\n    info: 'green',\n    debug: 'blue',\n});\n\nlet logLevel = parseCLIArgs('debug')?.debug || config.env.LOG_LEVEL || 'info';\nif (!['none', 'error', 'warn', 'info', 'debug'].includes(logLevel)) {\n    logLevel = 'none';\n}\n\n// Retrieve the DEBUG environment variable and split it into an array of namespaces\nconst namespaces = (config.env.LOG_FILTER || '').split(',');\n\n// Create a Winston format that filters messages based on namespaces\nconst namespaceFilter = winston.format((info) => {\n    // If DEBUG is not set, log everything\n    if (!config.env.LOG_FILTER || namespaces.some((ns) => info.module?.includes(ns))) {\n        return info;\n    }\n    return false; // Filter out messages that do not match the namespace\n})();\n\n// Custom stream for your transport\nclass ArrayTransport extends Transport {\n    private logs: any[];\n    constructor(opts) {\n        super(opts);\n        // Configure your storage array\n        this.logs = opts.logs;\n    }\n\n    log(info, callback) {\n        setImmediate(() => {\n            this.emit('logged', info);\n        });\n\n        // Perform the writing to the array storage\n        this.logs.push(`${info.level}: ${info.message}`);\n\n        // Perform the writing to the remote service\n        callback();\n    }\n}\n\nexport class LogHelper {\n    public startTime = Date.now();\n    public get output() {\n        return Array.isArray(this.data) ? this.data.join('\\n') : undefined;\n    }\n    public get elapsedTime() {\n        return Date.now() - this.startTime;\n    }\n    constructor(private _logger: winston.Logger, public data, private labels: { [key: string]: any }) {}\n\n    public log(...args) {\n        this._logger.log('info', formatLogMessage(...args), this.labels);\n    }\n    public warn(...args) {\n        this._logger.log('warn', formatLogMessage(...args), this.labels);\n    }\n    public debug(...args) {\n        this._logger.log('debug', formatLogMessage(...args), this.labels);\n    }\n    public info(...args) {\n        this._logger.log('info', formatLogMessage(...args), this.labels);\n    }\n    public verbose(...args) {\n        this._logger.log('verbose', formatLogMessage(...args), this.labels);\n    }\n\n    public error(...args) {\n        const stack = new Error().stack;\n\n        this._logger.log('error', formatLogMessage(...args), { ...this.labels, stack });\n    }\n\n    public close() {\n        this._logger.clear();\n        this._logger.close();\n    }\n}\n\nconst colorizedFormat = winston.format.printf((info) => {\n    return `${info.timestamp} ${winston.format.colorize().colorize(info.level, `${info.level}: ${info.message}`)}`;\n});\n\nconst MAX_LOG_MESSAGE_LENGTH = 500;\n\nfunction createBaseLogger(memoryStore?: any[]) {\n    const logger = winston.createLogger({\n        //level: 'info', // log level\n\n        format: winston.format.combine(\n            winston.format((info) => {\n                if (config.env.LOG_LEVEL == 'none') return false; // skip logging if log level is none\n\n                return info;\n            })(),\n            winston.format.timestamp(),\n            winston.format.errors({\n                stack: true,\n            }),\n            winston.format.splat(),\n            winston.format.json()\n        ),\n\n        transports: [\n            new winston.transports.Console({\n                level: 'error',\n                //handleExceptions: true,\n                format: winston.format.combine(\n                    winston.format.printf((info) => {\n                        let message = info.message;\n                        //message = message?.length > MAX_LOG_MESSAGE_LENGTH ? message.substring(0, MAX_LOG_MESSAGE_LENGTH) + '...' : message;\n                        return `${info.level}:${info.module || ''} ${message} ${info.stack || ''}`;\n                    })\n                ),\n                stderrLevels: ['error'], // Define levels that should be logged to stderr\n            }),\n            new winston.transports.Console({\n                level: logLevel,\n                format: winston.format.combine(\n                    namespaceFilter,\n                    winston.format.printf((info) => {\n                        const module = info.module ? winston.format.colorize().colorize(info.level, ` [${info.module}]`) : '';\n                        const ns = winston.format.colorize().colorize(info.level, `${info.level}${module}`);\n\n                        let message = info.message;\n                        //message = message?.length > MAX_LOG_MESSAGE_LENGTH ? message.substring(0, MAX_LOG_MESSAGE_LENGTH) + '...' : message;\n\n                        return `${ns} - ${message}`;\n                    })\n                ),\n\n                //handleExceptions: true,\n            }),\n        ],\n    });\n\n    if (Array.isArray(memoryStore)) {\n        logger.add(\n            new ArrayTransport({\n                level: 'debug',\n                logs: memoryStore,\n            })\n        );\n    }\n\n    return logger;\n}\n\nfunction formatLogMessage(...args) {\n    return args\n        .map((arg) => {\n            // If the argument is an object (and not null), serialize it to JSON\n            if (typeof arg === 'object' && arg !== null && !(arg instanceof Error)) {\n                return JSON.stringify(arg, null, 2); // set the space to 2 for better readability\n            }\n            // Otherwise, just convert it to a string in case it's not\n            return String(arg);\n        })\n        .join(' '); // Concatenate all arguments with a space\n}\n\nfunction createLabeledLogger(labels: { [key: string]: any }, memoryStore?: any[]) {\n    const _logger = createBaseLogger(memoryStore);\n\n    _logger.defaultMeta = labels;\n\n    const logger = new LogHelper(_logger, memoryStore, labels);\n\n    return logger;\n}\n\nexport function Logger(module: string, withMemoryStore = false) {\n    return createLabeledLogger({ module }, withMemoryStore ? [] : undefined);\n}\n","import { Logger } from '../helpers/Log.helper';\nconst logger = Logger('DummyConnector');\n/**\n * DummyConnector is a placeholder for unimplemented connectors, it logs a warning when a method is called in order to help developers identify missing connectors\n */\nexport const DummyConnector: any = new Proxy(\n    {},\n    {\n        get: function (target, prop, receiver) {\n            // Check if the property being accessed is a function\n            if (typeof target[prop] === 'function') {\n                return target[prop];\n            } else {\n                // Return a function that logs \"unavailable\"\n                return function (...args: any[]) {\n                    logger.warn(`[!!] Unimplemented Connector tried to call : ${prop.toString()} with arguments:`, args);\n                };\n            }\n        },\n    }\n);\n","import { Logger } from '../helpers/Log.helper';\n\nconst console = Logger('Connector');\n\nexport abstract class Connector {\n    public abstract name: string;\n    public started = false;\n    private _readyPromise: Promise<boolean>;\n\n    public async start() {\n        console.info(`Starting ${this.name} connector ...`);\n        this.started = true;\n    }\n\n    public async stop() {\n        console.info(`Stopping ${this.name} connector ...`);\n    }\n\n    public ready() {\n        if (!this._readyPromise) {\n            this._readyPromise = new Promise((resolve) => {\n                let maxWait = 10000;\n                const tick = 100;\n                if (this.started) {\n                    resolve(true);\n                } else {\n                    const interval = setInterval(() => {\n                        if (this.started) {\n                            clearInterval(interval);\n                            resolve(true);\n                        }\n\n                        maxWait -= tick;\n                        if (maxWait <= 0) {\n                            clearInterval(interval);\n                            resolve(false);\n                        }\n                    }, tick);\n                }\n            });\n        }\n        return this._readyPromise;\n    }\n}\n","import { EventEmitter } from 'events';\n\nconst SystemEvents = new EventEmitter();\n\nexport default SystemEvents;\n","import { SREConnectorConfig, TConnectorService, TServiceRegistry } from '@sre/types/SRE.types';\nimport { DummyConnector } from './DummyConnector';\nimport { Logger } from '../helpers/Log.helper';\nimport { Connector } from './Connector.class';\nimport { isSubclassOf } from '@sre/utils';\nimport SystemEvents from './SystemEvents';\nimport { StorageConnector } from '@sre/IO/Storage.service/StorageConnector';\nimport { CacheConnector } from '@sre/MemoryManager/Cache.service';\nimport { LLMConnector } from '@sre/LLMManager/LLM.service/LLMConnector';\nimport { VaultConnector } from '@sre/Security/Vault.service/VaultConnector';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport { AgentDataConnector } from '@sre/AgentManager/AgentData.service/AgentDataConnector';\nimport { VectorDBConnector } from '@sre/IO/VectorDB.service/VectorDBConnector';\nimport { CLIConnector } from '@sre/IO/CLI.service/CLIConnector';\nimport { NKVConnector } from '@sre/IO/NKV.service/NKVConnector';\nconst console = Logger('ConnectorService');\n\nconst Connectors = {};\n\nconst ConnectorInstances: any = {};\nlet ServiceRegistry: TServiceRegistry = {};\nlet _ready = false;\nSystemEvents.on('SRE:Booted', (services) => {\n    ServiceRegistry = services;\n    _ready = true;\n});\nexport class ConnectorService {\n    //Singleton\n    // private constructor() {\n    //     SystemEvents.on('SRE:Booted', (services) => {\n    //         ServiceRegistry = services;\n    //     });\n    // }\n    // private static instance: ConnectorService;\n    // public static get Instance(): ConnectorService {\n    //     if (!ConnectorService.instance) {\n    //         ConnectorService.instance = new ConnectorService();\n    //     }\n    //     return ConnectorService.instance;\n    // }\n    public static get ready() {\n        return _ready;\n    }\n\n    public static get service(): TServiceRegistry {\n        return ServiceRegistry;\n    }\n    /**\n     * Allows SRE services to register their connectors, a registered conector can then be initialized and used by SRE or its services\n     * @param connectorType\n     * @param connectorName\n     * @param connectorConstructor\n     * @returns\n     */\n    static register(connectorType: TConnectorService, connectorName: string, connectorConstructor: any) {\n        if (typeof connectorConstructor !== 'function' || !isSubclassOf(connectorConstructor, Connector)) {\n            console.error(`Invalid Connector ${connectorType}:${connectorName}`);\n            return;\n        }\n        if (!Connectors[connectorType]) {\n            Connectors[connectorType] = {};\n        }\n        Connectors[connectorType][connectorName] = connectorConstructor;\n    }\n\n    /**\n     * The init method instantiates a connector and starts it, a connector cannot be used before it is initialized\n     * Usually the initialization phase happens during the SRE startup, but some connectors can be initialized later if they are not mandatory for the SRE to start\n     *\n     *\n     * @param connectorType\n     * @param connectorName\n     * @param settings\n     * @param isDefault\n     * @returns\n     */\n    static init(connectorType: TConnectorService, connectorName: string, settings: any = {}, isDefault = false) {\n        if (ConnectorInstances[connectorType]?.[connectorName]) {\n            throw new Error(`Connector ${connectorType}:${connectorName} already initialized`);\n        }\n\n        const entry = Connectors[connectorType];\n        if (!entry) return;\n        const connectorConstructor = entry[connectorName];\n\n        if (connectorConstructor) {\n            const connector: Connector = new connectorConstructor(settings);\n\n            connector.start();\n            if (!ConnectorInstances[connectorType]) ConnectorInstances[connectorType] = {};\n            ConnectorInstances[connectorType][connectorName] = connector;\n\n            if (!ConnectorInstances[connectorType].default && isDefault) {\n                ConnectorInstances[connectorType].default = connector;\n            }\n        }\n    }\n    static async _stop() {\n        for (let connectorName in ConnectorInstances) {\n            let allConnectors: Connector[] = Object.values(ConnectorInstances[connectorName]);\n            //deduplicate\n            allConnectors = allConnectors.filter((value, index, self) => self.indexOf(value) === index);\n            for (let connector of allConnectors) {\n                connector.stop();\n            }\n        }\n    }\n    static getInstance<T>(connectorType: TConnectorService, connectorName: string = 'default'): T {\n        const instance = ConnectorInstances[connectorType]?.[connectorName] as T;\n        if (!instance) {\n            if (ConnectorInstances[connectorType] && Object.keys(ConnectorInstances[connectorType]).length > 0) {\n                //return the first instance\n                return ConnectorInstances[connectorType][Object.keys(ConnectorInstances[connectorType])[0]] as T;\n            }\n            console.warn(`Connector ${connectorType} not initialized returning DummyConnector`);\n            return DummyConnector as T;\n        }\n        return instance;\n    }\n\n    // Storage?: StorageService;\n    // Cache?: CacheService;\n    // LLM?: LLMService;\n    // Vault?: VaultService;\n    // Account?: AccountService;\n\n    static getStorageConnector(name?: string): StorageConnector {\n        return ConnectorService.getInstance<StorageConnector>(TConnectorService.Storage, name);\n    }\n\n    static getCacheConnector(name?: string): CacheConnector {\n        return ConnectorService.getInstance<any>(TConnectorService.Cache, name);\n    }\n\n    static getVectorDBConnector(name?: string): VectorDBConnector {\n        return ConnectorService.getInstance<VectorDBConnector>(TConnectorService.VectorDB, name);\n    }\n\n    static getNKVConnector(name?: string): NKVConnector {\n        return ConnectorService.getInstance<NKVConnector>(TConnectorService.NKV, name);\n    }\n\n    static getLLMConnector(name?: string): LLMConnector {\n        return ConnectorService.getInstance<LLMConnector>(TConnectorService.LLM, name);\n    }\n\n    static getVaultConnector(name?: string): VaultConnector {\n        return ConnectorService.getInstance<VaultConnector>(TConnectorService.Vault, name);\n    }\n\n    static getAccountConnector(name?: string): AccountConnector {\n        return ConnectorService.getInstance<AccountConnector>(TConnectorService.Account, name);\n    }\n\n    static getAgentDataConnector(name?: string): AgentDataConnector {\n        return ConnectorService.getInstance<AgentDataConnector>(TConnectorService.AgentData, name);\n    }\n\n    static getCLIConnector(name?: string): CLIConnector {\n        return ConnectorService.getInstance<CLIConnector>(TConnectorService.CLI, name);\n    }\n\n    //TODO: add missing get<Connector> functions : e.g getAgentData(), getCache() etc ...\n\n    static hasInstance(connectorType: TConnectorService, connectorName: string = 'default') {\n        const instance = ConnectorInstances[connectorType]?.[connectorName];\n        return instance && instance !== DummyConnector;\n    }\n}\n\nexport abstract class ConnectorServiceProvider {\n    public abstract register();\n    public init() {}\n    public constructor() {\n        this.register();\n    }\n}\n","import { Logger } from '@sre/helpers/Log.helper';\nconst console = Logger('EmbodimentSettings');\n\nexport default class EmbodimentSettings {\n    private _embodiments: any;\n    private _ready = false;\n\n    constructor(agentId) {\n        this.init(agentId);\n    }\n\n    async init(data) {\n        this._embodiments = data;\n        this._ready = true;\n    }\n    public ready(maxWait = 10000) {\n        return new Promise((resolve, reject) => {\n            const interval = setInterval(() => {\n                if (this._ready) {\n                    clearInterval(interval);\n                    resolve(true);\n                }\n                maxWait -= 100;\n            }, 100);\n\n            setTimeout(() => {\n                clearInterval(interval);\n                reject(false);\n            }, maxWait);\n        });\n    }\n\n    public get(embodimentType: string, key?: string) {\n        if (!this._embodiments) return undefined;\n        const _embodiment = this._embodiments.find((embodiment: any) => embodiment.type?.toLowerCase() === embodimentType.toLowerCase());\n\n        if (!_embodiment) {\n            //console.error(`Error: No ${embodimentType} embodiment found for agent`);\n        }\n        if (key) {\n            return _embodiment?.properties?.[key];\n        }\n        return _embodiment?.properties;\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport EmbodimentSettings from './EmbodimentSettings.class';\n\nimport { Logger } from '@sre/helpers/Log.helper';\nconst console = Logger('AgentSettings');\n\nexport default class AgentSettings {\n    private _settings: any;\n    public embodiments?: EmbodimentSettings;\n    private _ready = false;\n\n    constructor(agentId?) {\n        if (agentId) {\n            this.init(agentId);\n        }\n    }\n\n    async init(agentId) {\n        const agentDataConnector = ConnectorService.getAgentDataConnector();\n        this._settings = (await agentDataConnector.getAgentSettings(agentId).catch((e) => {})) || {};\n        this.embodiments = new EmbodimentSettings(this._settings.embodiments);\n        this._ready = true;\n    }\n\n    public ready(maxWait = 10000) {\n        return new Promise((resolve, reject) => {\n            const interval = setInterval(() => {\n                if (this._ready) {\n                    clearInterval(interval);\n                    resolve(true);\n                }\n                maxWait -= 100;\n            }, 100);\n\n            setTimeout(() => {\n                clearInterval(interval);\n                reject(false);\n            }, maxWait);\n        });\n    }\n    public get(key: string) {\n        return this._settings?.find((s) => s.key === key)?.value;\n    }\n    public set(key: string, value: any) {\n        this._settings[key] = value;\n    }\n    public has(key: string) {\n        return this._settings[key];\n    }\n}\n","//==[ SRE: ACL Types ]======================\n\nexport enum TAccessLevel {\n    None = 'none',\n    Owner = 'owner',\n    Read = 'read',\n    Write = 'write',\n}\n\nexport enum TAccessRole {\n    Agent = 'agent',\n    User = 'user',\n    Team = 'team',\n    Public = 'public',\n}\n\n// role and level mappings are used for ACL serialization / deserialization\nexport const RoleMap = {\n    user: 'u',\n    agent: 'a',\n    team: 't',\n    public: 'p',\n};\n\nexport const LevelMap = {\n    none: 'n',\n    owner: 'o',\n    read: 'r',\n    write: 'w',\n};\n\n// Reverse mappings\nexport const ReverseRoleMap = Object.fromEntries(Object.entries(RoleMap).map(([k, v]) => [v, k]));\nexport const ReverseLevelMap = Object.fromEntries(Object.entries(LevelMap).map(([k, v]) => [v, k]));\n\n/**\n * an ACLEntry is a list of access levels for a given owner.\n * an owner can be an agent, a user, a team or the public.\n */\nexport type TACLEntry = {\n    [hashedOwnerKey: string]: TAccessLevel[] | undefined;\n};\n/**\n * The Access Control List (ACL) is a list of access rights for a given resource.\n * Each entry in this ACL represents a role\n * Role entries define a list of owners of the resource and the access levels they have.\n * e.g.\n *  The following ACL defines that agentA and teamA has read and write access, while agentB and teamC has read access.\n *   {\n *      agent: {\n *         'agentA': ['read', 'write'],\n *         'agentB': ['read'],\n *     },\n *    team: {\n *       'teamA': ['read', 'write'],\n *       'teamC': ['read'],\n *     }\n * }\n */\n// prettier-ignore\nexport interface IACL {    \n    hashAlgorithm?: string | undefined;\n    entries?: {\n        [key in TAccessRole]?: TACLEntry | undefined;\n    };\n    migrated?: boolean | undefined;\n}\n\n// export type TACLMetadata = {\n//     acl?: TACL | undefined;\n// };\n\nexport interface IAccessCandidate {\n    role: TAccessRole;\n    id: string;\n}\n\nexport interface IAccessRequest {\n    id: string;\n    resourceId: string;\n    candidate: IAccessCandidate;\n    level: TAccessLevel | TAccessLevel[];\n}\n\nexport enum TAccessResult {\n    Granted = 'granted',\n    Denied = 'denied',\n}\n\nexport type TAccessTicket = {\n    request: IAccessRequest;\n    access: TAccessResult;\n};\n\n//custom errors\n\n//access denied error\nexport class ACLAccessDeniedError extends Error {\n    constructor(message?: string) {\n        super(message);\n        this.name = 'ACLAccessDeniedError';\n    }\n}\n","import { IAccessCandidate, IAccessRequest, TAccessLevel } from '@sre/types/ACL.types';\nimport { uid } from '@sre/utils/index';\n\nexport class AccessRequest implements IAccessRequest {\n    public id: string;\n    public resourceId: string;\n\n    public level: TAccessLevel[] = [];\n    public candidate: IAccessCandidate;\n\n    constructor(object?: IAccessRequest | IAccessCandidate) {\n        if (!object) {\n            this.id = 'aclR:' + uid();\n        }\n        if (['role', 'id'].every((k) => k in object)) {\n            //this is a candidate\n            this.id = 'aclR:' + uid();\n            this.candidate = object as IAccessCandidate;\n        } else {\n            const acReq: AccessRequest = object as AccessRequest;\n            this.id = acReq.id;\n            //this.resourceId = acReq.resourceId;\n            this.level = acReq.level;\n            this.candidate = acReq.candidate;\n        }\n\n        this.resourceId = undefined;\n    }\n\n    public static clone(request: IAccessRequest): AccessRequest {\n        return new AccessRequest(request);\n    }\n\n    public setLevel(level: TAccessLevel | TAccessLevel[]): AccessRequest {\n        this.level = Array.isArray(level) ? level : [level];\n        return this;\n    }\n    public addLevel(level: TAccessLevel | TAccessLevel[]): AccessRequest {\n        this.level = [...this.level, ...(Array.isArray(level) ? level : [level])];\n        return this;\n    }\n    public resource(resourceId: string): AccessRequest {\n        this.resourceId = resourceId;\n\n        return this;\n    }\n    public setCandidate(candidate: IAccessCandidate): AccessRequest {\n        this.candidate = candidate;\n\n        return this;\n    }\n}\n","import { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { AccessRequest } from './AccessRequest.class';\n\nexport class AccessCandidate implements IAccessCandidate {\n    public role: TAccessRole;\n    public id: string;\n    //public _candidate: TAccessCandidate;\n    constructor(candidate?: IAccessCandidate) {\n        //this._candidate = candidate || { role: TAccessRole.Public, id: '' };\n\n        this.role = candidate ? candidate.role : TAccessRole.Public;\n        this.id = candidate ? candidate.id : '';\n    }\n\n    public get request(): AccessRequest {\n        return new AccessRequest(this);\n    }\n\n    public get readRequest(): AccessRequest {\n        return new AccessRequest(this).setLevel(TAccessLevel.Read);\n    }\n    public get writeRequest(): AccessRequest {\n        return new AccessRequest(this).setLevel(TAccessLevel.Write);\n    }\n    public get ownerRequest(): AccessRequest {\n        return new AccessRequest(this).setLevel(TAccessLevel.Owner);\n    }\n\n    public static clone(candidate: IAccessCandidate): AccessCandidate {\n        return new AccessCandidate(candidate);\n    }\n\n    public team(teamId: string): AccessCandidate {\n        this.role = TAccessRole.Team;\n        this.id = teamId;\n\n        return this;\n    }\n    static team(teamId: string): AccessCandidate {\n        return new AccessCandidate({ role: TAccessRole.Team, id: teamId });\n    }\n\n    public agent(agentId: string): AccessCandidate {\n        this.role = TAccessRole.Agent;\n        this.id = agentId;\n        return this;\n    }\n    static agent(agentId: string): AccessCandidate {\n        return new AccessCandidate({ role: TAccessRole.Agent, id: agentId });\n    }\n\n    public user(userId: string): AccessCandidate {\n        this.role = TAccessRole.User;\n        this.id = userId;\n        return this;\n    }\n    static user(userId: string): AccessCandidate {\n        return new AccessCandidate({ role: TAccessRole.User, id: userId });\n    }\n\n    public public(): AccessCandidate {\n        this.role = TAccessRole.Public;\n\n        //public is a special case we use the role as the owner id because public access does not have specific candidate IDs\n        this.id = TAccessRole.Public;\n\n        return this;\n    }\n    static public(): AccessCandidate {\n        return new AccessCandidate({ role: TAccessRole.Public, id: '' });\n    }\n}\n","import { xxh3 } from '@node-rs/xxhash';\nimport { IACL, IAccessRequest, LevelMap, ReverseLevelMap, ReverseRoleMap, RoleMap, TACLEntry, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\n\nconst ACLHashAlgo = {\n    none: (source) => source,\n    xxh3: (source) => xxh3.xxh64(source.toString()).toString(16),\n};\n\nexport class ACL implements IACL {\n    public hashAlgorithm?: string | undefined;\n    public entries?: {\n        [key in TAccessRole]?: TACLEntry | undefined;\n    };\n    public migrated?: boolean | undefined;\n    //private acl: TACL;\n    public get ACL(): IACL {\n        return {\n            hashAlgorithm: this.hashAlgorithm,\n            entries: JSON.parse(JSON.stringify(this.entries)),\n            migrated: this.migrated,\n        };\n    }\n    public get serializedACL(): string {\n        return this.serializeACL(this);\n    }\n\n    constructor(acl?: IACL | string) {\n        if (typeof acl === 'string') {\n            this.deserializeACL(acl);\n        } else {\n            this.hashAlgorithm = acl?.hashAlgorithm;\n            this.entries = acl?.entries ? JSON.parse(JSON.stringify(acl?.entries)) : {};\n            this.migrated = acl?.migrated;\n        }\n        if (!this.hashAlgorithm) this.hashAlgorithm = 'xxh3';\n        if (!this.entries) this.entries = {};\n    }\n\n    static from(acl?: IACL | string): ACL {\n        return new ACL(acl);\n    }\n\n    /**\n     * This function checks if the candidate has access to the requested level\n     * it only checks the exact access level, not the higher levels\n     * Examples :\n     * - if the candidate has read access, it will return true only if the requested level is read\n     * - if the current ACL has team access but the candidate is an agent, it will not match the team access\n     * @param acRequest\n     * @returns\n     */\n    public checkExactAccess(acRequest: IAccessRequest): boolean {\n        if (!this?.entries) return false; // cannot determine the access rights, prefer to deny access\n\n        const role = this?.entries[acRequest.candidate.role];\n        if (!role) return false;\n        let entryId = acRequest.candidate.id;\n\n        if (!ACLHashAlgo[this.hashAlgorithm]) {\n            throw new Error(`Hash algorithm ${this.hashAlgorithm} not supported`);\n        }\n\n        entryId = ACLHashAlgo[this.hashAlgorithm](entryId);\n\n        const access = role[entryId];\n        if (!access) return false;\n\n        const levels = Array.isArray(acRequest.level) ? acRequest.level : [acRequest.level];\n\n        return levels.every((level) => access.includes(level));\n        //return access.includes(req.level);\n    }\n\n    public addPublicAccess(level: TAccessLevel | TAccessLevel[]): ACL {\n        if (!this?.entries[TAccessRole.Public]) this.entries[TAccessRole.Public] = {};\n        if (!ACLHashAlgo[this.hashAlgorithm]) {\n            throw new Error(`Hash algorithm ${this.hashAlgorithm} not supported`);\n        }\n        const ownerId = TAccessRole.Public; //public is a special case we use the role as the owner id because public access does not have specific candidate IDs\n        const hashedOwner = ACLHashAlgo[this.hashAlgorithm](ownerId);\n\n        if (!this?.entries[TAccessRole.Public]![hashedOwner]) this.entries[TAccessRole.Public]![hashedOwner] = [];\n        //acl[TAccessRole.Public]![hashedOwner]!.push(level);\n        //concatenate the levels\n        const curLevel: any = this.entries[TAccessRole.Public]![hashedOwner]!;\n        this.entries[TAccessRole.Public]![hashedOwner] = [...curLevel, ...level];\n\n        return this;\n    }\n    public removePublicAccess(level: TAccessLevel | TAccessLevel[]): ACL {\n        if (!this?.entries[TAccessRole.Public]) return this;\n        const ownerId = TAccessRole.Public; //public is a special case we use the role as the owner id because public access does not have specific candidate IDs\n        const hashedOwner = ACLHashAlgo[this.hashAlgorithm](ownerId);\n\n        //remove the levels\n        const curLevel = this[TAccessRole.Public]![hashedOwner]!;\n        this[TAccessRole.Public]![hashedOwner] = curLevel.filter((l) => !level.includes(l));\n\n        return this;\n    }\n    public addAccess(role: TAccessRole, ownerId: string, level: TAccessLevel | TAccessLevel[]): ACL {\n        if (role === TAccessRole.Public) {\n            throw new Error('Adding public access using addAccess method is not allowed. Use addPublicAccess method instead.');\n        }\n        const _level = Array.isArray(level) ? level : [level];\n        if (!this?.entries[role]) this.entries[role] = {};\n        if (!ACLHashAlgo[this.hashAlgorithm]) {\n            throw new Error(`Hash algorithm ${this.hashAlgorithm} not supported`);\n        }\n        const hashedOwner = ACLHashAlgo[this.hashAlgorithm](ownerId);\n\n        if (!this?.entries[role]![hashedOwner]) this.entries[role]![hashedOwner] = [];\n        //acl[role]![ownerId]!.push(level);\n        //concatenate the levels\n        const curLevel = this.entries[role]![hashedOwner]!;\n        this.entries[role]![hashedOwner] = [...curLevel, ..._level];\n\n        return this;\n    }\n    public static addAccess(role: TAccessRole, ownerId: string, level: TAccessLevel | TAccessLevel[]): ACL {\n        return ACL.from().addAccess(role, ownerId, level);\n    }\n\n    public removeAccess(role: TAccessRole, ownerId: string, level: TAccessLevel | TAccessLevel[]): ACL {\n        const _level = Array.isArray(level) ? level : [level];\n        if (!this[role]) return this;\n        if (!this[role]![ownerId]) return this;\n        //acl[role]![ownerId] = acl[role]![ownerId]!.filter((l) => l !== level);\n        //remove the levels\n        const curLevel = this[role]![ownerId]!;\n        this[role]![ownerId] = curLevel.filter((l) => !_level.includes(l));\n\n        return this;\n    }\n\n    private serializeACL(tacl: IACL): string {\n        let compressed = '';\n\n        if (tacl.hashAlgorithm) {\n            compressed += `h:${tacl.hashAlgorithm}|`;\n        }\n\n        if (tacl.entries) {\n            for (const [role, entries] of Object.entries(tacl.entries)) {\n                const roleShort = RoleMap[role]; // Use the mapping for role\n                const entriesArray: any[] = [];\n\n                for (const [hashedOwnerKey, accessLevels] of Object.entries(entries || {})) {\n                    if (accessLevels) {\n                        const accessLevelsShort = accessLevels.map((level) => LevelMap[level]).join('');\n                        entriesArray.push(`${hashedOwnerKey}/${accessLevelsShort}`);\n                    }\n                }\n\n                if (entriesArray.length > 0) {\n                    compressed += `${roleShort}:${entriesArray.join(',')}|`;\n                }\n            }\n        }\n\n        // Remove the trailing '|'\n        if (compressed.endsWith('|')) {\n            compressed = compressed.slice(0, -1);\n        }\n\n        return compressed;\n    }\n\n    private deserializeACL(compressed: string) {\n        const parts = compressed.split('|');\n        this.hashAlgorithm = '';\n        this.entries = {};\n\n        for (const part of parts) {\n            if (part.startsWith('h:')) {\n                this.hashAlgorithm = part.substring(2);\n            } else {\n                const [roleShort, entries] = part.split(':');\n                const role = ReverseRoleMap[roleShort]; // Use the reverse mapping for role\n\n                if (role) {\n                    const entriesObj = {};\n                    const entriesArray = entries.split(',');\n\n                    for (const entry of entriesArray) {\n                        const [hashedOwnerKey, accessLevelsShort] = entry.split('/');\n                        const accessLevels = accessLevelsShort.split('').map((short) => ReverseLevelMap[short]);\n\n                        entriesObj[hashedOwnerKey] = accessLevels;\n                    }\n\n                    this.entries[role] = entriesObj;\n                }\n            }\n        }\n\n        //return tacl;\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\nimport { isBuffer } from '@sre/utils';\nimport * as FileType from 'file-type';\nimport mime from 'mime';\nimport { Readable } from 'stream';\nimport { StorageConnector } from './StorageConnector';\n\nexport type TSmythFSURI = {\n    hash: string;\n    team: string;\n    path: string;\n};\n\nexport class SmythFS {\n    private storage: StorageConnector;\n\n    //singleton\n    private static instance: SmythFS;\n    public static get Instance() {\n        if (!this.instance) {\n            this.instance = new SmythFS();\n        }\n        return this.instance;\n    }\n\n    private constructor() {\n        //SmythFS cannot be used without SRE\n        if (!ConnectorService.ready) {\n            throw new Error('SRE not available');\n        }\n        this.storage = ConnectorService.getStorageConnector();\n    }\n\n    private URIParser(uri: string) {\n        const parts = uri.split('://');\n        if (parts.length !== 2) return undefined;\n        if (parts[0].toLowerCase() !== 'smythfs') return undefined;\n        const parsed = new URL(`http://${parts[1]}`);\n        const tld = parsed.hostname.split('.').pop();\n        if (tld !== 'team') throw new Error('Invalid Resource URI');\n        const team = parsed.hostname.replace(`.${tld}`, '');\n        //TODO: check if team exists\n\n        return {\n            hash: parsed.hash,\n            team,\n            path: parsed.pathname,\n        };\n    }\n    public getStoragePath(uri: string) {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n        return `teams/${smythURI.team}${smythURI.path}`;\n    }\n    public async read(uri: string, candidate: IAccessCandidate): Promise<Buffer> {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n\n        const resourceId = `teams/${smythURI.team}${smythURI.path}`;\n\n        const _candidate = candidate instanceof AccessCandidate ? candidate : new AccessCandidate(candidate);\n\n        const data = await this.storage.user(_candidate).read(resourceId);\n\n        return this.toBuffer(data);\n    }\n\n    private async toBuffer(data: StorageData): Promise<Buffer> {\n        if (Buffer.isBuffer(data)) {\n            return data;\n        } else if (typeof data === 'string') {\n            return Buffer.from(data, 'utf-8');\n        } else if (data instanceof Uint8Array) {\n            return Buffer.from(data);\n        } else if (data instanceof Readable) {\n            return new Promise<Buffer>((resolve, reject) => {\n                const chunks: Buffer[] = [];\n                data.on('data', (chunk) => {\n                    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n                });\n                data.on('end', () => {\n                    resolve(Buffer.concat(chunks));\n                });\n                data.on('error', (err) => {\n                    reject(err);\n                });\n            });\n        } else {\n            throw new Error('Unsupported data type');\n        }\n    }\n\n    public async write(uri: string, data: any, candidate: IAccessCandidate, metadata?: StorageMetadata) {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n        const accountConnector = ConnectorService.getAccountConnector();\n        const isMember = await accountConnector.isTeamMember(smythURI.team, candidate);\n        if (!isMember) throw new Error('Access Denied');\n\n        const resourceId = `teams/${smythURI.team}${smythURI.path}`;\n        //when we write a file, it does not exist we need to explicitly provide a resource team in order to have access rights set properly\n\n        const _candidate = candidate instanceof AccessCandidate ? candidate : new AccessCandidate(candidate);\n\n        const acl = new ACL()\n            //.addAccess(candidate.role, candidate.id, TAccessLevel.Owner) // creator is owner\n            .addAccess(TAccessRole.Team, smythURI.team, TAccessLevel.Read).ACL; // team has read access\n\n        if (!metadata) metadata = {};\n        if (!metadata?.ContentType) {\n            metadata.ContentType = await this.getMimeType(data);\n            if (!metadata.ContentType) {\n                const ext: any = uri.split('.').pop();\n                if (ext) {\n                    metadata.ContentType = mime.getType(ext) || 'application/octet-stream';\n                }\n            }\n        }\n        await this.storage.user(_candidate).write(resourceId, data, acl, metadata);\n    }\n    private async getMimeType(data: any) {\n        let size = 0;\n        if (data instanceof Blob) return data.type;\n        if (isBuffer(data)) {\n            try {\n                const fileType = await FileType.fileTypeFromBuffer(data);\n                return fileType.mime;\n            } catch {\n                return '';\n            }\n        }\n\n        if (typeof data === 'string') {\n            return 'text/plain';\n        }\n    }\n\n    public async delete(uri: string, candidate: IAccessCandidate) {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n\n        const resourceId = `teams/${smythURI.team}${smythURI.path}`;\n\n        const _candidate = candidate instanceof AccessCandidate ? candidate : new AccessCandidate(candidate);\n\n        await this.storage.user(_candidate).delete(resourceId);\n    }\n\n    //TODO: should we require access token here ?\n    public async exists(uri: string, candidate: IAccessCandidate) {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n\n        const resourceId = `teams/${smythURI.team}${smythURI.path}`;\n\n        //in order to get a consistent access check in case of inexisting resource, we need to explicitly set a default resource team\n        const _candidate = candidate instanceof AccessCandidate ? candidate : new AccessCandidate(candidate);\n\n        return await this.storage.user(_candidate).exists(resourceId);\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { SmythFS } from '@sre/IO/Storage.service/SmythFS.class';\nimport { IAccessCandidate } from '@sre/types/ACL.types';\nimport axios from 'axios';\nimport * as FileType from 'file-type';\nimport mime from 'mime';\nimport { getSizeFromBinary, isUrl, uid } from '../utils';\nexport class BinaryInput {\n    private size: number;\n    private url: string;\n    private _ready;\n    private _readyPromise;\n    private _source: Buffer;\n    private _uploading: boolean = false;\n\n    constructor(data: BinaryInput | Buffer | ArrayBuffer | Blob | string | Record<string, any>, private _name?: string, public mimetype?: string) {\n        if (!_name) _name = uid();\n        //this._source = data;\n\n        this.load(data, _name, mimetype);\n    }\n\n    public async ready() {\n        if (this._ready) return true;\n\n        if (!this._readyPromise) {\n            this._readyPromise = new Promise((resolve) => {\n                const maxWait = 10000;\n                const interval = setInterval(() => {\n                    if (this._ready) {\n                        clearInterval(interval);\n                        resolve(true);\n                    }\n                    if (maxWait <= 0) {\n                        clearInterval(interval);\n                        resolve(false);\n                    }\n                }, 100);\n            });\n        }\n\n        return this._readyPromise;\n    }\n\n    private async load(data, name: string, mimetype?: string) {\n        //assume the mimetype from the provided name\n        const ext: any = name.split('.').pop();\n        this.mimetype = mimetype || mime.getType(ext) || 'application/octet-stream';\n        this.url = ``;\n\n        if (typeof data === 'object' && data.url && data.mimetype && data.size) {\n            this.mimetype = data.mimetype;\n            this.size = data.size;\n            this.url = data.url;\n            this._ready = true;\n            return;\n        }\n\n        if (isUrl(data)) {\n            const info: any = await this.getUrlInfo(data);\n            this.mimetype = info.contentType;\n            this.size = info.contentLength;\n            //this.url = data;\n\n            try {\n                const response = await axios({\n                    method: 'get',\n                    url: data,\n                    responseType: 'arraybuffer', // Important for handling binary data\n                });\n\n                this._source = Buffer.from(response.data, 'binary');\n                this.size = response.data.byteLength;\n\n                const ext = mime.getExtension(this.mimetype);\n                if (!this._name.endsWith(`.${ext}`)) this._name += `.${ext}`;\n            } catch (error) {\n                console.error('Error loading binary data from url:', data.url);\n            }\n\n            //this._source = data.url;\n\n            this._ready = true;\n            return;\n        }\n\n        // console.log('>>>>>>>>>>>>>>>>>>> is base64 file ?', isDataUrl(data));\n        const base64FileInfo = await this.getBase64FileInfo(data);\n        if (base64FileInfo) {\n            this.mimetype = base64FileInfo.mimetype;\n            this.size = base64FileInfo.size;\n            this._source = base64FileInfo.data;\n            const ext = mime.getExtension(this.mimetype);\n            if (!this._name.endsWith(`.${ext}`)) this._name += `.${ext}`;\n\n            this._ready = true;\n            return;\n        }\n\n        if (typeof data === 'string') {\n            this._source = Buffer.from(data);\n            this.size = data.length;\n            this.mimetype = 'text/plain';\n            if (!this._name.endsWith(`.txt`)) this._name += `.txt`;\n\n            this._ready = true;\n            return;\n        }\n\n        //this.size = getSizeFromBinary(data);\n        // //try to enforce the mimetype from the provided data\n        // if (Buffer.isBuffer(data)) {\n        //     const fileType = await FileType.fileTypeFromBuffer(data);\n        //     this.mimetype = fileType.mime;\n        //     const ext = mime.getExtension(this.mimetype);\n        //     if (!this._name.endsWith(`.${ext}`)) this._name += `.${ext}`;\n\n        //     this._ready = true;\n        //     return;\n        // }\n        //try to enforce the mimetype from the provided data\n        if (Buffer.isBuffer(data)) {\n            this._source = data;\n            this.size = getSizeFromBinary(data);\n            const fileType = await FileType.fileTypeFromBuffer(data);\n            this.mimetype = fileType.mime;\n            const ext = mime.getExtension(this.mimetype);\n            if (!this._name.endsWith(`.${ext}`)) this._name += `.${ext}`;\n        }\n\n        this._ready = true;\n    }\n\n    private async getUrlInfo(url) {\n        try {\n            const response = await axios.head(url);\n            const contentType = response.headers['content-type'];\n            const contentLength = response.headers['content-length'];\n            return { contentType, contentLength };\n        } catch (error) {\n            return { contentType: '', contentLength: 0 };\n        }\n    }\n    private async getBase64FileInfo(data: string) {\n        //first check if it's a base64 url format\n        const validUrlFormatRegex = /data:[^;]+;base64,[A-Za-z0-9+\\/]*(={0,2})?$/gm;\n        if (!validUrlFormatRegex.test(data)) {\n            return null;\n        }\n\n        const base64Data = data.split(',')[1];\n        const buffer = Buffer.from(base64Data, 'base64');\n        const size = buffer.byteLength;\n        const filetype = await FileType.fileTypeFromBuffer(buffer);\n\n        return { size, data: buffer, mimetype: filetype?.mime || '' };\n    }\n    public static from(data, name?: string, mimetype?: string) {\n        if (data instanceof BinaryInput) return data;\n        return new BinaryInput(data, name, mimetype);\n    }\n\n    public async upload(candidate: IAccessCandidate) {\n        await this.ready();\n        if (this._uploading) return;\n\n        try {\n            this._uploading = true;\n            if (!this.url) {\n                const accountConnector = ConnectorService.getAccountConnector();\n                const teamId = await accountConnector.getCandidateTeam(candidate);\n\n                this.url = `smythfs://${teamId}.team/${candidate.id}/_temp/${this._name}`;\n                await SmythFS.Instance.write(this.url, this._source, candidate);\n                this._uploading = false;\n            }\n        } catch (error) {\n            console.error('Error uploading binary data:', error);\n            this._uploading = false;\n        }\n    }\n\n    public async getJsonData(candidate: IAccessCandidate) {\n        await this.upload(candidate);\n        return {\n            mimetype: this.mimetype,\n            size: this.size,\n            url: this.url,\n        };\n    }\n\n    public async readData(candidate: IAccessCandidate) {\n        await this.ready();\n        if (!this.url) {\n            throw new Error('Binary data not ready');\n        }\n        const data = await SmythFS.Instance.read(this.url, candidate);\n        return data;\n    }\n\n    public async getBuffer() {\n        await this.ready();\n\n        return this._source;\n    }\n}\n","import { jsonrepair } from 'jsonrepair';\nimport { isDigits, isSafeNumber, isValidString } from '@sre/utils';\n\nexport class JSONContentHelper {\n    private _current: string;\n\n    public get result() {\n        return this._current;\n    }\n    private constructor(private dataString: string) {\n        this._current = dataString;\n    }\n\n    public static create(dataString: string) {\n        return new JSONContentHelper(dataString);\n    }\n\n    /**\n     * This function tries to extract and parse a JSON object from a string. If it fails, it returns the original string.\n     * if the string is not a JSON representation, but contains a JSON object, it will extract and parse it.\n     * @returns\n     */\n    public tryParse() {\n        const strInput = this._current;\n        if (!isValidString(strInput)) return strInput;\n        let str = (this.extractJsonFromString(strInput) || strInput).trim();\n\n        if ((isDigits(str) && !isSafeNumber(str)) || (!str.startsWith('{') && !str.startsWith('['))) return str;\n\n        try {\n            return JSON.parse(str);\n        } catch (e) {\n            try {\n                return JSON.parse(jsonrepair(str));\n            } catch (e: any) {\n                //console.warn('Error on parseJson: ', e.toString());\n                //console.warn('   Tried to parse: ', str);\n                return strInput;\n            }\n        }\n    }\n\n    private extractJsonFromString(str) {\n        try {\n            const regex = /(\\{.*\\})/s;\n\n            const match = str.match(regex);\n\n            return match?.[1];\n        } catch {\n            return null;\n        }\n    }\n}\n\nexport function JSONContent(dataString: string) {\n    return JSONContentHelper.create(dataString);\n}\n","export function isDigits(str: string): boolean {\n    if (typeof str === 'number') return true;\n\n    if (typeof str !== 'string') return false;\n\n    const numRegex = /^-?\\d+(\\.\\d+)?$/;\n    return numRegex.test(str.trim());\n}\n\nexport function isSafeNumber(str: string): boolean {\n    const num = parseFloat(str);\n    return !isNaN(num) && num <= Number.MAX_SAFE_INTEGER && num >= Number.MIN_SAFE_INTEGER && num.toString() === str.trim();\n}\n","import { isRawBase64, isDataUrl } from '@sre/utils/base64.utils';\nimport dayjs from 'dayjs';\nimport { isBinaryData, isBuffer, isPlainObject, isSmythFileObject, isUrl, uid } from '../utils';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { TAccessRole } from '@sre/types/ACL.types';\nimport { BinaryInput } from './BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { JSONContent } from './JsonContent.helper';\n\nexport const inputErrMsg = (type, name) => `Invalid ${type} value for Input: ${name}`;\n\nconst InferenceStrategies = {\n    any: inferAnyType,\n    string: inferStringType,\n    number: inferNumberType,\n    integer: inferIntegerType,\n    boolean: inferBooleanType,\n    array: inferArrayType,\n    object: inferObjectType,\n    binary: inferBinaryType,\n    date: inferDateType,\n};\n\nexport async function performTypeInference(\n    inputs: Record<string, any>,\n    inputConfig: Record<string, any>[],\n    agent: Agent\n): Promise<Record<string, any>> {\n    try {\n        if (!inputConfig || Object.keys(inputConfig)?.length === 0) return inputs;\n\n        // Clone the input object to avoid modifying the original object\n        const _inputs = { ...inputs };\n        const _inputConfig = {};\n\n        for (const input of inputConfig) {\n            if (input?.name) {\n                _inputConfig[input.name] = { ...input };\n            }\n        }\n\n        for (const [key, config] of Object.entries(_inputConfig)) {\n            let value = inputs?.[key] || '';\n\n            if (!value) continue;\n\n            const type = (config as any)?.type?.toLowerCase() || 'any';\n\n            if (!InferenceStrategies[type]) {\n                throw new Error(`Invalid type: ${type} for Input: ${key}`);\n            }\n\n            _inputs[key] = await InferenceStrategies[type](value, key, agent);\n        }\n\n        return _inputs;\n    } catch (error) {\n        throw error;\n    }\n}\n\nasync function inferStringType(value: any, key?: string, agent?: Agent) {\n    if (value === null || value === undefined || value === 'null' || value === 'undefined') {\n        return '';\n    } else if (isRawBase64(value) || isDataUrl(value)) {\n        // If the value is a base64 string then return the value as it is\n        return value;\n    } /*else if (isSmythFileObject(value) || isBuffer(value) || isBinaryData(value)) {\n        const file = new SmythFile(value);\n        const base64Obj = await file.toBase64Object();\n        return `data:${base64Obj.mimetype};base64,${base64Obj.base64}`;\n    }*/ else if (typeof value === 'object' || Array.isArray(value)) {\n        return JSON.stringify(value);\n    } else {\n        return String(value);\n    }\n}\n\nasync function inferNumberType(value: any, key?: string, agent?: Agent) {\n    const floatVal = parseFloat(value);\n\n    if (isNaN(floatVal)) {\n        throw new Error('Invalid Number value');\n    }\n\n    return floatVal;\n}\n\nasync function inferIntegerType(value: any, key?: string, agent?: Agent) {\n    const intVal = parseInt(value);\n\n    if (isNaN(intVal)) throw new Error('Invalid Integer value');\n\n    return intVal;\n}\n\nasync function inferBooleanType(value: any, key?: string, agent?: Agent) {\n    if (typeof value === 'boolean') {\n        return value;\n    } else if (typeof value === 'string' || typeof value === 'number') {\n        const lowerCaseValue = String(value).toLowerCase();\n        if (['true', '1'].includes(lowerCaseValue)) {\n            return true;\n        } else if (['false', '0'].includes(lowerCaseValue)) {\n            return false;\n        } else {\n            throw new Error('Invalid Boolean value');\n        }\n    } else {\n        throw new Error('Invalid Boolean value');\n    }\n}\n\nasync function inferArrayType(value: any, key?: string, agent?: Agent) {\n    try {\n        if (Array.isArray(value)) return value;\n\n        if (typeof value !== 'string') throw new Error('Invalid Array value');\n\n        try {\n            // We need to consider array with comma separated values like \"item1, item2, item3\", as it's provided by Swagger UI\n            return value.trim().startsWith('[') ? JSONContent(value).tryParse() : value.split(',');\n        } catch {\n            throw new Error('Invalid Array value');\n        }\n    } catch (error) {\n        throw new Error('Invalid Array value');\n    }\n}\n\nasync function inferObjectType(value: any, key?: string, agent?: Agent) {\n    try {\n        // use parseJson instead of JSON.parse because the data may come from LLM responses\n        const obj = isPlainObject(value) ? value : JSONContent(value).tryParse();\n        if (!isPlainObject(obj)) throw new Error('Invalid Object value');\n        return obj;\n    } catch (error) {\n        throw new Error('Invalid Object value');\n    }\n}\n\nasync function inferBinaryType(value: any, key?: string, agent?: Agent) {\n    const binaryInput = BinaryInput.from(value, uid() + '-' + key);\n    //const data = value;\n    //const file = data instanceof SmythFile ? data : new SmythFile(data);\n    //return file;\n    return await binaryInput.getJsonData(AccessCandidate.agent(agent.id));\n}\n\nasync function inferDateType(value: any, key?: string, agent?: Agent) {\n    const errMsg = `Invalid Date value\\nThe date string is expected to be in a format commonly used in English-speaking countries.`;\n\n    // Make sure we only accept string or number to parse as date\n    if (typeof value !== 'string' && typeof value !== 'number') throw new Error(errMsg);\n\n    let date;\n    if (typeof value === 'string' && isNaN(Number(value))) {\n        date = dayjs(value).locale('en'); // parse as date string\n    } else {\n        // parse as Unix timestamp\n        const timestamp = typeof value === 'number' ? value : Number(value);\n        date = dayjs.unix(timestamp / 1000);\n    }\n\n    if (!date.isValid()) throw new Error(errMsg);\n\n    return date.toISOString();\n}\n\nasync function inferAnyType(value: any) {\n    return value;\n}\n","import Joi from 'joi';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { performTypeInference } from '@sre/helpers/TypeChecker.helper';\n\nexport default class Component {\n    public hasReadOutput = false;\n    public hasPostProcess = true;\n    public alwaysActive = false; //for components like readable memories\n    public exclusive = false; //for components like writable memories : when exclusive components are active, they are processed in a run cycle bofore other components\n    protected configSchema;\n    constructor() {}\n    init() {}\n\n    createComponentLogger(agent: Agent, name: string) {\n        const logger = Logger(name || this.constructor.name, agent?.agentRuntime?.debug);\n\n        return logger;\n    }\n\n    async validateConfig(config) {\n        if (!this.configSchema) return {};\n        if (config.data._templateVars) {\n            //Accept dynamically added template data\n            for (let tplVar in config.data._templateVars) {\n                this.configSchema = this.configSchema.append({ [tplVar]: Joi.any() });\n            }\n        }\n        const valid = await this.configSchema.validate(config.data);\n        if (valid.error) {\n            return {\n                id: config.id,\n                name: config.name,\n                _error: `Schema Validation error: ${valid?.error?.message} on component ${config.displayName}:${config.title}`,\n                _debug: `Schema Validation error: ${valid?.error?.message} on component ${config.displayName}:${config.title}`,\n            };\n        }\n\n        return {};\n    }\n\n    async process(input, config, agent: Agent): Promise<any> {\n        // console.log(\n        //     `Called component ${this.constructor.name}\\n ID=${config.id} \\ninput ${JSON.stringify(input, null, 2)} \\nand config ${JSON.stringify(\n        //         config,\n        //         null,\n        //         2,\n        //     )}`,\n        // );\n        const _input = await performTypeInference(input, config?.inputs, agent);\n\n        // modify the input object for component's process method\n        for (const [key, value] of Object.entries(_input)) {\n            input[key] = value;\n        }\n    }\n    async postProcess(output, config, agent: Agent): Promise<any> {\n        if (output?.result) {\n            delete output?.result?._debug;\n            if (!output?.result?._error) delete output?.result?._error;\n        }\n        return output;\n    }\n    async enable(config, agent: Agent): Promise<any> {}\n    async disable(config, agent: Agent): Promise<any> {}\n    readOutput(id, config, agent: Agent): any {\n        return null;\n    }\n    hasOutput(id, config, agent: Agent): any {\n        return false;\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccessCandidate } from '../AccessControl/AccessCandidate.class';\n\nexport class VaultHelper {\n    static async getTeamKey(key: string, teamId: string): Promise<string> {\n        const vaultConnector = ConnectorService.getVaultConnector();\n        return await vaultConnector.user(AccessCandidate.team(teamId)).get(key);\n    }\n\n    static async getUserKey(key: string, userId: string): Promise<string> {\n        const vaultConnector = ConnectorService.getVaultConnector();\n        const accountConnector = ConnectorService.getAccountConnector();\n\n        const teamId = await accountConnector.getCandidateTeam(AccessCandidate.user(userId));\n\n        return await vaultConnector.user(AccessCandidate.team(teamId)).get(key);\n    }\n\n    static async getAgentKey(key: string, agentId: string): Promise<string> {\n        const vaultConnector = ConnectorService.getVaultConnector();\n        const accountConnector = ConnectorService.getAccountConnector();\n\n        const teamId = await accountConnector.getCandidateTeam(AccessCandidate.agent(agentId));\n\n        return await vaultConnector.user(AccessCandidate.team(teamId)).get(key);\n    }\n}\n","import { VaultHelper } from '@sre/Security/Vault.service/Vault.helper';\n\nexport type TemplateStringMatch = RegExp;\n\nexport const Match = {\n    default: /{{(.*?)}}/g,\n    //matches all placeholders\n    doubleCurly: /{{(.*?)}}/g,\n    singleCurly: /{(.*?)}/g,\n    //matches only the placeholders that have a specific prefix\n    prefix(prefix: string) {\n        return new RegExp(`{{${prefix}(.*?)}}`, 'g');\n    },\n\n    //matches only the placeholders that have a specific suffix\n    suffix(suffix: string) {\n        return new RegExp(`{{(.*?)${suffix}}}`, 'g');\n    },\n    //matches only the placeholders that have a specific prefix and suffix\n    prefSuf(prefix: string, suffix: string) {\n        return new RegExp(`{{${prefix}(.*?)${suffix}}}`, 'g');\n    },\n\n    //matches a function annotation with a given name, just like prefix but with wrapping parenthesis\n    fn(name: string) {\n        return new RegExp(`{{${name}\\\\((.*?)\\\\)}}`, 'g');\n    },\n};\n\nexport const TPLProcessor = {\n    vaultTeam(teamId: string): (token) => Promise<string> {\n        //the token here represents the vault key name\n        return async (token) => await VaultHelper.getTeamKey(token, teamId);\n    },\n};\n\n/**\n * Provides a chainable to manipulate template strings\n *\n * Template strings are strings that can contain placeholders, which are expressions that get evaluated to produce a resulting string.\n * The placeholders are defined by double curly braces `{{` and `}}`.\n */\nexport class TemplateStringHelper {\n    private _current: string;\n\n    //this queue is used to wait for asyncronous results when async processors are used\n    //if all processors are synchronous, this queue will be empty and .result getter can be used\n    //if any processor is async, the .result getter will throw an error and you should use .asyncResult instead\n    private _promiseQueue: Promise<any>[] = [];\n\n    public get result() {\n        if (this._promiseQueue.length <= 0) return this._current;\n        throw new Error('This template object has async results, you should use .asyncResult with await instead of .result');\n    }\n\n    public get asyncResult() {\n        return new Promise(async (resolve, reject) => {\n            await Promise.all(this._promiseQueue);\n            resolve(this._current);\n        });\n    }\n\n    private constructor(private templateString: string) {\n        this._current = templateString;\n    }\n\n    public static create(templateString: string) {\n        return new TemplateStringHelper(templateString);\n    }\n\n    /**\n     * Parses a template string by replacing the placeholders with the values from the provided data object\n     * unmatched placeholders will be left as is\n     */\n    public parse(data: Record<string, string>, regex: TemplateStringMatch = Match.default) {\n        if (typeof this._current !== 'string') return this;\n        this._current = this._current.replace(regex, (match, token) => {\n            return data[token] || match;\n        });\n\n        return this;\n    }\n\n    /**\n     * This is a shortcut function that parses vault key values and replace them with corresponding values from team vault\n     * @param teamId\n     * @returns\n     */\n    public parseTeamKeys(teamId: string) {\n        return this.process(TPLProcessor.vaultTeam(teamId), Match.fn('KEY'));\n    }\n\n    /**\n     * Processes a template string by replacing the placeholders with the result of the provided processor function\n     * The processor function receives the token as an argument and should return the value to replace the token with\n     * If the processor function returns undefined, the token will be left as is\n     */\n    public process(processor: (token) => Promise<string> | string, regex: TemplateStringMatch = Match.default) {\n        if (typeof this._current !== 'string') return this;\n        //first build a json object with all matching tokens\n        let tokens = {};\n        let match;\n\n        const prosessorPromises = [];\n        while ((match = regex.exec(this._current)) !== null) {\n            const token = match[1];\n            tokens[token] = match[0];\n\n            const _processor = processor(token);\n\n            //if an async processor is used, the TemplateStringHelper switches to async mode\n            if (_processor instanceof Promise) {\n                _processor.then((result) => {\n                    if (result === undefined) {\n                        return match[0];\n                    }\n                    tokens[token] = result;\n                });\n                prosessorPromises.push(_processor);\n            } else {\n                tokens[token] = _processor;\n            }\n        }\n\n        if (prosessorPromises.length > 0) {\n            const promise = new Promise(async (resolve, reject) => {\n                await Promise.all(prosessorPromises);\n                this.parse(tokens, regex);\n                resolve(true);\n            });\n            this._promiseQueue.push(Promise.all(prosessorPromises));\n        } else {\n            this.parse(tokens, regex);\n        }\n\n        // this._current = await asyncReplace(this._current, regex, async (match, token) => {\n        //     let result = await processor(token);\n        //     if (result === undefined) {\n        //         return match;\n        //     }\n        //     return result;\n        // });\n\n        return this;\n    }\n\n    /**\n     * Removes all placeholders from the template string, leaving only the plain text\n     * This is useful when you want to clean up a template string that has placeholders that were not parsed\n     */\n    public clean(regex: TemplateStringMatch = Match.default) {\n        if (typeof this._current !== 'string') return this;\n        this._current = this._current.replace(regex, '');\n        return this;\n    }\n\n    // public toString() {\n    //     if (this._promiseQueue.length <= 0) return this._current;\n    //     return new Promise(async (resolve, reject) => {\n    //         await Promise.all(this._promiseQueue);\n    //         resolve(this._current);\n    //     });\n    // }\n}\n\n/**\n * a helper function that takes a string and escape it\n * This is useful when you have a stringified json and want to replace one of its values while making sure it won't break the json structure (e.g new lines, double quotes ...etc)\n */\nexport function escapeString(str?: string) {\n    if (!str) return str;\n    return str.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\t/g, '\\\\t');\n}\n\nexport function TemplateString(templateString: string) {\n    return TemplateStringHelper.create(templateString);\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nimport { jsonrepair } from 'jsonrepair';\nimport AgentRequest from '@sre/AgentManager/AgentRequest.class';\nimport { performTypeInference } from '@sre/helpers/TypeChecker.helper';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { uid } from '../utils';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\n// Utility function to check for empty values\nfunction isEmpty(value: any): boolean {\n    return (\n        value === undefined ||\n        value === null ||\n        (typeof value === 'string' && value.trim() === '') ||\n        (Array.isArray(value) && value.length === 0) ||\n        (typeof value === 'object' && value !== null && Object.keys(value).length === 0)\n    );\n}\nfunction isTemplateVar(str: string = ''): boolean {\n    if (!str || typeof str !== 'string') return false;\n    return (str?.match(/{{(.*?)}}/g) ?? []).length > 0;\n}\nfunction isKeyTemplateVar(str: string = ''): boolean {\n    if (!str || typeof str !== 'string') return false;\n    return (str?.match(/{{KEY\\((.*?)\\)}}/g) ?? []).length > 0;\n}\n\nfunction parseKey(str: string = '', teamId: string): string {\n    return str.replace(/{{KEY\\((.*?)\\)}}/g, (match, key) => {\n        return key === 'teamid' ? teamId : '';\n    });\n}\n\nexport default class APIEndpoint extends Component {\n    protected configSchema = Joi.object({\n        endpoint: Joi.string()\n            .pattern(/^[a-zA-Z0-9]+([-_][a-zA-Z0-9]+)*$/)\n            .max(50)\n            .required(),\n        method: Joi.string().valid('POST', 'GET').allow(''), //we're accepting empty value because we consider it POST by default.\n        description: Joi.string().max(5000).allow(''),\n        summary: Joi.string().max(1000).allow(''),\n        doc: Joi.string().max(1000).allow(''),\n        ai_exposed: Joi.boolean().default(true),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const req: AgentRequest = agent.agentRequest;\n        const logger = this.createComponentLogger(agent, config.name);\n\n        const headers = req ? req.headers : {};\n        let body = req ? req.body : input; //handle debugger injection\n        const params = req ? req.params : {};\n        let query = req ? req.query : {};\n        const _authInfo = req ? req._agent_authinfo : undefined;\n\n        // parse template variables\n        for (const [key, value] of Object.entries(body)) {\n            if (isKeyTemplateVar(value as string)) {\n                body[key] = await parseKey(value as string, agent?.teamId);\n            } else if (isTemplateVar(value as string)) {\n                //body[key] = parseTemplate(value as string, input, { escapeString: false });\n                body[key] = TemplateString(value as string).parse(input).result;\n            }\n        }\n\n        for (const [key, value] of Object.entries(query)) {\n            if (isKeyTemplateVar(value as string)) {\n                query[key] = await parseKey(value as string, agent?.teamId);\n            } else if (isTemplateVar(value as string)) {\n                //query[key] = parseTemplate(value as string, input, { escapeString: false });\n                query[key] = TemplateString(value as string).parse(input).result;\n            }\n        }\n\n        // set default value and agent variables\n        const inputsWithDefaultValue = config.inputs.filter(\n            (input) => input.defaultVal !== undefined && input.defaultVal !== '' && input.defaultVal !== null\n        );\n\n        const bodyInputNames: string[] = [];\n        const queryInputNames: string[] = [];\n\n        for (const output of config.outputs) {\n            const outputName = output?.expression || output?.name;\n            const inputName = outputName?.split('.')[1];\n\n            if (inputName) {\n                if (outputName?.includes('body')) {\n                    bodyInputNames.push(inputName);\n                }\n\n                if (outputName?.includes('query')) {\n                    queryInputNames.push(inputName);\n                }\n            }\n        }\n\n        for (const _inputWithDefaultValue of inputsWithDefaultValue) {\n            const inputName = _inputWithDefaultValue?.name;\n\n            let inputValue = input[inputName];\n\n            // We provide a default value for the OpenAPI Schema, which can detected by AnthropicAI. So we need to check if the default value is an Agent Variable. This is necessary for interactions with the Chatbot.\n\n            if (bodyInputNames.includes(inputName) && isEmpty(body[inputName])) {\n                body[inputName] = inputValue;\n            }\n\n            if (queryInputNames.includes(inputName) && isEmpty(query[inputName])) {\n                query[inputName] = inputValue;\n            }\n        }\n\n        //override debugger injection\n        // if (agent.agentRuntime.debug && body?.[0]?.dbg) { // ! 'dbg' is DEPRECATED\n        const isDbgInjection = req.header('X-Debug-Inj') !== undefined;\n        if (isDbgInjection && agent.agentRuntime.debug && Object.values(input).length > 0) {\n            switch (config.data.method) {\n                case 'GET':\n                    for (const [key, value] of Object.entries(input)) {\n                        if (value instanceof BinaryInput) {\n                            logger.debug('[WARNING] Binary files are not supported for GET requests. Key:', key);\n                        } else {\n                            query[key] = value as string;\n                        }\n                    }\n                    break;\n                case 'POST':\n                default:\n                    body = input;\n                    break;\n            }\n            //body = input;\n        }\n\n        // ensure strong data type\n        body = await performTypeInference(body, config.inputs, agent);\n        query = await performTypeInference(query, config.inputs, agent);\n\n        logger.debug('Parsing inputs');\n        logger.debug(' Headers', headers);\n        logger.debug(' Body', body);\n        logger.debug(' Params', params);\n        logger.debug(' Query', query);\n\n        //Handle JSON Data\n        //FIXME : this is a workaround that parses any json string in the body, we should only parse the json string in the body if the data type is explicitely set to JSON\n        //TODO : Add data types to APIEndpoint inputs\n        logger.debug('Parsing body json input');\n        for (let key in body) {\n            const value = body[key];\n            if (typeof value === 'string' && value.trim().startsWith('{') && value.trim().endsWith('}')) {\n                try {\n                    const obj = JSON.parse(jsonrepair(body[key]));\n                    body[key] = obj;\n                } catch {\n                    //skip it if it's not a valid json\n                }\n            }\n        }\n        logger.debug('Parsed body json input', body);\n\n        logger.debug('Parsing query json input');\n        for (let key in query) {\n            const value = query[key];\n            if (typeof value === 'string' && value.trim().startsWith('{') && value.trim().endsWith('}')) {\n                try {\n                    const obj = JSON.parse(jsonrepair(query[key] as string));\n                    query[key] = obj;\n                } catch {\n                    //skip it if it's not a valid json\n                }\n            }\n        }\n        logger.debug('Parsed query json input', query);\n\n        //Handle binary data\n        for (let input of config.inputs) {\n            if (!input.isFile && input?.type?.toLowerCase() !== 'binary') continue;\n\n            const fieldname = input.name;\n\n            logger.debug('Parsing file input ', fieldname);\n\n            let binaryInput = body[fieldname];\n\n            if (!(binaryInput instanceof BinaryInput)) {\n                // * when data sent with 'multipart/form-data' content type, we expect the files to be in req.files\n                if (req.files?.length > 0) {\n                    const file = req.files.find((file) => file.fieldname === fieldname);\n                    if (!file) continue;\n                    binaryInput = new BinaryInput(file.buffer, uid() + '-' + file.originalname, file.mimetype);\n                }\n            }\n\n            if (binaryInput instanceof BinaryInput) {\n                body[fieldname] = await binaryInput.getJsonData(AccessCandidate.agent(agent.id));\n            }\n            //console.log('file', fieldname, body[fieldname]);\n        }\n\n        return { headers, body, query, params, _authInfo, _debug: logger.output };\n    }\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Joi from 'joi';\n\nexport default class APIOutput extends Component {\n    protected configSchema = Joi.object({\n        format: Joi.string().valid('full', 'minimal').required().label('Output Format'),\n    });\n    public hasPostProcess = true;\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        const _error = undefined;\n        const Output = {};\n        logger.debug(` Processing outputs `);\n        for (let key in input) {\n            Output[key] = input[key];\n        }\n        return { Output, _error, _debug: logger.output };\n    }\n    async postProcess(output, config, agent: Agent): Promise<any> {\n        for (let agentVar in agent.agentVariables) {\n            delete output?.result?.Output?.[agentVar]; //clean up agent variables from output\n        }\n        if (config?.data?.format == 'minimal') {\n            if (output?.result?.Output) {\n                return output?.result?.Output;\n            }\n\n            if (output?.result?._error) {\n                return output?.result?._error;\n            }\n\n            delete output.id;\n            delete output.name;\n        }\n        return output;\n    }\n}\n","export default {\n    echo: {\n        llm: 'Echo',\n        alias: 'Echo',\n    },\n    Echo: {\n        llm: 'Echo',\n        tokens: 128000,\n        completionTokens: 128000,\n        enabled: true,\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n    },\n\n    'gpt-4o-mini': {\n        llm: 'OpenAI',\n        alias: 'gpt-4o-mini-2024-07-18',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n        tags: ['new'],\n    },\n    'gpt-4o-mini-2024-07-18': {\n        llm: 'OpenAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 16383 },\n    },\n    'gpt-4o': {\n        llm: 'OpenAI',\n        alias: 'gpt-4o-2024-05-13',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n        tags: ['new'],\n    },\n    'gpt-4o-2024-05-13': {\n        llm: 'OpenAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 4096 },\n    },\n\n    // GPT-4-turbo\n    'gpt-4-turbo-latest': {\n        llm: 'OpenAI',\n        alias: 'gpt-4-turbo-2024-04-09',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n    },\n    'gpt-4-turbo': {\n        llm: 'OpenAI',\n        alias: 'gpt-4-turbo-2024-04-09',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'GPTPlugin', 'AgentPlugin', 'Chatbot'],\n        tags: ['legacy'],\n    },\n    'gpt-4-turbo-2024-04-09': {\n        llm: 'OpenAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 4096 },\n    },\n\n    // GPT-4\n    'gpt-4-latest': {\n        llm: 'OpenAI',\n        alias: 'gpt-4-0613',\n        enabled: true,\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'gpt-4': {\n        llm: 'OpenAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: true,\n        keyOptions: { tokens: 8192, completionTokens: 8192 },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'GPTPlugin', 'AgentPlugin', 'Chatbot'],\n        tags: ['legacy'],\n    },\n    'gpt-4-0613': {\n        llm: 'OpenAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: true,\n        hidden: true,\n        keyOptions: { tokens: 8192, completionTokens: 8192 },\n    },\n    'gpt-4-vision-preview': {\n        llm: 'OpenAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 4096 },\n        components: ['VisionLLM'],\n    },\n    'gpt-4-1106-vision-preview': {\n        llm: 'OpenAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 4096 },\n    },\n\n    // GPT-3.5\n    'gpt-3.5-turbo-latest': {\n        llm: 'OpenAI',\n        alias: 'gpt-3.5-turbo-0125',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'GPTPlugin', 'AgentPlugin', 'Chatbot'],\n    },\n    'gpt-3.5-turbo': {\n        llm: 'OpenAI',\n        alias: 'gpt-3.5-turbo-0125',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'GPTPlugin', 'AgentPlugin', 'Chatbot'],\n        tags: ['legacy'],\n    },\n    'gpt-3.5-turbo-0125': {\n        llm: 'OpenAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: true,\n        keyOptions: { tokens: 16385, completionTokens: 4096 },\n    },\n    'gpt-3.5-turbo-1106': {\n        llm: 'OpenAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: true,\n        keyOptions: { tokens: 16384, completionTokens: 4096 },\n        //components: ['PromptGenerator', 'LLMAssistant'],\n    },\n\n    'gpt-3.5-turbo-16k': {\n        llm: 'OpenAI',\n        alias: 'gpt-3.5-turbo-0125',\n        //components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    // legacy model to continue support for Agent Plugins\n    'gpt-3.5-turbo-0613': {\n        llm: 'OpenAI',\n        alias: 'gpt-3.5-turbo-0125',\n        //components: ['GPTPlugin', 'AgentPlugin'],\n        tags: ['deprecated'],\n    },\n\n    // AnthropicAI\n    'claude-3-opus': {\n        llm: 'AnthropicAI',\n        alias: 'claude-3-opus-20240229',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n    },\n    'claude-3.5-sonnet': {\n        llm: 'AnthropicAI',\n        alias: 'claude-3-5-sonnet-20240620',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n        tags: ['new'],\n    },\n    'claude-3-sonnet': {\n        llm: 'AnthropicAI',\n        alias: 'claude-3-sonnet-20240229',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n    },\n    'claude-3-haiku': {\n        llm: 'AnthropicAI',\n        alias: 'claude-3-haiku-20240307',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n    },\n    'claude-3-opus-20240229': {\n        llm: 'AnthropicAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 4096, enabled: true },\n    },\n    'claude-3-5-sonnet-20240620': {\n        llm: 'AnthropicAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 4096, enabled: true },\n    },\n    'claude-3-sonnet-20240229': {\n        llm: 'AnthropicAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 4096, enabled: true },\n    },\n    'claude-3-haiku-20240307': {\n        llm: 'AnthropicAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 4096, enabled: true },\n    },\n    'claude-2.1': {\n        llm: 'AnthropicAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n        tags: ['legacy'],\n    },\n    'claude-instant-1.2': {\n        llm: 'AnthropicAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 100000, completionTokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n        tags: ['legacy'],\n    },\n\n    /*** Models from Google AI ***/\n\n    // Gemini 1.5 pro\n    'gemini-1.5-pro-latest': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 1048576, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n        tags: ['legacy'],\n    },\n    'gemini-1.5-pro-latest-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.5-pro',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n        tags: ['new'],\n    },\n    'gemini-1.5-pro-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.5-pro-001',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n        tags: ['new'],\n    },\n    'gemini-1.5-pro': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 1048576, completionTokens: 8192, enabled: true },\n    },\n    'gemini-1.5-pro-001': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 1048576, completionTokens: 8192, enabled: true },\n    },\n\n    // Gemini 1.5 flash\n    'gemini-1.5-flash-latest': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 1048576, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n        tags: ['legacy'],\n    },\n    'gemini-1.5-flash-latest-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.5-flash',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n        tags: ['legacy'],\n    },\n    'gemini-1.5-flash-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.5-flash-001',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n        tags: ['new'],\n    },\n    'gemini-1.5-flash': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 1048576, completionTokens: 8192, enabled: true },\n    },\n    'gemini-1.5-flash-001': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 1048576, completionTokens: 8192, enabled: true },\n    },\n\n    // Gemini 1.0 pro\n    'gemini-1.0-pro-latest': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 30720, completionTokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'gemini-1.0-pro-latest-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.0-pro',\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'gemini-1.0-pro-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.0-pro-001',\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'gemini-1.0-pro': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 30720, completionTokens: 2048, enabled: true },\n    },\n    'gemini-1.0-pro-001': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 30720, completionTokens: 2048, enabled: true },\n    },\n    'gemini-pro-vision': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 12288, completionTokens: 4096, enabled: true },\n        components: ['VisionLLM'],\n    },\n\n    /* Groq */\n    'groq-llama-3.1-405b-reasoning': {\n        llm: 'Groq',\n        alias: 'llama-3.1-405b-reasoning',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama-3.1-405b-reasoning': {\n        llm: 'Groq',\n        tokens: 16000,\n        completionTokens: 16000,\n        enabled: false,\n        keyOptions: { tokens: 131072, completionTokens: 131072, enabled: true },\n    },\n    'groq-llama-3.1-70b-versatile': {\n        llm: 'Groq',\n        alias: 'llama-3.1-70b-versatile',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama-3.1-70b-versatile': {\n        llm: 'Groq',\n        tokens: 8000,\n        completionTokens: 8000,\n        enabled: false,\n        keyOptions: { tokens: 131072, completionTokens: 131072, enabled: true },\n    },\n    'groq-llama-3.1-8b-instant': {\n        llm: 'Groq',\n        alias: 'llama-3.1-8b-instant',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama-3.1-8b-instant': {\n        llm: 'Groq',\n        tokens: 8000,\n        completionTokens: 8000,\n        enabled: false,\n        keyOptions: { tokens: 131072, completionTokens: 131072, enabled: true },\n    },\n    'llama3-groq-70b-tool-use-preview': {\n        llm: 'Groq',\n        tokens: 8192,\n        completionTokens: 8192,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama3-groq-8b-tool-use-preview': {\n        llm: 'Groq',\n        tokens: 8192,\n        completionTokens: 8192,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'groq-llama3-8b': {\n        llm: 'Groq',\n        alias: 'llama3-8b-8192',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'llama3-8b-8192': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n    },\n    'groq-llama3-70b': {\n        llm: 'Groq',\n        alias: 'llama3-70b-8192',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'llama3-70b-8192': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n    },\n    'groq-llama2-70b': {\n        llm: 'Groq',\n        alias: 'llama2-70b-4096',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'llama2-70b-4096': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, completionTokens: 4096, enabled: true },\n    },\n    'groq-mixtral-8x7b': {\n        llm: 'Groq',\n        alias: 'mixtral-8x7b-32768',\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'mixtral-8x7b-32768': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, completionTokens: 32768, enabled: true },\n    },\n    'groq-gemma-7b': {\n        llm: 'Groq',\n        alias: 'gemma-7b-it',\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'gemma-7b-it': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n    },\n\n    /* Together AI */\n    'zero-one-ai/Yi-34B-Chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has \"```json...```\" with JSON response)\n    },\n    'Austism/chronos-hermes-13b': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n\n    // Meta\n    'meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo': {\n        llm: 'togetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 128000, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n    },\n    'meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo': {\n        llm: 'togetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 128000, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n    },\n    'meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo': {\n        llm: 'togetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n    },\n    'meta-llama/Meta-Llama-3-8B-Instruct-Turbo': {\n        llm: 'togetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n    },\n    'meta-llama/Meta-Llama-3-70B-Instruct-Turbo': {\n        llm: 'togetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n    },\n    'meta-llama/Meta-Llama-3-8B-Instruct-Lite': {\n        llm: 'togetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n    },\n    'meta-llama/Meta-Llama-3-70B-Instruct-Lite': {\n        llm: 'togetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n    },\n    'togethercomputer/CodeLlama-13b-Instruct': {\n        // ! DEPRECATED: will be removed (replace with codellama/CodeLlama-13b-Instruct-hf)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n    },\n    'codellama/CodeLlama-13b-Instruct-hf': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'togethercomputer/CodeLlama-34b-Instruct': {\n        // ! DEPRECATED: will be removed (replaced with codellama/CodeLlama-34b-Instruct-hf)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n    },\n    'codellama/CodeLlama-34b-Instruct-hf': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'codellama/CodeLlama-70b-Instruct-hf': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'togethercomputer/CodeLlama-7b-Instruct': {\n        // ! DEPRECATED: will be removed (replaced with codellama/CodeLlama-7b-Instruct-hf)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n    },\n    'codellama/CodeLlama-7b-Instruct-hf': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 16384, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'togethercomputer/llama-2-70b-chat': {\n        // ! DEPRECATED: will be removed (replaced with meta-llama/Llama-2-70b-chat-hf)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n    },\n    'meta-llama/Llama-2-70b-chat-hf': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'togethercomputer/llama-2-13b-chat': {\n        // ! DEPRECATED: will be removed (replaced with meta-llama/Llama-2-13b-chat-hf)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n    },\n    'meta-llama/Llama-2-13b-chat-hf': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has introductory text with JSON response)\n    },\n    'togethercomputer/llama-2-7b-chat': {\n        // ! DEPRECATED: will be removed (replaced with meta-llama/Llama-2-7b-chat-hf)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n    },\n    'meta-llama/Llama-2-7b-chat-hf': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has introductory text with JSON response)\n    },\n    'meta-llama/Llama-3-8b-chat-hf': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'meta-llama/Llama-3-70b-chat-hf': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n\n    'DiscoResearch/DiscoLM-mixtral-8x7b-v2': {\n        // ! DEPRECATED: will be removed (404 - not found)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n    },\n    'togethercomputer/falcon-40b-instruct': {\n        // ! DEPRECATED: will be removed (404 - not found)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n    },\n    'togethercomputer/falcon-7b-instruct': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'togethercomputer/GPT-NeoXT-Chat-Base-20B': {\n        // ! DEPRECATED: will be removed (404 - not found)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n    },\n    'togethercomputer/Llama-2-7B-32K-Instruct': {\n        // ! DEPRECATED: will be removed\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n    },\n\n    // mistralai\n    'mistralai/Mistral-7B-Instruct-v0.1': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'mistralai/Mistral-7B-Instruct-v0.2': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'mistralai/Mistral-7B-Instruct-v0.3': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n        tags: ['legacy'],\n    },\n    'mistralai/Mixtral-8x7B-Instruct-v0.1': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n    },\n    'mistralai/Mixtral-8x22B-Instruct-v0.1': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 65536, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n\n    'Gryphe/MythoMax-L2-13b': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n\n    // NousResearch\n    'NousResearch/Nous-Hermes-Llama2-70b': {\n        // ! DEPRECATED: will be removed (404 - not found)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n    },\n    'NousResearch/Nous-Capybara-7B-V1p9': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'NousResearch/Nous-Hermes-2-Mistral-7B-DPO': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'NousResearch/Nous-Hermes-2-Mixtral-8x7B-DPO': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'NousResearch/Nous-Hermes-2-Mixtral-8x7B-SFT': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'NousResearch/Nous-Hermes-2-Yi-34B': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'NousResearch/Nous-Hermes-llama-2-7b': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'NousResearch/Nous-Hermes-Llama2-13b': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n\n    // OpenChat\n    'openchat/openchat-3.5-1210': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n\n    // Teknium\n    'teknium/OpenHermes-2-Mistral-7B': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'teknium/OpenHermes-2p5-Mistral-7B': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n\n    'garage-bAInd/Platypus2-70B-instruct': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'togethercomputer/Pythia-Chat-Base-7B-v0.16': {\n        // ! DEPRECATED: will be removed (404 - not found)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n    },\n    'togethercomputer/Qwen-7B-Chat': {\n        // ! DEPRECATED: will be removed (404 - not found)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n    },\n    'togethercomputer/RedPajama-INCITE-Chat-3B-v1': {\n        // ! DEPRECATED: will be removed (Weird response)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n    },\n    'togethercomputer/RedPajama-INCITE-7B-Chat': {\n        // ! DEPRECATED: will be removed (Weird response)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n    },\n    'upstage/SOLAR-0-70b-16bit': {\n        // ! DEPRECATED: will be removed (404 - not found) (replaced with upstage/SOLAR-10.7B-Instruct-v1.0)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n    },\n    'upstage/SOLAR-10.7B-Instruct-v1.0': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'togethercomputer/StripedHyena-Nous-7B': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'lmsys/vicuna-7b-v1.5': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'lmsys/vicuna-13b-v1.5': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'lmsys/vicuna-13b-v1.5-16k': {\n        // ! DEPRECATED: will be removed (not exists in models page)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 16384, enabled: true },\n    },\n\n    // Allen AI\n    // ! Response it is not JSON and have unnecessary information\n    /* 'allenai/OLMo-7B-Instruct': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n    }, */\n    'allenai/OLMo-7B-Twin-2T': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'allenai/OLMo-7B': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n\n    // Qwen\n    'Qwen/Qwen1.5-0.5B-Chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has introductory text with JSON response)\n        tags: ['legacy'],\n    },\n    'Qwen/Qwen1.5-1.8B-Chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'Qwen/Qwen1.5-4B-Chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'Qwen/Qwen1.5-7B-Chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'Qwen/Qwen1.5-14B-Chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'Qwen/Qwen1.5-32B-Chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'Qwen/Qwen1.5-72B-Chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'Qwen/Qwen1.5-110B-Chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n\n    // DeepSeek\n    'deepseek-ai/deepseek-coder-33b-instruct': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 16384, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'deepseek-ai/deepseek-llm-67b-chat': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n\n    // Google\n    'google/gemma-2b-it': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'google/gemma-7b-it': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n\n    // Undi95\n    'Undi95/ReMM-SLERP-L2-13B': {\n        // ! DEPRECATED: will be removed (always have empty response)\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n    },\n    'Undi95/Toppy-M-7B': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n\n    // Others\n    'cognitivecomputations/dolphin-2.5-mixtral-8x7b': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'databricks/dbrx-instruct': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'Open-Orca/Mistral-7B-OpenOrca': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'snorkelai/Snorkel-Mistral-PairRM-DPO': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has some other text)\n        tags: ['legacy'],\n    },\n    'Snowflake/snowflake-arctic-instruct': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'togethercomputer/alpaca-7b': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'WizardLM/WizardLM-13B-V1.2': {\n        llm: 'togetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n};\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { LLMChatResponse, LLMConnector } from './LLM.service/LLMConnector';\nimport models from './models';\n\nexport class LLMHelper {\n    private _llmConnector: LLMConnector;\n    private _modelId: string;\n    private _modelInfo: any;\n\n    constructor(private model: string) {\n        const llmName = models[model]?.llm;\n        this._modelId = models[model]?.alias || model;\n        this._modelInfo = models[this._modelId];\n        this._llmConnector = ConnectorService.getLLMConnector(llmName);\n    }\n\n    static load(model: string) {\n        //TODO: cache instances\n        return new LLMHelper(model);\n    }\n\n    public get modelInfo(): any {\n        return this._modelInfo;\n    }\n    public get connector(): LLMConnector {\n        return this._llmConnector;\n    }\n\n    public async promptRequest(prompt, config: any = {}, agent: string | Agent, customParams: any = {}) {\n        if (!this._llmConnector) return { error: 'LLM request failed', details: `Model ${this.model} not supported` };\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        const params: any = await this._llmConnector.extractLLMComponentParams(config);\n        params.model = this._modelId;\n\n        //override params with customParams\n        Object.assign(params, customParams);\n\n        try {\n            prompt = this._llmConnector.enhancePrompt(prompt, config);\n\n            let response: LLMChatResponse = await this._llmConnector.user(AccessCandidate.agent(agentId)).chatRequest(prompt, params);\n\n            const result = this._llmConnector.postProcess(response?.content);\n            if (result.error && response.finishReason !== 'stop') {\n                result.details = 'The model stopped before completing the response, this is usually due to output token limit reached.';\n            }\n            return result;\n        } catch (error: any) {\n            return { error: 'LLM request failed', details: error?.message || error?.toString() };\n        }\n    }\n\n    public async visionRequest(prompt, sources: BinaryInput[], config: any = {}, agent: string | Agent) {\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        const params: any = await this._llmConnector.extractVisionLLMParams(config);\n        params.model = this._modelId;\n        params.sources = sources;\n\n        try {\n            prompt = this._llmConnector.enhancePrompt(prompt, config);\n            let response: LLMChatResponse = await this._llmConnector.user(AccessCandidate.agent(agentId)).visionRequest(prompt, params);\n\n            const result = this._llmConnector.postProcess(response?.content);\n            if (result.error && response.finishReason !== 'stop') {\n                result.details = 'The model stopped before completing the response, this is usually due to output token limit reached.';\n            }\n            return result;\n        } catch (error: any) {\n            return { error: 'LLM request failed', details: error?.message || error?.toString() };\n        }\n    }\n\n    public async toolRequest(params: any, agent: string | Agent) {\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        return this._llmConnector.user(AccessCandidate.agent(agentId)).toolRequest(params);\n    }\n\n    public async streamToolRequest(params: any, agent: string | Agent) {\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        return this._llmConnector.user(AccessCandidate.agent(agentId)).streamToolRequest(params);\n    }\n\n    public async streamRequest(params: any, agent: string | Agent) {\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        return this._llmConnector.user(AccessCandidate.agent(agentId)).streamRequest(params);\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport Joi from 'joi';\nimport Component from './Component.class';\n\n//TODO : better handling of context window exceeding max length\n\nexport default class PromptGenerator extends Component {\n    protected configSchema = Joi.object({\n        model: Joi.string().max(200).required(),\n        prompt: Joi.string().required().label('Prompt'),\n        temperature: Joi.number().min(0).max(5).label('Temperature'), // max temperature is 2 for OpenAI and togetherAI but 5 for cohere\n        maxTokens: Joi.number().min(1).label('Maximum Tokens'),\n        stopSequences: Joi.string().allow('').max(400).label('Stop Sequences'),\n        topP: Joi.number().min(0).max(1).label('Top P'),\n        topK: Joi.number().min(0).max(500).label('Top K'), // max top_k is 100 for togetherAI but 500 for cohere\n        frequencyPenalty: Joi.number().min(0).max(2).label('Frequency Penalty'),\n        presencePenalty: Joi.number().min(0).max(2).label('Presence Penalty'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        //let debugLog = agent.agentRuntime?.debug ? [] : undefined;\n        const logger = this.createComponentLogger(agent, config.name);\n\n        try {\n            logger.debug(`=== LLM Prompt Log ===`);\n\n            const model: string = config.data.model || 'echo';\n            const llmHelper: LLMHelper = LLMHelper.load(model);\n\n            // if the llm is undefined, then it means we removed the model from our system\n            if (!llmHelper.connector) {\n                return {\n                    _error: `The model '${model}' is not available. Please try a different one.`,\n                    _debug: logger.output,\n                };\n            }\n\n            logger.debug(` Model : ${model}`);\n\n            let prompt: any = TemplateString(config.data.prompt).parse(input).result;\n\n            logger.debug(` Parsed prompt\\n`, prompt, '\\n');\n\n            // request to LLM\n            //const response: any = await componentLLMRequest(prompt, model, config).catch((error) => ({ error: error }));\n            const response: any = await llmHelper.promptRequest(prompt, config, agent).catch((error) => ({ error: error }));\n\n            logger.debug(` Enhanced prompt \\n`, prompt, '\\n');\n            // in case we have the response but it's empty string, undefined or null\n            if (!response) {\n                return { _error: ' LLM Error = Empty Response!', _debug: logger.output };\n            }\n\n            if (response?.error) {\n                logger.error(` LLM Error=${JSON.stringify(response.error)}`);\n\n                return { Reply: response?.data, _error: response?.error + ' ' + response?.details, _debug: logger.output };\n            }\n\n            const result = { Reply: response };\n\n            result['_debug'] = logger.output;\n\n            return result;\n        } catch (error) {\n            return { _error: error.message, _debug: logger.output };\n        }\n    }\n}\n","import { AxiosRequestConfig } from 'axios';\nimport Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nfunction parseComponentAnnotations(source, templateSettings) {\n    const arrRegex = new RegExp(/{{([A-Z]+):([\\w\\s]+):\\[(.*?)\\]}}/gm);\n    const jsonRegex = new RegExp(/{{([A-Z]+):([\\w\\s]+):(\\{.*?\\})}}/gm);\n\n    const matches = [...source.matchAll(arrRegex), ...source.matchAll(jsonRegex)];\n    for (const match of matches) {\n        const label = match[2];\n        if (!label) continue;\n\n        const entry: any = Object.values(templateSettings).find((o: any) => o.label == label);\n        if (!entry) continue;\n\n        source = source.replace(match[0], `{{${entry.id}}}`);\n    }\n    return source;\n}\nexport default class APICall extends Component {\n    protected configSchema = Joi.object({\n        method: Joi.string().valid('GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD').required().label('Method'),\n        url: Joi.string()\n            .max(8192) /*.custom(isUrlValid, 'URL validation')*/\n            .required()\n            .label('URL'),\n        headers: Joi.string().allow('').label('Headers'),\n        contentType: Joi.string()\n            .valid('none', 'application/json', 'multipart/form-data', 'binary', 'application/x-www-form-urlencoded', 'text/plain', 'application/xml')\n            .label('Content-Type'),\n        body: Joi.string().allow('').label('Body'),\n        _templateSettings: Joi.object().allow(null).label('Template Settings'),\n        _templateVars: Joi.object().allow(null).label('Template Variables'),\n        proxy: Joi.string().allow('').label('Proxy'),\n        oauthService: Joi.string().allow('').label('OAuth Service'),\n        scope: Joi.string().allow('').label('Scope'),\n        authorizationURL: Joi.string().allow('').label('Authorization URL'),\n        tokenURL: Joi.string().allow('').label('Token URL'),\n        clientID: Joi.string().allow('').label('Client ID'),\n        clientSecret: Joi.string().allow('').label('Client Secret'),\n        oauth2CallbackURL: Joi.string().allow('').label('OAuth2 Callback URL'),\n        callbackURL: Joi.string().allow('').label('Callback URL'), // !TEMP: prevent validation error\n        requestTokenURL: Joi.string().allow('').label('Request Token URL'),\n        accessTokenURL: Joi.string().allow('').label('Access Token URL'),\n        userAuthorizationURL: Joi.string().allow('').label('User Authorization URL'),\n        consumerKey: Joi.string().allow('').label('Consumer Key'),\n        consumerSecret: Joi.string().allow('').label('Consumer Secret'),\n        oauth1CallbackURL: Joi.string().allow('').label('OAuth1 Callback URL'),\n        authenticate: Joi.string().allow('').label('Authenticate'),\n    });\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n        const _error: any = undefined;\n        try {\n            logger.debug(`=== API Call Log ===`);\n            // addittionalParams will collect values that oauth1.0 header require for signature\n            let additionalParams: any = {},\n                rootUrl: any = null;\n            const templateSettings = config?.template?.settings || {};\n\n            const reqConfig: AxiosRequestConfig = {};\n\n            /*\n                We're experiencing an issue displaying binary data as a string in the debug log.\n                To address this, we need to create 'dataForDebug' specifically for the debug log to avoid converting binary data into a string.\n            */\n            let dataForDebug;\n\n            /* === Request Method === */\n            const method = config?.data?.method || 'get';\n\n            reqConfig.method = method;\n\n            let _url = config?.data?.url;\n\n            return { Response: {}, Headers: {}, _error, _debug: logger.output };\n        } catch (error) {\n            return { _error: error.message, _debug: logger.output };\n        }\n    }\n}\n","import Joi from 'joi';\n\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport Component from './Component.class';\n\nexport default class VisionLLM extends Component {\n    protected configSchema = Joi.object({\n        prompt: Joi.string().required().label('Prompt'),\n        maxTokens: Joi.number().min(1).label('Maximum Tokens'),\n        model: Joi.string().max(200).required(),\n    });\n\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            logger.debug(`=== Vision LLM Log ===`);\n            const model: string = config.data.model || 'gpt-4-vision-preview';\n            const llmHelper: LLMHelper = LLMHelper.load(model);\n            // if the llm is undefined, then it means we removed the model from our system\n            if (!llmHelper.connector) {\n                return {\n                    _error: `The model '${model}' is not available. Please try a different one.`,\n                    _debug: logger.output,\n                };\n            }\n            let prompt: any = TemplateString(config.data.prompt).parse(input).result;\n\n            logger.debug(` Parsed prompt\\n`, prompt, '\\n');\n\n            //prompt = llmConnector.enhancePrompt(prompt, config);\n\n            //logger.debug(` Enhanced prompt \\n`, prompt, '\\n');\n\n            const sources = [];\n            const images = Array.isArray(input.Images) ? input.Images : [input.Images];\n            const promises = [];\n            for (let image of images) {\n                const binaryInput = BinaryInput.from(image);\n                sources.push(binaryInput);\n                promises.push(binaryInput.upload(AccessCandidate.agent(agent.id)));\n            }\n\n            await Promise.all(promises);\n\n            const response = await llmHelper.visionRequest(prompt, sources, config, agent);\n            logger.debug(` Enhanced prompt \\n`, prompt, '\\n');\n            // in case we have the response but it's empty string, undefined or null\n            if (!response) {\n                return { _error: ' LLM Error = Empty Response!', _debug: logger.output };\n            }\n\n            if (response?.error) {\n                logger.error(` LLM Error=${JSON.stringify(response.error)}`);\n\n                return { Reply: response?.data, _error: response?.error + ' ' + response?.details, _debug: logger.output };\n            }\n\n            const result = { Reply: response };\n\n            result['_debug'] = logger.output;\n\n            return result;\n        } catch (error: any) {\n            return { _error: error.message, _debug: logger.output };\n        }\n    }\n}\n","// import Component from './Component.class';\nimport Joi from 'joi';\n// import { LLMHelper } from '@sre/LLMManager/LLM.helper';\nimport { validateInteger } from '../utils';\nimport { jsonrepair } from 'jsonrepair';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { JSONContent } from '@sre/helpers/JsonContent.helper';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n// import { LLMHelper } from '@sre/LLMManager/LLM.helper';\n\nclass LLMHelper {\n    static load(model: string) {\n        throw new Error('Method not implemented.');\n    }\n}\n\nexport default class DataSourceLookup extends Component {\n    protected configSchema = Joi.object({\n        topK: Joi.string()\n            .custom(validateInteger({ min: 0 }), 'custom range validation')\n            .label('Result Count'),\n        model: Joi.string().valid('gpt-3.5-turbo', 'gpt-4', 'gpt-3.5-turbo-16k').required(),\n        prompt: Joi.string().max(30000).allow('').label('Prompt'),\n        postprocess: Joi.boolean().strict().required(),\n        includeMetadata: Joi.boolean().strict().optional(),\n        namespace: Joi.string().allow('').max(80).messages({\n            // Need to reserve 30 characters for the prefixed unique id\n            'string.max': `The length of the 'namespace' name must be 50 characters or fewer.`,\n        }),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const componentId = config.id;\n        const component = agent.components[componentId];\n        const teamId = agent.teamId;\n\n        const outputs = {};\n        for (let con of config.outputs) {\n            if (con.default) continue;\n            outputs[con.name] = '';\n        }\n\n        const namespace = config.data.namespace;\n        const model = config.data.model;\n        const prompt = config.data.prompt?.trim?.() || '';\n        const postprocess = config.data.postprocess;\n        const includeMetadata = config.data.includeMetadata || false;\n\n        const _input = typeof input.Query === 'string' ? input.Query : JSON.stringify(input.Query);\n\n        const topK = Math.max(config.data.topK, 50);\n\n        const vectorDB = ConnectorService.getVectorDBConnector();\n\n        let results: string[] | { content: string; metadata: any }[];\n        let _error;\n        try {\n            const response = await vectorDB.user(AccessCandidate.team(teamId)).search(namespace, _input, { topK, includeMetadata: true });\n            results = response.slice(0, config.data.topK).map((result) => ({\n                content: result.metadata?.text,\n                metadata: result.metadata,\n            }));\n\n            if (includeMetadata) {\n                // only show user-level metadata\n                results = results.map((result) => ({\n                    content: result.content,\n                    metadata: this.parseMetadata(\n                        result.metadata?.user || result.metadata?.metadata //* legacy user-specific metadata key [result.metadata?.metadata]\n                    ),\n                }));\n            } else {\n                results = results.map((result) => result.content);\n            }\n        } catch (error) {\n            _error = error.toString();\n        }\n\n        //is there a post processing LLM?\n\n        //TODO : better handling of context window exceeding max length\n        if (postprocess && prompt) {\n            const promises: any = [];\n            for (let result of results) {\n                const _prompt = TemplateString(prompt.replace(/{{result}}/g, JSON.stringify(result))).parse(input).result;\n                // promises.push(LLMHelper.componentLLMRequest(_prompt, model, {}, agent).catch((error) => result));\n                const llmHelper = LLMHelper.load(model);\n                // const req = llmHelper.promptRequest(_prompt, config, agent).catch((error) => ({ error: error }));\n                // promises.push(req);\n            }\n            results = await Promise.all(promises);\n            for (let i = 0; i < results.length; i++) {\n                if (typeof results[i] === 'string') {\n                    // results[i] = parseJson(results[i]);\n                    results[i] = JSONContent(results[i] as string).tryParse();\n                }\n            }\n        }\n\n        const totalLength = JSON.stringify(results).length;\n        return {\n            Results: results,\n            _error,\n            _debug: `totalLength = ${totalLength}`,\n            //_debug: `Query: ${_input}. \\nTotal Length = ${totalLength} \\nResults: ${JSON.stringify(results)}`,\n        };\n    }\n\n    // private async checkIfTeamOwnsNamespace(teamId: string, namespaceId: string, token: string) {\n    //     try {\n    //         const res = await SmythAPIHelper.fromAuth({ token }).mwSysAPI.get(`/vectors/namespaces/${namespaceId}`);\n    //         if (res.data?.namespace?.teamId !== teamId) {\n    //             throw new Error(`Namespace does not exist`);\n    //         }\n    //         return true;\n    //     } catch (err) {\n    //         throw new Error(`Namespace does not exist`);\n    //     }\n    // }\n\n    private parseMetadata(metadata: any) {\n        try {\n            return JSON.parse(jsonrepair(metadata));\n        } catch (err) {\n            return metadata;\n        }\n    }\n}\n","import { OpenAIEmbeddings } from '@langchain/openai';\nimport { RecursiveCharacterTextSplitter } from '@langchain/textsplitters';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { VectorDBConnector } from './VectorDBConnector';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport crypto from 'crypto';\nimport { IVectorDataSourceDto, Source } from '@sre/types/VectorDB.types';\nimport { jsonrepair } from 'jsonrepair';\n\nexport class VectorsHelper {\n    private _connector: VectorDBConnector;\n    private embeddingsProvider: OpenAIEmbeddings;\n    private _vectorDimention: number;\n\n    constructor() {\n        this._connector = ConnectorService.getVectorDBConnector();\n        this.embeddingsProvider = new OpenAIEmbeddings();\n        if (this._vectorDimention && !isNaN(this._vectorDimention)) {\n            this.embeddingsProvider.dimensions = this._vectorDimention;\n        }\n    }\n\n    public static load(options: { vectorDimention?: number } = {}) {\n        const instance = new VectorsHelper();\n        options.vectorDimention && instance.setVectorDimention(options.vectorDimention);\n\n        return instance;\n    }\n\n    public setVectorDimention(vectorDimention: number) {\n        this._vectorDimention = vectorDimention;\n    }\n\n    public static async chunkText(\n        text: string,\n        {\n            chunkSize = 4000,\n            chunkOverlap = 500,\n        }: {\n            chunkSize?: number;\n            chunkOverlap?: number;\n        } = {}\n    ): Promise<string[]> {\n        const textSplitter = new RecursiveCharacterTextSplitter({\n            chunkSize,\n            chunkOverlap,\n        });\n        let output = await textSplitter.splitText(text);\n\n        return output;\n    }\n\n    public async ingestText(\n        text: string,\n        namespace: string,\n        {\n            teamId,\n            metadata,\n            chunkSize = 4000,\n            chunkOverlap = 500,\n        }: {\n            teamId?: string;\n            metadata?: Record<string, string>;\n            chunkSize?: number;\n            chunkOverlap?: number;\n        } = {}\n    ) {\n        const chunkedText = await VectorsHelper.chunkText(text, { chunkSize, chunkOverlap });\n        const ids = Array.from({ length: chunkedText.length }, (_, i) => crypto.randomUUID());\n        const source: IVectorDataSourceDto[] = chunkedText.map((doc, i) => {\n            return {\n                id: ids[i],\n                source: doc,\n                metadata: {\n                    user: VectorsHelper.stringifyMetadata(metadata), // user-speficied metadata\n                },\n            };\n        });\n        const _vIds = await this._connector.user(AccessCandidate.team(teamId)).insert(namespace, source);\n        return _vIds;\n    }\n\n    public async embedText(text: string) {\n        return this.embeddingsProvider.embedQuery(text);\n    }\n\n    public async embedTexts(texts: string[]) {\n        return this.embeddingsProvider.embedDocuments(texts);\n    }\n\n    public static stringifyMetadata(metadata: any) {\n        try {\n            return jsonrepair(JSON.stringify(metadata));\n        } catch (err) {\n            return metadata;\n        }\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\nimport Joi from 'joi';\nimport { validateCharacterSet } from '@sre/utils/validation.utils';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { isUrl, detectURLSourceType } from '../utils';\nimport { SmythFS } from '@sre/IO/Storage.service/SmythFS.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { VectorsHelper } from '@sre/IO/VectorDB.service/Vectors.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { IStorageVectorDataSource } from '@sre/types/VectorDB.types';\n\nexport default class DataSourceIndexer extends Component {\n    private MAX_ALLOWED_URLS_PER_INPUT = 20;\n    protected configSchema = Joi.object({\n        namespace: Joi.string().max(50).allow(''),\n        id: Joi.string().custom(validateCharacterSet, 'id custom validation').allow('').label('source identifier'),\n        name: Joi.string().max(50).allow('').label('label'),\n        metadata: Joi.string().allow(null).allow('').max(10000).label('metadata'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const teamId = agent.teamId;\n        const agentId = agent.id;\n        let debugOutput = agent.agentRuntime?.debug ? '== Source Indexer Log ==\\n' : null;\n\n        try {\n            const _config = {\n                ...config.data,\n                name: TemplateString(config.data.name).parse(input).result,\n                id: TemplateString(config.data.id).parse(input).result,\n                metadata: TemplateString(config.data.metadata).parse(input).result,\n            };\n\n            const outputs = {};\n            for (let con of config.outputs) {\n                if (con.default) continue;\n                outputs[con.name] = con?.description ? `<${con?.description}>` : '';\n            }\n\n            const namespaceId = _config.namespace;\n            debugOutput += `[Selected namespace id] \\n${namespaceId}\\n\\n`;\n            // await this.checkIfTeamOwnsNamespace(teamId, namespaceId, token);\n\n            const inputSchema = this.validateInput(input);\n            if (inputSchema.error) {\n                throw new Error(`Input validation error: ${inputSchema.error}\\n EXITING...`);\n            }\n\n            const providedId = _config.id;\n            // const isAutoId = _config.isAutoId;\n            const idRegex = /^[a-zA-Z0-9\\-\\_\\.]+$/;\n\n            if (!providedId) {\n                // Assign a new ID if it's set to auto-generate or not provided\n                // _config.id = crypto.randomBytes(16).toString('hex');\n                throw new Error(`Id is required`);\n            } else if (!idRegex.test(providedId)) {\n                // Validate the provided ID if it's not auto-generated\n                throw new Error(`Invalid id. Accepted characters: 'a-z', 'A-Z', '0-9', '-', '_', '.'`);\n            }\n\n            const dsId = this.generateContextUID(_config.id, teamId, namespaceId);\n\n            // check if the datasource already exists with the same id\n            // await this.checkForRecordDuplicate(dsId, token);\n\n            let indexRes: any = null;\n            let parsedUrlArray: string[] | null = null;\n\n            //! DISABLE URL ARRAY PARSING FOR NOW UNTIL WE HAVE A GOOD WAY TO HANDLE BULK INDEXING\n            // if ((parsedUrlArray = parseUrlArray(inputSchema.value.Source))) {\n            //     debugOutput += `STEP: Parsing input as url array\\n\\n`;\n            //     if (parsedUrlArray.length > this.MAX_ALLOWED_URLS_PER_INPUT) {\n            //         throw new Error(`Too many urls in input. Max allowed: ${this.MAX_ALLOWED_URLS_PER_INPUT}`);\n            //     }\n\n            //     for (let url of parsedUrlArray) {\n            //         indexRes = await this.addDSFromUrl({\n            //             teamId,\n            //             namespaceId,\n            //             dsId, // WILL OVERRIDE EACH OTHER\n            //             type: detectURLSourceType(url),\n            //             url,\n            //             name: _config.name || 'Untitled',\n            //         });\n\n            //         debugOutput += `STEP: Created datasource for url: ${url}\\n\\n`;\n            //     }\n            // } else\n\n            if (isUrl(inputSchema.value.Source)) {\n                debugOutput += `STEP: Parsing input as url\\n\\n`;\n                throw new Error('URLs are not supported yet');\n                // indexRes = await this.addDSFromUrl({\n                //     teamId,\n                //     namespaceId,\n                //     dsId,\n                //     type: detectURLSourceType(inputSchema.value.Source),\n                //     url: inputSchema.value.Source,\n                //     name: _config.name || 'Untitled',\n                //     metadata: _config.metadata || null,\n                // });\n            } else {\n                debugOutput += `STEP: Parsing input as text\\n\\n`;\n                indexRes = await this.addDSFromText({\n                    teamId,\n                    namespaceId,\n                    dsId,\n                    text: inputSchema.value.Source,\n                    name: _config.name || 'Untitled',\n                    metadata: _config.metadata || null,\n                });\n            }\n\n            debugOutput += `Created datasource successfully\\n\\n`;\n\n            return {\n                _debug: debugOutput,\n                Success: {\n                    result: indexRes?.data?.dataSource || true,\n                    id: _config.id,\n                },\n                // _error,\n            };\n        } catch (err: any) {\n            debugOutput += `Error: ${err?.message || \"Couldn't index data source\"}\\n\\n`;\n            return {\n                _debug: debugOutput,\n                _error: err?.message || \"Couldn't index data source\",\n            };\n        }\n    }\n\n    validateInput(input: any) {\n        return Joi.object({\n            Source: Joi.any().required(),\n        })\n            .unknown(true)\n            .validate(input);\n    }\n\n    public generateContextUID(providedId: string, teamId: string, namespaceId: string) {\n        return `${teamId}::${namespaceId}::${providedId}`;\n    }\n\n    private parseContextUID(uid: string) {\n        if (!uid) return null;\n        const parts = uid.split('::');\n        if (parts.length != 3) return null;\n        return {\n            teamId: parts[0],\n            agentId: parts[1],\n            providedId: parts[2],\n        };\n    }\n\n    private async addDSFromText({ teamId, namespaceId, dsId, text, name, metadata }) {\n        const ids = await VectorsHelper.load().ingestText(text, namespaceId, {\n            teamId,\n            metadata,\n        });\n\n        const url = `smythfs://${teamId}.team/_datasources/${dsId}.json`;\n        const dsData: IStorageVectorDataSource = {\n            namespaceId,\n            teamId,\n            name,\n            metadata,\n            text,\n            embeddingIds: ids,\n        };\n        await SmythFS.Instance.write(url, JSON.stringify(dsData), AccessCandidate.team(teamId));\n    }\n\n    private async addDSFromUrl({ teamId, namespaceId, dsId, type, url, name, metadata }) {\n        throw new Error('URLs are not supported yet');\n        // try {\n        //     const res = await SmythAPIHelper.fromAuth(token).mwSysAPI.post(`/vectors/datasources`, {\n        //         type,\n        //         url,\n        //         name,\n        //         metadata,\n        //         id: dsId,\n        //         namespaceId,\n        //         teamId,\n        //     });\n\n        //     return res;\n        // } catch (err: any) {\n        //     console.log(err?.response?.data);\n        //     throw new Error(err?.response?.data?.message || 'Error creating datasource');\n        // }\n    }\n\n    // private async checkIfTeamOwnsNamespace(teamId: string, namespaceId: string, token: string) {\n    //     try {\n    //         const res = await SmythAPIHelper.fromAuth({ token }).mwSysAPI.get(`/vectors/namespaces/${namespaceId}`);\n    //         if (res.data?.namespace?.teamId !== teamId) {\n    //             throw new Error(`Namespace does not exist`);\n    //         }\n    //         return true;\n    //     } catch (err) {\n    //         throw new Error(`Namespace does not exist`);\n    //     }\n    // }\n\n    // private async checkForRecordDuplicate(dsId: string, token: string) {\n    //     try {\n    //         // try to delete the datasource if it exists\n    //         const res = await SmythAPIHelper.fromAuth({ token }).mwSysAPI.delete(`/vectors/datasources/${dsId}`);\n    //     } catch (err) {}\n    // }\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicAtLeast extends Component {\n    protected configSchema = Joi.object({\n        // TODO (Forhad): Need to check if min and max work instead of the custom validateInteger\n        minSetInputs: Joi.string()\n            .custom(validateInteger({ min: 0, max: 9 }), 'custom range validation')\n            .label('Minimum Inputs'),\n    });\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        const result: any = { Output: undefined };\n\n        if (typeof config.data.minSetInputs !== 'string' || config.data.minSetInputs.trim() === '' || isNaN(Number(config.data.minSetInputs))) {\n            return result;\n        }\n\n        const minSetInputs = Number(config.data.minSetInputs);\n        if (config.inputs.length < minSetInputs) {\n            return result;\n        }\n\n        let trueCount = 0;\n        for (let cfgInput of config.inputs) {\n            if (input[cfgInput.name]) {\n                trueCount++;\n            }\n        }\n\n        if (trueCount >= minSetInputs) {\n            result.Output = true;\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n\n        return result;\n    }\n}\n\ninterface RangeValidationArgs {\n    min?: number;\n    max?: number;\n}\n\nfunction validateInteger(args: RangeValidationArgs) {\n    return (value: string, helpers: any) => {\n        const numValue = Number(value);\n        const fieldName = helpers.schema._flags.label || helpers.state.path[helpers.state.path.length - 1];\n\n        // Check if the value is a number\n        if (isNaN(numValue)) {\n            throw new Error(`The value for '${fieldName}' must be a number`);\n        }\n\n        // Range validations\n        if (args.min !== undefined && args.max !== undefined) {\n            if (numValue < args.min || numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be from ${args.min} to ${args.max}`);\n            }\n        } else if (args.min !== undefined) {\n            if (numValue < args.min) {\n                throw new Error(`The value for '${fieldName}' must be greater or equal to ${args.min}`);\n            }\n        } else if (args.max !== undefined) {\n            if (numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be less or equal to ${args.max}`);\n            }\n        }\n\n        return value; // Value is valid\n    };\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicAtMost extends Component {\n    protected configSchema = Joi.object({\n        // TODO (Forhad): Need to check if min and max work instead of the custom validateInteger\n        maxSetInputs: Joi.string()\n            .custom(validateInteger({ min: 0, max: 9 }), 'custom range validation')\n            .label('Maximum Inputs'),\n    });\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const result: any = { Output: undefined };\n\n        if (typeof config.data.maxSetInputs !== 'string' || config.data.maxSetInputs.trim() === '' || isNaN(Number(config.data.maxSetInputs))) {\n            return result;\n        }\n\n        const maxSetInputs = Number(config.data.maxSetInputs);\n        if (config.inputs.length < maxSetInputs) {\n            return result;\n        }\n\n        let trueCount = 0;\n        for (let cfgInput of config.inputs) {\n            if (input[cfgInput.name]) {\n                trueCount++;\n                if (trueCount > maxSetInputs) {\n                    break;\n                }\n            }\n        }\n\n        if (trueCount <= maxSetInputs) {\n            result.Output = true;\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n\n        return result;\n    }\n}\ninterface RangeValidationArgs {\n    min?: number;\n    max?: number;\n}\n\nfunction validateInteger(args: RangeValidationArgs) {\n    return (value: string, helpers: any) => {\n        const numValue = Number(value);\n        const fieldName = helpers.schema._flags.label || helpers.state.path[helpers.state.path.length - 1];\n\n        // Check if the value is a number\n        if (isNaN(numValue)) {\n            throw new Error(`The value for '${fieldName}' must be a number`);\n        }\n\n        // Range validations\n        if (args.min !== undefined && args.max !== undefined) {\n            if (numValue < args.min || numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be from ${args.min} to ${args.max}`);\n            }\n        } else if (args.min !== undefined) {\n            if (numValue < args.min) {\n                throw new Error(`The value for '${fieldName}' must be greater or equal to ${args.min}`);\n            }\n        } else if (args.max !== undefined) {\n            if (numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be less or equal to ${args.max}`);\n            }\n        }\n\n        return value; // Value is valid\n    };\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport AgentRequest from '@sre/AgentManager/AgentRequest.class';\nimport AgentSettings from '@sre/AgentManager/AgentSettings.class';\nimport { TAgentProcessParams } from '@sre/types/Agent.types';\nimport { uid } from '../utils';\n\nimport { CLIConnector } from '@sre/IO/CLI.service/CLIConnector';\nimport * as FileType from 'file-type';\nimport fs from 'fs';\nimport mime from 'mime';\nimport path from 'path';\nimport { ConnectorService } from './ConnectorsService';\nexport class AgentProcess {\n    public agent: Agent;\n\n    private _loadPromise: Promise<any>;\n\n    private constructor(private agentData: any) {\n        this.initAgent(agentData);\n    }\n    private async initAgent(agentData: any) {\n        let data;\n        let agentId;\n\n        if (typeof agentData === 'object') {\n            data = agentData;\n            if (data.components && data.connections) {\n                data = { data, version: '1.0' };\n            }\n\n            agentId = data.data.id || 'tmp-' + uid();\n        } else {\n            const jsonRegex = /^{.*}$/g;\n            const jsonData = agentData.match(jsonRegex)?.[0];\n\n            const idRegex = /^[a-zA-Z0-9\\-]+$/g;\n            agentId = agentData.match(idRegex)?.[0];\n\n            //We are loading from an agentId\n            if (agentId) {\n                const agentDataConnector = ConnectorService.getAgentDataConnector();\n                data = await agentDataConnector.getAgentData(agentId, 'latest');\n            }\n\n            //we are loading an agent from provided data\n            if (!data && jsonData) {\n                data = JSON.parse(jsonData);\n                //generate an agentId if not provided\n                agentId = data.id || 'tmp-' + uid();\n\n                if (data.components && data.connections) {\n                    data = { data, version: '1.0' };\n                }\n            }\n        }\n\n        const agentSettings = new AgentSettings(agentId);\n        this.agent = new Agent(agentId, data, agentSettings);\n    }\n\n    public async ready() {\n        if (this._loadPromise) {\n            return this._loadPromise;\n        }\n\n        return (this._loadPromise = new Promise((resolve) => {\n            let maxWait = 10000;\n            //wait for agent to be set\n            const itv = setInterval(() => {\n                if (this.agent) {\n                    clearInterval(itv);\n                    resolve(true);\n                }\n                maxWait -= 100;\n                if (maxWait <= 0) {\n                    clearInterval(itv);\n                    resolve(false);\n                }\n            }, 100);\n        }));\n    }\n\n    public static load(agentData: any) {\n        const agentProcess = new AgentProcess(agentData);\n        return agentProcess;\n    }\n\n    public async run(reqConfig: TAgentProcessParams | Array<string> | AgentRequest) {\n        await this.ready();\n        if (!this.agent) throw new Error('Failed to load agent');\n        let request: AgentRequest = this.parseReqConfig(reqConfig);\n\n        this.agent.setRequest(request);\n\n        const pathMatches = request.path.match(/(^\\/v[0-9]+\\.[0-9]+?)?(\\/api\\/(.+)?)/);\n        if (!pathMatches || !pathMatches[2]) {\n            return { status: 404, data: { error: 'Endpoint not found' } };\n        }\n        const endpointPath = pathMatches[2];\n        const input = request.method == 'GET' ? request.query : request.body;\n        const result: any = await this.agent.process(endpointPath, input).catch((error) => ({ error: error.message }));\n\n        return { data: result };\n    }\n\n    public reset() {\n        //the current version of agent cannot be used to run multiple requests\n        //as a workaround we provide this function to reset AgentProcess state by generating a new Agent\n        //TODO: refactor Agent.class in order to allow multiple consecutive requests running\n        this.initAgent(this.agentData);\n    }\n\n    private parseReqConfig(reqConfig: TAgentProcessParams | Array<string> | AgentRequest): AgentRequest {\n        if (reqConfig instanceof AgentRequest) return reqConfig;\n        if (Array.isArray(reqConfig)) return this.parseCLI(reqConfig);\n        return new AgentRequest(reqConfig);\n    }\n\n    private parseCLI(argList: Array<string>): AgentRequest {\n        const cliConnector: CLIConnector = ConnectorService.getCLIConnector();\n        const methods = ['get', 'post', 'put', 'delete', 'patch', 'head', 'options'];\n        const cli: any = cliConnector.parse(argList, ['endpoint', 'post', 'get', 'put', 'delete', 'patch', 'head', 'options', 'headers', 'session']);\n\n        const usedMethod = methods.find((method) => cli[method]);\n\n        const req: AgentRequest = new AgentRequest();\n\n        req.method = usedMethod?.toUpperCase() || 'GET';\n        req.body = {};\n        req.query = {};\n\n        switch (usedMethod) {\n            case 'get':\n            case 'delete':\n            case 'head':\n            case 'options':\n                req.query = cli[usedMethod];\n                break;\n            case 'post':\n            case 'put':\n            case 'patch':\n                req.body = cli[usedMethod];\n                break;\n        }\n\n        req.path = `/api/${cli.endpoint}`;\n        req.params = cli.endpoint?.split('/');\n\n        req.headers = cli.headers || {};\n        //convert all keys to lowercase\n        for (let key in req.headers) {\n            req.headers[key.toLowerCase()] = req.headers[key];\n            delete req.headers[key];\n        }\n\n        req.sessionID = cli.session || uid();\n\n        req.files = [];\n        if (req.body) {\n            for (let entry in req.body) {\n                let value = req.body[entry];\n                const filePath = path.join(process.cwd(), value);\n                const fileName = path.basename(filePath);\n                if (!fs.existsSync(filePath)) continue;\n\n                //read the file and create a file object\n\n                try {\n                    // Read the file content\n                    const fileBuffer = fs.readFileSync(filePath);\n                    const ext: any = fileName.split('.').pop();\n\n                    const fileObj = {\n                        fieldname: entry,\n                        originalname: fileName,\n                        buffer: fileBuffer,\n                        mimetype: mime.getType(ext) || 'application/octet-stream',\n                    };\n\n                    delete req.body[entry];\n                    req.files.push(fileObj);\n\n                    // Try to determine the MIME type from the file content\n                    FileType.fileTypeFromBuffer(fileBuffer).then((fileType) => {\n                        if (fileType) {\n                            fileObj.mimetype = fileType.mime;\n                        }\n                    });\n                } catch (error) {\n                    console.warn('Coud not read file', filePath, error.message);\n                }\n            }\n        }\n\n        return req;\n    }\n\n    public async post(path: string, input?: any, headers?: any) {\n        return this.run({ method: 'POST', path, body: input || {}, headers });\n    }\n\n    public async get(path: string, query?: any, headers?: any) {\n        return this.run({ method: 'GET', path, query, headers });\n    }\n}\n","import { encode, encodeChat } from 'gpt-tokenizer';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\nimport { ChatMessage } from 'gpt-tokenizer/esm/GptEncoding';\n\n//content, name, role, tool_call_id, tool_calls, function_call\nexport class LLMContext {\n    private _llmHelper: LLMHelper;\n    public contextLength: number;\n    public get llmHelper() {\n        return this._llmHelper;\n    }\n\n    public get messages() {\n        return this._messages;\n    }\n    /**\n     *\n     * @param source a messages[] object, or smyth file system uri (smythfs://...)\n     */\n    constructor(private _model, private _systemPrompt: string = '', private _messages: any[] = []) {\n        //TODO:allow configuring a storage service\n        this._llmHelper = LLMHelper.load(this._model);\n    }\n\n    public push(...message: any[]) {\n        this._messages.push(...message);\n\n        //TODO: persist to storage\n    }\n    public addUserMessage(content: string) {\n        this.push({ role: 'user', content });\n    }\n\n    public getContextWindow(maxTokens: number, maxOutputTokens: number = 256): any[] {\n        //TODO: handle non key accounts (limit tokens)\n        const maxModelContext = this._llmHelper?.modelInfo?.keyOptions?.tokens || this._llmHelper?.modelInfo?.tokens || 256;\n        let maxInputContext = Math.min(maxTokens, maxModelContext);\n\n        if (maxInputContext + maxOutputTokens > maxModelContext) {\n            maxInputContext -= maxInputContext + maxOutputTokens - maxModelContext;\n        }\n\n        let messages = [];\n\n        const systemMessage = { role: 'system', content: this._systemPrompt };\n        //loop through messages from last to first and use encodeChat to calculate token lengths\n\n        let tokens = encodeChat([systemMessage as ChatMessage], 'gpt-4o').length;\n        for (let i = this._messages.length - 1; i >= 0; i--) {\n            const message = this._messages[i] as ChatMessage;\n\n            //skip system messages because we will add our own\n\n            if (message.role === 'system') continue;\n\n            //skip empty messages\n            if (!message.content) {\n                //FIXME: tool call messages does not have a content but have a tool field do we need to count them as tokens ?\n                messages.unshift(message);\n                continue;\n            }\n\n            delete message['__smyth_data__']; //remove smyth data entry, this entry may hold smythOS specific data\n\n            const textContent = typeof message.content === 'string' ? message.content : JSON.stringify(message.content);\n            const encoded = encode(textContent);\n            tokens += encoded.length;\n            if (tokens > maxInputContext) {\n                if (typeof message.content !== 'string') {\n                    //FIXME: handle this case for object contents (used by Anthropic for tool calls for example)\n                    break;\n                }\n                //handle context window overflow\n                //FIXME: the logic here is weak, we need a better one\n                const diff = tokens - maxInputContext;\n                const excessPercentage = diff / encoded.length;\n\n                //truncate message content\n                //const textContent = typeof message.content === 'string' ? message.content : JSON.stringify(message.content);\n\n                message.content = message.content.slice(0, Math.floor(message.content.length * (1 - excessPercentage)) - 200);\n                message.content += '...\\n\\nWARNING : The context window has been truncated to fit the maximum token limit.';\n\n                tokens -= encoded.length;\n                tokens += encodeChat([message], 'gpt-4').length;\n                //break;\n            }\n            messages.unshift(message);\n        }\n        //add system message as first message in the context window\n        messages.unshift(systemMessage);\n\n        return messages;\n    }\n}\n","// supported request methods\nexport const REQUEST_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'];\n\nexport const REQUEST_CONTENT_TYPES = {\n    none: 'none',\n    urlEncodedFormData: 'application/x-www-form-urlencoded',\n    multipartFormData: 'multipart/form-data',\n    json: 'application/json',\n    text: 'text/plain',\n    xml: 'application/xml',\n    binary: 'binary',\n};\n\nexport enum EMBODIMENT_TYPES {\n    ChatBot = 'chatBot',\n    ChatGPT = 'chatGPT',\n}\n\nexport const ERR_MSG_INVALID_IMAGE_SOURCE =\n    'Please provide a valid Image Source. Supported image sources are: HTTP(S) URL, Base64 string, Data URL, Output Image from other component(s).';\nexport const ERR_MSG_INVALID_BINARY =\n    'Please provide a valid data that is either a Blob, SmythFileObject (Binary Output from any Component), ArrayBuffer, Buffer, Base64 string, Data URL, or HTTP(s) URL';\nexport const ERR_MSG_MAX_DEPTH = 'The maximum depth has been exceeded for the provided array or object.';\nexport const ERR_MSG_MAX_ARRAY_SIZE = 'The maximum array size has been exceeded for the provided array.';\nexport const ERR_MSG_MAX_OBJECT_SIZE = 'The maximum object size has been exceeded for the provided object.';\n\nexport const MAX_DEPTH = 10;\nexport const MAX_OBJECT_SIZE = 1000;\nexport const MAX_ARRAY_SIZE = 1000;\n\nexport const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\nexport const MAX_FILE_COUNT = 10;\n\n// Default maximum number of tokens allowed for LLM\nexport const DEFAULT_MAX_TOKENS_FOR_LLM = 2048;\n\n// life cycle tag for daily purge of s3 objects\nexport const S3_DAILY_PURGE_LIFECYCLE_TAG = 'ExpirationPolicy=DeleteDaily';\nexport const S3_WEEKLY_PURGE_LIFECYCLE_TAG = 'ExpirationPolicy=DeleteWeekly';\nexport const S3_MONTHLY_PURGE_LIFECYCLE_TAG = 'ExpirationPolicy=DeleteMonthly';\n\nexport const TOOL_USE_DEFAULT_MODEL = 'gpt-3.5-turbo';\n\nexport const COMP_NAMES = {\n    apiCall: 'APICall',\n    code: 'Code',\n    llmPrompt: 'PromptGenerator',\n    visionLLM: 'VisionLLM',\n};\n\nexport const JSON_RESPONSE_INSTRUCTION =\n    '\\nAll responses should be in valid JSON format, compacted without newlines, indentations, or additional JSON syntax markers.';\n","import axios from 'axios';\nimport yaml from 'js-yaml';\n\nimport { REQUEST_METHODS } from '../constants';\n\n// * We need a couple of packages to resolve references in the OpenAPI specification\nimport SwaggerParser from '@apidevtools/swagger-parser';\nimport $RefParser from '@apidevtools/json-schema-ref-parser';\nimport { JSONSchema } from '@apidevtools/json-schema-ref-parser/dist/lib/types';\n\nconst swaggerParser = new SwaggerParser();\n\nexport class OpenAPIParser {\n    static mapReqMethods(paths: Array<Record<string, any>>): Map<string, any> {\n        const methods = new Map();\n\n        for (const path in paths) {\n            const pathData = paths[path];\n\n            for (const method in pathData) {\n                const data = pathData[method];\n\n                if (REQUEST_METHODS.includes(method.toUpperCase())) {\n                    methods.set(data?.operationId, method);\n                }\n            }\n        }\n\n        return methods;\n    }\n    static mapEndpoints(paths: Array<Record<string, any>>): Map<string, any> {\n        const operationIds = new Map();\n\n        for (const path in paths) {\n            const pathData = paths[path];\n\n            // it's possible we have multiple methods for a single path\n            for (const method in pathData) {\n                const data = pathData[method];\n\n                if (REQUEST_METHODS.includes(method.toUpperCase())) {\n                    operationIds.set(data?.operationId, path);\n                }\n            }\n        }\n\n        return operationIds;\n    }\n\n    static async yamlToJson(yamlData: string): Promise<JSONSchema> {\n        const data = yaml.load(yamlData);\n        const schema = await $RefParser.dereference(data);\n\n        return schema;\n    }\n    static async getJson(data: string | Record<string, any>): Promise<Record<string, any>> {\n        try {\n            let _data = data;\n            if (typeof data === 'string') {\n                _data = JSON.parse(_data as string);\n            }\n            const result = swaggerParser.dereference(_data as any);\n            return result;\n        } catch (error) {\n            try {\n                return OpenAPIParser.yamlToJson(data as string);\n            } catch (error) {\n                throw new Error('Invalid OpenAPI specification data format');\n            }\n        }\n    }\n    static async getJsonFromUrl(url: string): Promise<Record<string, any>> {\n        const response = await axios.get(url);\n        const data = response.data;\n\n        return OpenAPIParser.getJson(data);\n    }\n\n    static isValidOpenAPI(data: Record<string, any>): boolean {\n        return data?.openapi && data?.paths && data?.servers;\n    }\n}\n","import { AgentProcess } from '@sre/Core/AgentProcess.helper';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\nimport { LLMContext } from '@sre/MemoryManager/LLMContext';\nimport { TAgentProcessParams } from '@sre/types/Agent.types';\nimport { ToolData } from '@sre/types/LLM.types';\nimport { isUrl } from '@sre/utils/data.utils';\nimport { processWithConcurrencyLimit } from '@sre/utils/general.utils';\nimport axios, { AxiosRequestConfig } from 'axios';\nimport EventEmitter from 'events';\nimport { JSONContent } from './JsonContent.helper';\nimport { OpenAPIParser } from './OpenApiParser.helper';\nimport { Match, TemplateString } from './TemplateString.helper';\n\nconst console = Logger('ConversationHelper');\ntype FunctionDeclaration = {\n    name: string;\n    description: string;\n    properties: Record<string, any>;\n    requiredFields: string[];\n};\ntype ToolParams = {\n    type: string;\n    endpoint: string;\n    args: Record<string, any>;\n    method: string;\n    baseUrl: string;\n    headers?: Record<string, string>;\n};\n\n//TODO: handle authentication\nexport class Conversation extends EventEmitter {\n    private _agentId: string = '';\n\n    public systemPrompt;\n    public assistantName;\n\n    private _reqMethods;\n    private _toolsConfig;\n    private _endpoints;\n    private _baseUrl;\n\n    private _status = '';\n    private _currentWaitPromise;\n\n    private _context: LLMContext;\n    private _maxContextSize = 1024 * 16;\n    private _maxOutputTokens = 1024;\n\n    public get context() {\n        return this._context;\n    }\n\n    private _spec;\n    public set spec(specSource) {\n        this.ready.then(() => {\n            this._status = '';\n            this.loadSpecFromSource(specSource).then((spec) => {\n                if (!spec) {\n                    this._status = 'error';\n                    this.emit('error', 'Invalid OpenAPI specification data format');\n                    throw new Error('Invalid OpenAPI specification data format');\n                }\n                this._spec = spec;\n                this.updateModel(this._model);\n                this._status = 'ready';\n            });\n        });\n    }\n\n    public set model(model: string) {\n        this.ready.then(() => {\n            this._status = '';\n            this.updateModel(model);\n            this._status = 'ready';\n        });\n    }\n    public get model() {\n        return this._model;\n    }\n    constructor(\n        private _model: string,\n        private _specSource?: string | Record<string, any>,\n        private _settings?: { maxContextSize: number; maxOutputTokens: number }\n    ) {\n        super();\n        if (_settings?.maxContextSize) this._maxContextSize = _settings.maxContextSize;\n        if (_settings?.maxOutputTokens) this._maxOutputTokens = _settings.maxOutputTokens;\n        if (_specSource) {\n            this.loadSpecFromSource(_specSource).then((spec) => {\n                if (!spec) {\n                    this._status = 'error';\n                    this.emit('error', 'Invalid OpenAPI specification data format');\n                    throw new Error('Invalid OpenAPI specification data format');\n                }\n                this._spec = spec;\n\n                this.updateModel(this._model);\n                this._status = 'ready';\n            });\n        } else {\n            this.updateModel(this._model);\n            this._status = 'ready';\n        }\n    }\n\n    private get ready() {\n        if (this._currentWaitPromise) return this._currentWaitPromise;\n        this._currentWaitPromise = new Promise((resolve, reject) => {\n            if (this._status) {\n                return resolve(true);\n            }\n\n            const maxWaitTime = 30000;\n            let waitTime = 0;\n            const interval = 100;\n\n            const wait = setInterval(() => {\n                if (this._status) {\n                    clearInterval(wait);\n                    return resolve(true);\n                } else {\n                    waitTime += interval;\n                    if (waitTime >= maxWaitTime) {\n                        clearInterval(wait);\n                        return reject('Timeout: Failed to prepare data');\n                    }\n                }\n            }, interval);\n        });\n\n        return this._currentWaitPromise;\n    }\n\n    //TODO : handle attachments\n    public async prompt(message?: string, toolHeaders = {}) {\n        await this.ready;\n\n        const reqMethods = this._reqMethods;\n        const toolsConfig = this._toolsConfig;\n        const endpoints = this._endpoints;\n        const baseUrl = this._baseUrl;\n\n        /* ==================== STEP ENTRY ==================== */\n        console.debug('Request to LLM with the given model, messages and functions properties.', {\n            model: this.model,\n            message,\n            toolsConfig,\n        });\n        /* ==================== STEP ENTRY ==================== */\n        const llmHelper: LLMHelper = LLMHelper.load(this.model);\n\n        if (message) this._context.addUserMessage(message);\n\n        const contextWindow = this._context.getContextWindow(this._maxContextSize, this._maxOutputTokens);\n\n        const { data: llmResponse, error } = await llmHelper.toolRequest(\n            {\n                model: this.model,\n                messages: contextWindow,\n                toolsConfig,\n                max_tokens: this._maxOutputTokens,\n            },\n            this._agentId\n        );\n\n        if (error) {\n            throw new Error(\n                '[LLM Request Error]\\n' +\n                    JSON.stringify({\n                        code: error?.name || 'LLMRequestFailed',\n                        message: error?.message || 'Something went wrong while calling LLM.',\n                    })\n            );\n        }\n\n        // useTool = true means we need to use it\n        if (llmResponse?.useTool) {\n            /* ==================== STEP ENTRY ==================== */\n            console.debug({\n                type: 'ToolsData',\n                message: 'Tool(s) is available for use.',\n                toolsData: llmResponse?.toolsData,\n            });\n            /* ==================== STEP ENTRY ==================== */\n\n            const toolsData: ToolData[] = [];\n\n            for (const tool of llmResponse?.toolsData) {\n                const endpoint = endpoints?.get(tool?.name);\n                // Sometimes we have object response from the LLM such as Anthropic\n                const parsedArgs = JSONContent(tool?.arguments).tryParse();\n                let args = typeof tool?.arguments === 'string' ? parsedArgs || {} : tool?.arguments;\n\n                if (args?.error) {\n                    throw new Error('[Tool] Arguments Parsing Error\\n' + JSON.stringify({ message: args?.error }));\n                }\n\n                const toolArgs = {\n                    type: tool?.type,\n                    method: reqMethods?.get(tool?.name),\n                    endpoint,\n                    args,\n                    baseUrl,\n                    headers: toolHeaders,\n                };\n\n                /* ==================== STEP ENTRY ==================== */\n                console.debug({\n                    type: 'UseTool',\n                    message: 'As LLM returned a tool to use, so use it with the provided arguments.',\n                    plugin_url: { baseUrl, endpoint, args },\n                    arguments: args,\n                });\n                /* ==================== STEP ENTRY ==================== */\n\n                this.emit('beforeToolCall', toolArgs);\n                //TODO: Should we run these tools in parallel?\n                let { data: functionResponse, error } = await this.useTool(toolArgs);\n\n                if (error) {\n                    this.emit('toolCallError', toolArgs, error);\n                    functionResponse = typeof error === 'object' && typeof error !== null ? JSON.stringify(error) : error;\n                }\n\n                functionResponse =\n                    typeof functionResponse === 'object' && typeof functionResponse !== null ? JSON.stringify(functionResponse) : functionResponse;\n\n                /* ==================== STEP ENTRY ==================== */\n                console.debug({\n                    type: 'ToolResult',\n                    message: 'Result from the tool',\n                    response: functionResponse,\n                });\n                /* ==================== STEP ENTRY ==================== */\n\n                this.emit('afterToolCall', toolArgs, functionResponse);\n                toolsData.push({ ...tool, result: functionResponse });\n            }\n\n            const messagesWithToolResult = llmHelper.connector.prepareInputMessageBlocks({ messageBlock: llmResponse?.message, toolsData });\n\n            this._context.push(...messagesWithToolResult);\n\n            return this.prompt(null, toolHeaders);\n        }\n\n        let content = JSONContent(llmResponse?.content).tryParse();\n\n        /* ==================== STEP ENTRY ==================== */\n        console.debug({\n            type: 'FinalResult',\n            message: 'Here is the final result after processing all the tools and LLM response.',\n            response: content,\n        });\n        /* ==================== STEP ENTRY ==================== */\n\n        return content;\n    }\n\n    //TODO : handle attachments\n    public async streamPrompt(message?: string, toolHeaders = {}, concurrentToolCalls = 4) {\n        await this.ready;\n\n        //let promises = [];\n        let _content = '';\n        const reqMethods = this._reqMethods;\n        const toolsConfig = this._toolsConfig;\n        const endpoints = this._endpoints;\n        const baseUrl = this._baseUrl;\n\n        /* ==================== STEP ENTRY ==================== */\n        // console.debug('Request to LLM with the given model, messages and functions properties.', {\n        //     model: this.model,\n        //     message,\n        //     toolsConfig,\n        // });\n        /* ==================== STEP ENTRY ==================== */\n        const llmHelper: LLMHelper = LLMHelper.load(this.model);\n\n        if (message) this._context.addUserMessage(message);\n\n        const contextWindow = this._context.getContextWindow(this._maxContextSize, this._maxOutputTokens);\n\n        const eventEmitter: any = await llmHelper\n            .streamRequest(\n                {\n                    model: this.model,\n                    messages: contextWindow,\n                    toolsConfig,\n                    max_tokens: this._maxOutputTokens,\n                },\n                this._agentId\n            )\n            .catch((error) => {\n                console.error('Error on streamRequest: ', error);\n            });\n\n        if (!eventEmitter || eventEmitter.error) {\n            throw new Error('[LLM Request Error]');\n        }\n\n        if (message) this.emit('start');\n        eventEmitter.on('data', (data) => {\n            this.emit('data', data);\n        });\n\n        eventEmitter.on('content', (content) => {\n            _content += content;\n            this.emit('content', content);\n        });\n\n        let toolsPromise = new Promise((resolve, reject) => {\n            let hasTools = false;\n            eventEmitter.on('toolsData', async (toolsData) => {\n                hasTools = true;\n                let llmMessage: any = {\n                    role: 'assistant',\n                    content: _content,\n                    tool_calls: [],\n                };\n                llmMessage.tool_calls = toolsData.map((tool) => {\n                    return {\n                        id: tool.id,\n                        type: tool.type,\n                        function: {\n                            name: tool.name,\n                            arguments: tool.arguments,\n                        },\n                    };\n                });\n\n                //if (llmMessage.tool_calls?.length <= 0) return;\n\n                this.emit('toolInfo', toolsData); // replaces onFunctionCallResponse in legacy code\n\n                const toolProcessingTasks = toolsData.map(\n                    (tool: { index: number; name: string; type: string; arguments: Record<string, any> }) => async () => {\n                        const endpoint = endpoints?.get(tool?.name);\n                        // Sometimes we have object response from the LLM such as Anthropic\n\n                        let args = typeof tool?.arguments === 'string' ? JSONContent(tool?.arguments).tryParse() || {} : tool?.arguments;\n\n                        if (args?.error) {\n                            throw new Error('[Tool] Arguments Parsing Error\\n' + JSON.stringify({ message: args?.error }));\n                        }\n\n                        //await beforeFunctionCall(llmMessage, toolsData[tool.index]);\n                        this.emit('beforeToolCall', { tool, args });\n\n                        const toolArgs = {\n                            type: tool?.type,\n                            method: reqMethods?.get(tool?.name),\n                            endpoint,\n                            args,\n                            baseUrl,\n                            headers: toolHeaders,\n                        };\n\n                        let { data: functionResponse, error } = await this.useTool(toolArgs);\n\n                        if (error) {\n                            functionResponse = typeof error === 'object' && typeof error !== null ? JSON.stringify(error) : error;\n                        }\n\n                        functionResponse =\n                            typeof functionResponse === 'object' && typeof functionResponse !== null\n                                ? JSON.stringify(functionResponse)\n                                : functionResponse;\n\n                        //await afterFunctionCall(functionResponse, toolsData[tool.index]);\n                        this.emit('afterToolCall', { tool, args }, functionResponse);\n\n                        return { ...tool, result: functionResponse };\n                    }\n                );\n\n                const processedToolsData = await processWithConcurrencyLimit<ToolData>(toolProcessingTasks, concurrentToolCalls);\n\n                const messagesWithToolResult = llmHelper.connector.prepareInputMessageBlocks({\n                    messageBlock: llmMessage,\n                    toolsData: processedToolsData,\n                });\n\n                this._context.push(...messagesWithToolResult);\n\n                resolve(await this.streamPrompt(null, toolHeaders, concurrentToolCalls));\n            });\n\n            eventEmitter.on('end', async (toolsData) => {\n                if (!hasTools) {\n                    resolve('');\n                }\n            });\n        });\n\n        const toolsContent = await toolsPromise;\n        _content += toolsContent;\n        let content = JSONContent(_content).tryParse();\n\n        // let streamPromise = new Promise((resolve, reject) => {\n        //     eventEmitter.on('end', async () => {\n        //         if (toolsPromise) await toolsPromise;\n\n        //         let content = JSONContent(_content).tryParse();\n        //         resolve({ content });\n        //     });\n        // });\n\n        // promises.push(streamPromise);\n\n        //await Promise.all(promises);\n        //return content;\n\n        if (message) {\n            this._context.push({ role: 'assistant', content: content });\n            this.emit('end');\n        }\n\n        return content;\n    }\n\n    public async _streamPrompt(message?: string, toolHeaders = {}, concurrentToolCalls = 4) {\n        await this.ready;\n\n        const reqMethods = this._reqMethods;\n        const toolsConfig = this._toolsConfig;\n        const endpoints = this._endpoints;\n        const baseUrl = this._baseUrl;\n\n        /* ==================== STEP ENTRY ==================== */\n        // console.debug('Request to LLM with the given model, messages and functions properties.', {\n        //     model: this.model,\n        //     message,\n        //     toolsConfig,\n        // });\n        /* ==================== STEP ENTRY ==================== */\n        const llmHelper: LLMHelper = LLMHelper.load(this.model);\n\n        if (message) this._context.addUserMessage(message);\n        const contextWindow = this._context.getContextWindow(this._maxContextSize, this._maxOutputTokens);\n\n        const { data: llmResponse, error } = await llmHelper.streamToolRequest(\n            {\n                model: this.model,\n                messages: contextWindow,\n                toolsConfig,\n            },\n            this._agentId\n        );\n\n        if (error) {\n            throw new Error(\n                '[LLM Request Error]\\n' +\n                    JSON.stringify({\n                        code: error?.name || 'LLMRequestFailed',\n                        message: error?.message || 'Something went wrong while calling LLM.',\n                    })\n            );\n        }\n\n        // useTool = true means we need to use it\n        if (llmResponse?.useTool) {\n            const llmMessage = llmResponse?.message;\n            const toolsData = llmResponse?.toolsData;\n\n            /* ==================== STEP ENTRY ==================== */\n            // console.debug({\n            //     type: 'ToolsData',\n            //     message: 'Tool(s) is available for use.',\n            //     toolsData: llmResponse?.toolsData,\n            // });\n            /* ==================== STEP ENTRY ==================== */\n\n            this.emit('toolInfo', toolsData); // replaces onFunctionCallResponse in legacy code\n\n            const toolProcessingTasks = toolsData.map(\n                (tool: { index: number; name: string; type: string; arguments: Record<string, any> }) => async () => {\n                    const endpoint = endpoints?.get(tool?.name);\n                    // Sometimes we have object response from the LLM such as Anthropic\n\n                    let args = typeof tool?.arguments === 'string' ? JSONContent(tool?.arguments).tryParse() || {} : tool?.arguments;\n\n                    if (args?.error) {\n                        throw new Error('[Tool] Arguments Parsing Error\\n' + JSON.stringify({ message: args?.error }));\n                    }\n\n                    //await beforeFunctionCall(llmMessage, toolsData[tool.index]);\n                    this.emit('beforeToolCall', { tool, args });\n\n                    const toolArgs = {\n                        type: tool?.type,\n                        method: reqMethods?.get(tool?.name),\n                        endpoint,\n                        args,\n                        baseUrl,\n                        headers: toolHeaders,\n                    };\n\n                    let { data: functionResponse, error } = await this.useTool(toolArgs);\n\n                    if (error) {\n                        functionResponse = typeof error === 'object' && typeof error !== null ? JSON.stringify(error) : error;\n                    }\n\n                    functionResponse =\n                        typeof functionResponse === 'object' && typeof functionResponse !== null\n                            ? JSON.stringify(functionResponse)\n                            : functionResponse;\n\n                    //await afterFunctionCall(functionResponse, toolsData[tool.index]);\n                    this.emit('afterToolCall', { tool, args }, functionResponse);\n\n                    return { ...tool, result: functionResponse };\n                }\n            );\n\n            const processedToolsData = await processWithConcurrencyLimit<ToolData>(toolProcessingTasks, concurrentToolCalls);\n\n            const messagesWithToolResult = llmHelper.connector.prepareInputMessageBlocks({\n                messageBlock: llmMessage,\n                toolsData: processedToolsData,\n            });\n\n            this._context.push(...messagesWithToolResult);\n\n            return this.streamPrompt(null, toolHeaders, concurrentToolCalls);\n        }\n        let _content = '';\n        if (llmResponse.content) {\n            _content = llmResponse.content;\n        }\n        if (llmResponse.stream) {\n            this.emit('start');\n            for await (const part of llmResponse.stream) {\n                const delta = part.choices[0].delta;\n\n                //if (!_content) delta.content = '\\n\\n' + delta.content;\n                //onResponse(delta);\n                this.emit('data', delta);\n                if (delta.content) this.emit('content', delta.content);\n                _content += delta.content || '';\n            }\n\n            this.emit('end');\n        }\n        let content = JSONContent(_content).tryParse();\n\n        /* ==================== STEP ENTRY ==================== */\n        // console.debug({\n        //     type: 'FinalResult',\n        //     message: 'Here is the final result after processing all the tools and LLM response.',\n        //     response: content,\n        // });\n        /* ==================== STEP ENTRY ==================== */\n\n        return content;\n    }\n    private resolveToolEndpoint(baseUrl: string, method: string, endpoint: string, params: Record<string, any>): string {\n        //handle query params\n        let templateParams = {};\n        if (params) {\n            const parameters = this._spec?.paths?.[endpoint]?.[method.toLowerCase()]?.parameters || [];\n            for (let p of parameters) {\n                if (p.in === 'path') {\n                    templateParams[p.name] = params[p.name] || '';\n                    delete params[p.name];\n                }\n            }\n        }\n        const parsedEndpoint = TemplateString(endpoint).parse(templateParams, Match.singleCurly).clean().result;\n\n        // Create a new URL object using the base URL and endpoint\n        const url = new URL(parsedEndpoint, baseUrl);\n\n        // Iterate over the params object and append each key/value pair to the URL search parameters\n        Object.keys(params).forEach((key) => {\n            url.searchParams.append(key, params[key]);\n        });\n\n        // Return the full URL as a string\n        return url.toString();\n    }\n\n    private async useTool(params: ToolParams): Promise<{\n        data: any;\n        error;\n    }> {\n        const { type, endpoint, args, method, baseUrl, headers = {} } = params;\n\n        if (type === 'function') {\n            try {\n                const url = this.resolveToolEndpoint(baseUrl, method, endpoint, method == 'get' ? args : {});\n\n                const reqConfig: AxiosRequestConfig = {\n                    method,\n                    url,\n                    headers,\n                };\n\n                if (method !== 'get') {\n                    if (Object.keys(args).length) {\n                        reqConfig.data = args;\n                    }\n                    (reqConfig.headers as Record<string, unknown>)['Content-Type'] = 'application/json';\n                }\n\n                console.debug('Calling tool: ', reqConfig);\n                if (reqConfig.url.includes('localhost')) {\n                    //if it's a local agent, invoke it directly\n                    const response = await AgentProcess.load(reqConfig.headers['X-AGENT-ID']).run(reqConfig as TAgentProcessParams);\n                    return { data: response.data, error: null };\n                } else {\n                    //if it's a remote agent, call the API via HTTP\n                    const response = await axios.request(reqConfig);\n\n                    return { data: response.data, error: null };\n                }\n            } catch (error: any) {\n                console.warn('Failed to call Tool: ', baseUrl, endpoint);\n                console.warn('  ====>', error);\n                return { data: null, error: error?.response?.data || error?.message };\n            }\n        }\n\n        return { data: null, error: `'${type}' tool type not supported at the moment` };\n    }\n    /**\n     * updates LLM model, if spec is available, it will update the tools config\n     * @param model\n     */\n    private updateModel(model: string) {\n        this._model = model;\n\n        if (this._spec) {\n            this._reqMethods = OpenAPIParser.mapReqMethods(this._spec?.paths);\n            this._endpoints = OpenAPIParser.mapEndpoints(this._spec?.paths);\n            this._baseUrl = this._spec?.servers?.[0].url;\n\n            const functionDeclarations = this.getFunctionDeclarations(this._spec);\n            const llmHelper: LLMHelper = LLMHelper.load(this._model);\n            this._toolsConfig = llmHelper.connector.formatToolsConfig({\n                type: 'function',\n                toolDefinitions: functionDeclarations,\n                toolChoice: 'auto',\n            });\n\n            let messages = [];\n            if (this._context) messages = this._context.messages; // preserve messages\n\n            this._context = new LLMContext(this._model, this.systemPrompt, messages);\n        } else {\n            this._toolsConfig = null;\n            this._reqMethods = null;\n            this._endpoints = null;\n            this._baseUrl = null;\n        }\n    }\n\n    /**\n     * this function is used to patch the spec with missing fields that are required for the tool to work\n     * @param spec\n     */\n    private patchSpec(spec: Record<string, any>) {\n        const paths = spec?.paths;\n        for (const path in paths) {\n            const pathData = paths[path];\n\n            // it's possible we have multiple methods for a single path\n            for (const key in pathData) {\n                const data = pathData[key];\n                if (!data?.operationId) {\n                    //normalize path and use it as operationId\n                    data.operationId = path.replace(/\\//g, '_').replace(/{|}/g, '').replace(/\\./g, '_');\n                }\n            }\n        }\n        return spec;\n    }\n    /**\n     * Loads OpenAPI specification from source\n     * @param specSource\n     * @returns\n     */\n    private async loadSpecFromSource(specSource: string | Record<string, any>) {\n        if (typeof specSource === 'object') {\n            if (OpenAPIParser.isValidOpenAPI(specSource)) return this.patchSpec(specSource);\n            return null;\n        }\n\n        if (typeof specSource === 'string') {\n            if (isUrl(specSource as string)) {\n                const spec = await OpenAPIParser.getJsonFromUrl(specSource as string);\n                if (spec.info?.description) this.systemPrompt = spec.info.description;\n                if (spec.info?.title) this.assistantName = spec.info.title;\n\n                const defaultBaseUrl = new URL(specSource as string).origin;\n\n                if (!spec?.servers) spec.servers = [{ url: defaultBaseUrl }];\n                if (spec.servers?.length == 0) spec.servers = [{ url: defaultBaseUrl }];\n\n                if (this.assistantName) {\n                    this.systemPrompt = `Assistant Name : ${this.assistantName}\\n\\n${this.systemPrompt}`;\n                }\n\n                return this.patchSpec(spec);\n            }\n            const agentDataConnector = ConnectorService.getAgentDataConnector();\n            const agentId = specSource as string;\n            const agentData = await agentDataConnector.getAgentData(agentId).catch((error) => null);\n            if (!agentData) return null;\n            this._agentId = agentId;\n            this.systemPrompt = agentData?.data?.behavior || this.systemPrompt;\n            this.assistantName = agentData?.data?.name || agentData?.data?.templateInfo?.name || this.assistantName;\n            if (this.assistantName) {\n                this.systemPrompt = `Assistant Name : ${this.assistantName}\\n\\n${this.systemPrompt}`;\n            }\n            const spec = await agentDataConnector.getOpenAPIJSON(agentData, 'http://localhost/', 'latest', true).catch((error) => null);\n            return this.patchSpec(spec);\n        }\n    }\n\n    /**\n     * Extracts function declarations from OpenAPI specification\n     * @param spec\n     * @returns\n     */\n    private getFunctionDeclarations(spec): FunctionDeclaration[] {\n        const paths = spec?.paths;\n        const reqMethods = OpenAPIParser.mapReqMethods(paths);\n\n        let declarations: FunctionDeclaration[] = [];\n\n        for (const path in paths) {\n            const pathData = paths[path];\n\n            // it's possible we have multiple methods for a single path\n            for (const key in pathData) {\n                const data = pathData[key];\n\n                const method = reqMethods.get(data?.operationId) || 'get';\n\n                let properties = {};\n                let requiredFields: string[] = [];\n\n                if (method.toLowerCase() === 'get') {\n                    const params = data?.parameters || [];\n                    for (const prop of params) {\n                        properties[prop.name] = {\n                            ...prop.schema,\n                            description: prop.description,\n                        };\n\n                        if (prop.required === true) {\n                            requiredFields.push(prop?.name || '');\n                        }\n                    }\n                } else {\n                    properties = data?.requestBody?.content?.['application/json']?.schema?.properties;\n                    requiredFields = data?.requestBody?.content?.['application/json']?.schema?.required;\n\n                    // Open AI doesn't support 'required' to be boolean inside property\n                    for (const prop in properties) {\n                        delete properties[prop]?.required;\n                    }\n                }\n\n                if (!properties) properties = {};\n                if (!requiredFields) requiredFields = [];\n\n                const declaration = {\n                    name: data?.operationId,\n                    description: data?.description || data?.summary || '',\n                    properties,\n                    requiredFields,\n                };\n                declarations.push(declaration);\n            }\n        }\n\n        return declarations;\n    }\n}\n","import Joi from 'joi';\n\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { Conversation } from '@sre/helpers/Conversation.helper';\nimport Component from './Component.class';\n\nexport default class AgentPlugin extends Component {\n    protected configSchema = Joi.object({\n        agentId: Joi.string().max(200).required(),\n        openAiModel: Joi.string().max(200).required(),\n        descForModel: Joi.string().max(5000).allow('').label('Description for Model'),\n        id: Joi.string().max(200),\n        name: Joi.string().max(500),\n        desc: Joi.string().max(5000).allow('').label('Description'),\n        logoUrl: Joi.string().max(8192).allow(''),\n        version: Joi.string().max(100).allow(''),\n        domain: Joi.string().max(253).allow(''),\n    });\n\n    constructor() {\n        super();\n    }\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n\n        logger.debug(`=== Agent Plugin Log ===`);\n\n        try {\n            const subAgentId = config.data?.agentId;\n\n            if (!subAgentId) {\n                return { _error: 'Agent Component ID is required!', _debug: logger.output };\n            }\n\n            //tag this request to tell the nested agent that the call comes from internal agent\n            const reqTag = agent.agentRuntime?.reqTag;\n\n            const model = config?.data?.openAiModel;\n            const descForModel = TemplateString(config?.data?.descForModel).parse(input).result;\n            const prompt = typeof input?.Prompt === 'string' ? input?.Prompt : JSON.stringify(input?.Prompt);\n\n            const agentDataConnector = ConnectorService.getAgentDataConnector();\n\n            //let subAgentDomain = await isDeployed(subAgentId);\n            // when domain found for sub agent, that means it's deployed\n            const isSubAgentDeployed = await agentDataConnector.isDeployed(subAgentId);\n\n            let version = config.data?.version || '';\n\n            logger.debug('Version: ', version);\n\n            if (version === 'same-as-parent') {\n                const isParentAgentDeployed = await agentDataConnector.isDeployed(agent?.id);\n\n                if (isParentAgentDeployed) {\n                    if (isSubAgentDeployed) {\n                        version = 'latest';\n                    } else {\n                        return {\n                            _error: `Call failed, Agent '${config.data?.name}' (${subAgentId}) is not deployed. Please deploy the agent and try again.`,\n                            _debug: logger.output,\n                        };\n                    }\n                } else {\n                    version = ''; // empty string ('') means latest dev version\n                }\n            } else if (version === 'dev-latest') {\n                version = '';\n            } else if (version === 'prod-latest') {\n                if (isSubAgentDeployed) {\n                    version = 'latest';\n                } else {\n                    return {\n                        _error: `Call failed, Agent '${config.data?.name}' (${subAgentId}) is not deployed. Please deploy the agent and try again.`,\n                        _debug: logger.output,\n                    };\n                }\n            }\n\n            const conv = new Conversation(config?.data?.openAiModel, subAgentId);\n\n            const result = await conv.prompt(prompt, {\n                'X-AGENT-ID': subAgentId,\n                'X-AGENT-VERSION': version,\n                'X-REQUEST-TAG': reqTag, //request Tag identifies the request and tells the called agent that the call comes from internal agent\n                'x-caller-session-id': agent.callerSessionId,\n            });\n\n            logger.debug(`Response:\\n`, result, '\\n');\n\n            return { Response: result, _debug: logger.output };\n        } catch (error: any) {\n            console.error('Error on running Agent Component: ', error);\n            return { _error: `Error on running Agent Component!\\n${error?.message || JSON.stringify(error)}`, _debug: logger.output };\n        }\n    }\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\nimport { CacheConnector } from '@sre/MemoryManager/Cache.service';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { DEFAULT_MAX_TOKENS_FOR_LLM } from '@sre/constants';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { encode } from 'gpt-tokenizer';\nimport Component from './Component.class';\nimport { JSONContent, JSONContentHelper } from '@sre/helpers/JsonContent.helper';\n\n//const sessions = {};\nlet cacheConnector: CacheConnector;\nfunction getCacheConnector() {\n    if (!cacheConnector) {\n        cacheConnector = ConnectorService.getCacheConnector();\n    }\n    return cacheConnector;\n}\n\nasync function saveMessagesToSession(agentId, userId, conversationId, messages, ttl?) {\n    if (!userId && !conversationId) return;\n    const cacheConnector = getCacheConnector();\n    const conv_uid = `${agentId}:conv-u${userId}-c${conversationId}`;\n\n    cacheConnector.user(AccessCandidate.agent(agentId)).set(conv_uid, JSON.stringify(messages), null, null, ttl);\n}\n\nasync function readMessagesFromSession(agentId, userId, conversationId, maxTokens = DEFAULT_MAX_TOKENS_FOR_LLM) {\n    if (!userId && !conversationId) return [];\n    const cacheConnector = getCacheConnector();\n\n    const conv_uid = `${agentId}:conv-u${userId}-c${conversationId}`;\n    //read the last messages from a given session and ensure that the total chat tokens are within the limit\n    //start from the last message and keep adding messages until the total tokens exceed the limit\n    //if (!sessions[agentId]) return [];\n    //if (!sessions[agentId][conv_uid]) return [];\n\n    const sessionData = await cacheConnector.user(AccessCandidate.agent(agentId)).get(conv_uid);\n\n    const messages = sessionData ? JSONContent(sessionData).tryParse() : [];\n    //const messages = sessions[agentId][conv_uid].messages;\n\n    const filteredMessages: any[] = [];\n\n    let tokens = 0;\n    if (messages[0]?.role == 'system') {\n        const encoded = encode(messages[0]?.content);\n        const messageTokens = encoded.length + 3;\n        tokens += messageTokens;\n    }\n\n    for (let i = messages.length - 1; i >= 0; i--) {\n        if (messages[i].role == 'system') continue;\n        const message = messages[i];\n        const encoded = encode(message?.content);\n        const messageTokens = encoded.length + 3;\n        if (tokens + messageTokens > maxTokens) break;\n        filteredMessages.unshift(message);\n        tokens += messageTokens;\n    }\n\n    if (messages[0]?.role == 'system') filteredMessages.unshift(messages[0]);\n\n    return filteredMessages;\n}\n\n//TODO : update this implementation to use ConversationManager\n//        This will allow better context management and support for tool calls\nexport default class LLMAssistant extends Component {\n    protected configSchema = Joi.object({\n        model: Joi.string().max(200).required(),\n        behavior: Joi.string().max(30000).allow('').label('Behavior'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            logger.debug('== LLM Assistant Log ==\\n');\n\n            const model: string = config.data.model || 'echo';\n            const ttl = config.data.ttl || undefined;\n            const llmHelper: LLMHelper = LLMHelper.load(model);\n            // if the llm is undefined, then it means we removed the model from our system\n            if (!llmHelper.connector) {\n                return {\n                    _error: `The model '${model}' is not available. Please try a different one.`,\n                    _debug: logger.output,\n                };\n            }\n\n            logger.debug(` Model : ${model}`);\n\n            const userInput = input.UserInput;\n            const userId = input.UserId;\n            const conversationId = input.ConversationId;\n\n            let behavior = TemplateString(config.data.behavior).parse(input).result;\n            logger.debug(`[Parsed Behavior] \\n${behavior}\\n\\n`);\n\n            const modelInfo = llmHelper.modelInfo;\n            const maxTokens = modelInfo?.tokens ?? 2048;\n\n            const messages: any[] = await readMessagesFromSession(agent.id, userId, conversationId, Math.round(maxTokens / 2));\n\n            if (messages[0]?.role != 'system') messages.unshift({ role: 'system', content: behavior });\n            messages.push({ role: 'user', content: userInput });\n            //saveMessagesToSession(agent.id, userId, conversationId, messages);\n\n            const customParams = {\n                messages,\n            };\n\n            const response: any = await llmHelper.promptRequest(null, config, agent, customParams).catch((error) => ({ error: error }));\n\n            // in case we have the response but it's empty string, undefined or null\n            if (!response) {\n                return { _error: ' LLM Error = Empty Response!', _debug: logger.output };\n            }\n\n            if (response?.error) {\n                logger.error(` LLM Error=${JSON.stringify(response.error)}`);\n\n                return { Response: response?.data, _error: response?.error + ' ' + response?.details, _debug: logger.output };\n            }\n\n            messages.push({ role: 'assistant', content: response });\n            saveMessagesToSession(agent.id, userId, conversationId, messages, ttl);\n\n            const result = { Response: response };\n\n            result['_debug'] = logger.output;\n\n            return result;\n        } catch (error) {\n            return { _error: error.message, _debug: logger.output };\n        }\n    }\n}\n","import Component from './Component.class';\nimport APIEndpoint from './APIEndpoint.class';\nimport APIOutput from './APIOutput.class';\nimport PromptGenerator from './PromptGenerator.class';\nimport APICall from './APICall.class';\nimport VisionLLM from './VisionLLM.class';\nimport FSleep from './FSleep.class';\nimport FHash from './FHash.class';\nimport FEncDec from './FEncDec.class';\nimport FTimestamp from './FTimestamp.class';\nimport DataSourceLookup from './DataSourceLookup.class';\nimport DataSourceIndexer from './DataSourceIndexer.class';\nimport DataSourceCleaner from './DataSourceCleaner.class';\nimport JSONFilter from './JSONFilter.class';\nimport LogicAND from './LogicAND.class';\nimport LogicOR from './LogicOR.class';\nimport LogicXOR from './LogicXOR.class';\nimport LogicAtLeast from './LogicAtLeast.class';\nimport LogicAtMost from './LogicAtMost.class';\nimport AgentPlugin from './AgentPlugin.class';\nimport LLMAssistant from './LLMAssistant.class';\n\nconst components = {\n    Component: new Component(),\n    Note: new Component(), //this is a fake component\n    APIEndpoint: new APIEndpoint(),\n    APIOutput: new APIOutput(),\n    PromptGenerator: new PromptGenerator(),\n    LLMPrompt: new PromptGenerator(),\n    APICall: new APICall(),\n    VisionLLM: new VisionLLM(),\n    FSleep: new FSleep(),\n    FHash: new FHash(),\n    FEncDec: new FEncDec(),\n    // FSign: new FSign(), // TODO: Implement FSign\n    FTimestamp: new FTimestamp(),\n    DataSourceLookup: new DataSourceLookup(),\n    DataSourceIndexer: new DataSourceIndexer(),\n    DataSourceCleaner: new DataSourceCleaner(),\n    JSONFilter: new JSONFilter(),\n    LogicAND: new LogicAND(),\n    LogicOR: new LogicOR(),\n    LogicXOR: new LogicXOR(),\n    LogicAtLeast: new LogicAtLeast(),\n    LogicAtMost: new LogicAtMost(),\n    AgentPlugin: new AgentPlugin(),\n    LLMAssistant: new LLMAssistant(),\n};\n\nexport default components;\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\n\nexport default class FSleep extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const _error = undefined;\n            const delay = parseInt(config.data.delay || 1);\n            const Output = input.Input;\n            logger.debug(`Sleeping for ${delay} seconds`);\n            await new Promise((resolve) => setTimeout(resolve, delay * 1000));\n            return { Output, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error processing data \\n${_error}\\n`);\n            return { hash: undefined, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        }\n    }\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport crypto from 'crypto';\n\nexport default class FHash extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const _error = undefined;\n\n            const data = input.Data;\n            const algorithm = config.data.algorithm;\n            const encoding = config.data.encoding;\n            logger.debug(` Generating hash using ${algorithm} algorithm and ${encoding} encoding`);\n\n            const hashAlgo = crypto.createHash(algorithm);\n            hashAlgo.update(data);\n\n            const Hash = hashAlgo.digest(encoding);\n            logger.debug(` Generated hash: ${Hash}`);\n            return { Hash, _error, _debug: logger.output };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error generating hash \\n${_error}\\n`);\n            return { hash: undefined, _error, _debug: logger.output };\n        }\n    }\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\n\nexport default class FEncDec extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const _error = undefined;\n\n            const data = input.Data;\n            const action = config.data.action || 'Encode';\n            const encoding = config.data.encoding;\n            logger.debug(`${encoding} ${action} data`);\n\n            const Output = action == 'Encode' ? Buffer.from(data).toString(encoding) : Buffer.from(data, encoding).toString('utf8');\n\n            return { Output, _error, _debug: logger.output };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error processing data \\n${_error}\\n`);\n            return { hash: undefined, _error, _debug: logger.output };\n        }\n    }\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\n\nexport default class FTimestamp extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const _error = undefined;\n            const format = config.data.format; //TODO set timestamp format\n            const Timestamp = Date.now();\n            logger.debug(`Timestamp : ${Timestamp}`);\n\n            return { Timestamp, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error processing data \\n${_error}\\n`);\n            return { hash: undefined, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        }\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport Joi from 'joi';\nimport { validateCharacterSet } from '../utils';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { SmythFS } from '@sre/IO/Storage.service/SmythFS.class';\nimport { JSONContent, JSONContentHelper } from '@sre/helpers/JsonContent.helper';\nimport { IStorageVectorDataSource } from '@sre/types/VectorDB.types';\n\nexport default class DataSourceCleaner extends Component {\n    protected configSchema = Joi.object({\n        namespaceId: Joi.string().max(50).allow('').label('namespace'),\n        id: Joi.string().custom(validateCharacterSet, 'custom validation characterSet').allow('').label('source identifier'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const teamId = agent.teamId;\n        const agentId = agent.id;\n        let debugOutput = agent.agentRuntime?.debug ? '== Source Indexer Log ==\\n' : null;\n\n        try {\n            const configSchema = this.validateConfigData(config.data);\n            if (configSchema.error) {\n                throw new Error(`Config data validation error: ${configSchema.error}\\n EXITING...`);\n            }\n\n            const outputs = {};\n            for (let con of config.outputs) {\n                if (con.default) continue;\n                outputs[con.name] = con?.description ? `<${con?.description}>` : '';\n            }\n\n            const inputSchema = this.validateInput(input);\n            if (inputSchema.error) {\n                throw new Error(`Input validation error: ${inputSchema.error}\\n EXITING...`);\n            }\n\n            const namespaceId = configSchema.value.namespaceId;\n            const providedId = TemplateString(config.data.id).parse(input).result;\n            const idRegex = /^[a-zA-Z0-9\\-\\_\\.]+$/;\n            if (!idRegex.test(providedId)) {\n                throw new Error(`Invalid id. Accepted characters: 'a-z', 'A-Z', '0-9', '-', '_', '.'`);\n            }\n            debugOutput += `Searching for data source with id: ${providedId}\\n`;\n\n            const dsId = this.generateContextUID(providedId, teamId, namespaceId);\n\n            // await this.deleteRecord(dsId, token);\n\n            // const vectorDB = ConnectorService.getVectorDBConnector();\n            // await vectorDB.user(AccessCandidate.team(teamId)).delete(namespaceId, providedId);\n            const dsUrl = `smythfs://${teamId}.team/_datasources/${dsId}.json`;\n\n            const dataBuffer = await SmythFS.Instance.read(dsUrl, AccessCandidate.team(teamId));\n            const data = JSONContentHelper.create(dataBuffer.toString()).tryParse() as IStorageVectorDataSource;\n\n            if (!data) {\n                throw new Error(`Data source not found with id: ${providedId}`);\n            }\n\n            const vectorDB = ConnectorService.getVectorDBConnector();\n            await vectorDB.user(AccessCandidate.team(teamId)).delete(namespaceId, data.embeddingIds || []);\n\n            // after successfully deleting the embeddings, delete the datasource\n            await SmythFS.Instance.delete(dsUrl, AccessCandidate.team(teamId));\n\n            debugOutput += `Deleted data source with id: ${providedId}\\n`;\n\n            return {\n                _debug: debugOutput,\n                Success: true,\n                // _error,\n            };\n        } catch (err: any) {\n            debugOutput += `Failed to delete data source: \\n Error: ${err?.message}\\n`;\n\n            return {\n                _debug: debugOutput,\n                _error: err?.message || \"Couldn't delete data source\",\n            };\n        }\n    }\n\n    private generateContextUID(providedId: string, teamId: string, namespaceId: string) {\n        return `${teamId}::${namespaceId}::${providedId}`;\n    }\n\n    validateInput(input: any) {\n        return Joi.object({}).unknown(true).validate(input);\n    }\n\n    validateConfigData(data: any) {\n        return Joi.object({\n            namespaceId: Joi.string().required(),\n            id: Joi.string().optional().allow('').allow(null),\n        })\n            .unknown(true)\n            .validate(data);\n    }\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class JSONFilter extends Component {\n    protected configSchema = Joi.object({\n        fields: Joi.string().max(30000).allow('').label('Prompt'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n        logger.debug(`=== JSONFilter Log ===`);\n        let Output = {};\n        let _error = null;\n        try {\n            const componentId = config.id;\n            const fields = config.data.fields;\n            const obj = input.Input;\n\n            Output = filterFields(obj, fields);\n            logger.debug(`Output filtered`);\n        } catch (error: any) {\n            _error = error;\n            logger.error(` JSONFilter Error \\n ${error.toString()}`);\n        }\n        return { Output, _error, _debug: logger.output };\n    }\n}\n\nfunction filterFields(obj, fields) {\n    const fieldList = fields?.split(',').map((field) => field.trim());\n\n    function filterObject(obj) {\n        if (Array.isArray(obj)) {\n            return obj.map(filterObject);\n        } else if (obj !== null && typeof obj === 'object') {\n            return Object.keys(obj)\n                .filter((key) => fieldList.includes(key))\n                .reduce((acc, key) => {\n                    acc[key] = filterObject(obj[key]);\n                    return acc;\n                }, {});\n        }\n        return obj;\n    }\n\n    return filterObject(obj);\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicAND extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        const result: any = { Output: true };\n\n        for (let cfgInput of config.inputs) {\n            // check if all inputs are set (expected inputs are in \"config.inputs\" actual inputs are in \"input\")\n            if (!input[cfgInput.name]) {\n                result.Output = undefined;\n                break;\n            }\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n        return result;\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicOR extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const result: any = { Output: undefined };\n        console.log(input);\n        console.log(config);\n        for (let cfgInput of config.inputs) {\n            // check if one of the inputs are set (expected inputs are in \"config.inputs\" actual inputs are in \"input\")\n            if (input[cfgInput.name]) {\n                result.Output = true;\n                break;\n            }\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n\n        return result;\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicXOR extends Component {\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const result: any = { Output: undefined };\n        let trueCount = 0;\n\n        for (let cfgInput of config.inputs) {\n            // counts the number of set inputs\n            if (input[cfgInput.name]) {\n                trueCount++;\n            }\n        }\n        // checks if only one input is set, to trigger output\n        if (trueCount === 1) {\n            result.Output = true;\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n\n        return result;\n    }\n}\n","import Agent from './Agent.class';\nimport { AgentCallLog } from '@sre/types/AgentLogger.types';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { uid } from '@sre/utils';\n\nconst console = Logger('AgentLogger');\n\nexport default class AgentLogger {\n    private static transactions: any = {};\n    constructor(private agent: Agent) {}\n    public static async cleanup() {\n        const trIds = Object.keys(AgentLogger.transactions);\n        for (const trId of trIds) {\n            const transaction = AgentLogger.transactions[trId];\n            if (transaction.canDelete()) {\n                delete AgentLogger.transactions[trId];\n            }\n        }\n    }\n    public static log(agent, trId, logData: AgentCallLog) {\n        if (!trId) trId = 'log-' + uid();\n        return trId;\n    }\n    public static async logTask(agent: Agent, tasks) {}\n}\n","import EventEmitter from 'events';\nimport fs from 'fs';\nimport path from 'path';\nimport config from '@sre/config';\nimport { delay, uid } from '@sre/utils';\nimport AgentRuntime from '@sre/AgentManager/AgentRuntime.class';\nimport { Logger } from '@sre/helpers/Log.helper';\n\nconst console = Logger('RuntimeContext');\n\ntype TRuntimeData = {\n    input?: { [key: string]: any };\n    _LoopData?: any;\n};\ntype TComponentContext = {\n    active: boolean;\n    name: string;\n    runtimeData?: TRuntimeData;\n    step: number;\n    input?: { [key: string]: any };\n    output?: { [key: string]: any };\n};\nexport class RuntimeContext extends EventEmitter {\n    public circularLimitReached: string | boolean = false;\n    public step: number = 0;\n    public sessionResult: boolean = false;\n    public sessionResults: any;\n    public components: { [id: string]: { ctx: TComponentContext } } = {};\n\n    public checkRuntimeContext: any = null;\n\n    private ctxFile: string = '';\n    private _runtimeFileReady: any;\n\n    constructor(private runtime: AgentRuntime) {\n        super();\n        const agent = runtime.agent;\n        const dbgFolder = path.join(<string>config.env.DATA_PATH, `/debug/${agent.id}/`);\n        if (!fs.existsSync(dbgFolder)) {\n            fs.mkdirSync(dbgFolder, { recursive: true });\n        }\n\n        const processRootID = runtime.processID?.split(':')[0] || '';\n        const reqId = processRootID == runtime.xDebugId ? '' : '.' + uid() + runtime.reqTag;\n        this.ctxFile = path.join(dbgFolder, `${runtime.xDebugId}${reqId}${agent.jobID ? `-job-${agent.jobID}` : ''}.json`);\n\n        this.initRuntimeContext();\n    }\n\n    private serialize() {\n        const data = {\n            step: this.step,\n            sessionResult: this.sessionResult,\n            sessionResults: this.sessionResults,\n            components: this.components,\n        };\n\n        return data;\n    }\n    private deserialize(data: any) {\n        this.step = data.step;\n        this.sessionResult = data.sessionResult;\n        this.sessionResults = data.sessionResults;\n        this.components = data.components;\n    }\n    private reset() {\n        this.step = 0;\n        this.sessionResult = false;\n        this.sessionResults = null;\n        this.components = {};\n    }\n\n    private initRuntimeContext() {\n        if (this._runtimeFileReady) return;\n\n        const endpointDBGCall = this.runtime.xDebugId?.startsWith('dbg-'); //weak check for debug session, we need to improve this\n        console.debug('Init ctxFile', this.ctxFile);\n        const agent = this.runtime.agent;\n        let method = (agent.agentRequest.method || 'POST').toUpperCase();\n        const endpoint = agent.endpoints?.[agent.agentRequest.path]?.[method];\n\n        let ctxData: any = {};\n        if (!fs.existsSync(this.ctxFile)) {\n            ctxData = JSON.parse(JSON.stringify({ components: agent.components, connections: agent.connections, timestamp: Date.now() }));\n            if (!ctxData.step) ctxData.step = 0;\n            for (let cptId in ctxData.components) {\n                ctxData.components[cptId] = {\n                    id: cptId,\n                    name: ctxData.components[cptId].name,\n                    //dbg: { active: false, name: ctxData.components[cptId].name },\n                    ctx: { active: false, name: ctxData.components[cptId].name },\n                };\n\n                const cpt = ctxData.components[cptId];\n                //if this debug session was initiated from an endpoint, we mark the endpoint component as active\n                if (endpoint && endpoint.id != undefined && cpt.id == endpoint.id && endpointDBGCall) {\n                    //cpt.dbg.active = true;\n                    cpt.ctx.active = true;\n                }\n            }\n            fs.writeFileSync(this.ctxFile, JSON.stringify(ctxData, null, 2));\n        } else {\n            ctxData = JSON.parse(fs.readFileSync(this.ctxFile, 'utf8'));\n            if (!ctxData.step) ctxData.step = 0;\n        }\n\n        this.deserialize(ctxData);\n        this._runtimeFileReady = true;\n        this.emit('ready');\n    }\n    public async sync() {\n        if (!this.ctxFile) return;\n        this.emit('syncing');\n\n        const deleteSession = this.runtime.sessionClosed;\n\n        if (deleteSession) {\n            if (this.runtime.debug && fs.existsSync(this.ctxFile)) await delay(1000 * 60); //if we're in debug mode, we keep the file for a while to allow final state read\n            if (fs.existsSync(this.ctxFile)) fs.unlinkSync(this.ctxFile);\n        } else {\n            const data = this.serialize();\n            if (data) fs.writeFileSync(this.ctxFile, JSON.stringify(data, null, 2));\n        }\n    }\n\n    public incStep() {\n        this.step++;\n        this.sync();\n    }\n\n    public updateComponent(componentId: string, data: any) {\n        const ctxData = this;\n        if (!ctxData) return;\n        const component = ctxData.components[componentId];\n\n        if (!component) {\n            console.log('>>>>>>> updateComponent Component debug data not found', componentId, component);\n            console.log('>>> ctxFile', this.ctxFile);\n            console.log('>>> ctxData', ctxData);\n        }\n        component.ctx = { ...component.ctx, ...data, step: this.step };\n\n        //if (this.debug) component.dbg = { ...component.dbg, ...data };\n\n        this.sync();\n    }\n    public resetComponent(componentId: string) {\n        const ctxData = this;\n        const component = ctxData.components[componentId];\n        if (!component) {\n            console.log('>>>>>>> resetComponent Component debug data not found', componentId, component);\n            console.log('>>> ctxFile', this.ctxFile);\n            console.log('>>> ctxData', ctxData);\n        }\n        //component.dbg.active = false;\n        //component.dbg.runtimeData = {};\n        component.ctx.runtimeData = {};\n        component.ctx.active = false;\n\n        this.sync();\n    }\n\n    public getComponentData(componentId: string) {\n        const ctxData = this;\n        if (!ctxData) return null;\n        const component = ctxData.components[componentId];\n        if (!component) {\n            console.log('>>>>>>> getComponentData Component debug data not found', componentId, component);\n            console.log('>>> ctxFile', this.ctxFile);\n            console.log('>>> ctxData', ctxData);\n        }\n        //const data = this.debug ? component.dbg : component.ctx;\n        const data = component.ctx;\n\n        return data;\n    }\n}\n","import fs from 'fs';\nimport path from 'path';\nimport Agent from './Agent.class';\nimport Component from '@sre/Components/Component.class';\nimport componentInstance from '@sre/Components/index';\n\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { uid } from '@sre/utils';\nimport { RuntimeContext } from '@sre/MemoryManager/RuntimeContext';\n\nconst console = Logger('AgentRuntime');\nconst AgentRuntimeUnavailable = new Proxy(\n    {},\n    {\n        get: function (target, prop, receiver) {\n            // Check if the property being accessed is a function\n            if (typeof target[prop] === 'function') {\n                return target[prop];\n            } else {\n                // Return a function that logs \"unavailable\"\n                return function () {\n                    console.warn(`AgentRuntime Unavailable tried to call : ${prop.toString()}`);\n                };\n            }\n        },\n    }\n);\nexport default class AgentRuntime {\n    private static processResults: any = {};\n    private static tagsData = {};\n    public static dummy = AgentRuntimeUnavailable;\n\n    private agentContext: RuntimeContext;\n    //private ctxFile: string = '';\n    private xDebugRun: string | undefined = '';\n    private xDebugInject: string | undefined = '';\n    private xDebugRead: string | undefined = '';\n    private xDebugStop: string | undefined = '';\n    private xDebugPendingInject: any = null;\n    public xDebugId: string | undefined = '';\n    private xDebugCmd: string | undefined = '';\n    private _debugActive = false;\n    private _runtimeFileReady = false;\n    public sessionClosed = false;\n\n    private reqTagOwner = false;\n\n    //reqTag is used to identify the current running workflow including nested calls, it allows us to identify circular calls\n    public reqTag: any;\n    public processID: any; //this identifies the current processID, a process ID is the full set of runCycles that is executed by the agent.\n    public workflowReqId: any; //this identifies the current running workflow. a workflow starts when and agent endpoint is called, or a debug session is initiated, and ends when no more steps can be executed.\n\n    public alwaysActiveComponents: any = {};\n    public exclusiveComponents: any = {};\n\n    private checkRuntimeContext: any = null;\n\n    public get circularLimitReached() {\n        return this.agentContext?.circularLimitReached || false;\n    }\n    public set circularLimitReached(value) {\n        if (this.agentContext) this.agentContext.circularLimitReached = value;\n    }\n\n    public get debug() {\n        return this._debugActive;\n    }\n    public get curStep() {\n        return this.agentContext?.step || 0;\n    }\n\n    constructor(public agent: Agent) {\n        this.reqTag = agent.agentRequest.header('X-REQUEST-TAG');\n        const isNestedProcess: boolean = !!this.reqTag;\n\n        if (!this.reqTag) {\n            //tagged request should not be run in debug mode, this comes from a parent agent\n            this.xDebugStop = agent.agentRequest.header('X-DEBUG-STOP');\n            this.xDebugRun = agent.agentRequest.header('X-DEBUG-RUN'); //send this as header to create a session and attach it\n            this.xDebugInject = agent.agentRequest.header('X-DEBUG-INJ');\n            this.xDebugRead = agent.agentRequest.header('X-DEBUG-READ');\n            this.reqTag = 'xTAG-' + uid(); //if request tag is not set, set a new value, this will be used to tag nested agent calls\n            this.reqTagOwner = true;\n        } else {\n            this.xDebugStop = undefined;\n            this.xDebugRun = undefined;\n            this.xDebugInject = undefined;\n            this.xDebugRead = undefined;\n        }\n\n        this.xDebugId = this.xDebugStop || this.xDebugRun || this.xDebugRead;\n\n        //if (req.body) {\n        if (!this.xDebugId && agent.agentRequest.body) {\n            if (this.xDebugInject != undefined && this.xDebugInject != null) {\n                this.xDebugPendingInject = agent.agentRequest.body;\n                this.xDebugRun = this.xDebugInject || 'inj-' + uid();\n            } else {\n                if (this.xDebugRun == '') {\n                    this.xDebugRun = 'dbg-' + uid(); //generate a random debug id\n                }\n            }\n            this.xDebugId = this.xDebugRun;\n        }\n\n        this.processID = this.xDebugId;\n\n        if (!this.xDebugId) {\n            //if it's not a debug session, processID is unique per request\n            this.xDebugId = agent.sessionId;\n            this.processID = this.reqTag;\n        }\n        if (isNestedProcess) {\n            // Need to make processID unique to run same sub-agents multiple times in parallel\n            this.processID += `:${Math.floor(1000 + Math.random() * 9000)}`;\n        }\n\n        //we need a way to identify current running workflow in a unique way\n        //=> In debug mode, xDebugRun holds the debug sessionID which is unique per workflow run\n        //   if the debug session is stopped, xDebugStop holds the sessionID\n        //   Note : We can't use reqTag in debug mode because it changes every time a new debug step is executed\n        //\n        //=> In normal mode, reqTag is unique per workflow run\n        this.workflowReqId = this.xDebugRun || this.xDebugStop || this.reqTag;\n\n        //tagsData can be updated from external integrations (eg. Chatbot, API Endpoint, etc.)\n        if (!AgentRuntime.tagsData[this.reqTag]) AgentRuntime.tagsData[this.reqTag] = {};\n        if (!AgentRuntime.processResults[this.processID])\n            AgentRuntime.processResults[this.processID] = {\n                timestamp: Date.now(),\n                errorResults: [],\n                sessionResults: [],\n            };\n\n        this.agentContext = new RuntimeContext(this);\n        this.agentContext.on('ready', () => {\n            this.alwaysActiveComponents = {};\n            this.exclusiveComponents = {};\n            for (let component of this.agent.data.components) {\n                const cpt: Component = componentInstance[component.name];\n                if (!cpt) {\n                    console.warn(`Component ${component.name} Exists in agent but has no implementation`);\n                    continue;\n                }\n\n                if (cpt.alwaysActive) {\n                    this.alwaysActiveComponents[component.id] = cpt;\n                    this.updateComponent(component.id, { active: true, alwaysActive: true });\n                    const runtimeData = { ...this.getRuntimeData(component.id) };\n                    this.saveRuntimeComponentData(component.id, runtimeData);\n                }\n                if (cpt.exclusive) {\n                    this.exclusiveComponents[component.id] = cpt;\n                    this.updateComponent(component.id, { exclusive: true });\n                    const runtimeData = { ...this.getRuntimeData(component.id) };\n                    this.saveRuntimeComponentData(component.id, runtimeData);\n                }\n            }\n        });\n\n        //if xDebugId is equal to agent session, it means that the debugging features are not active\n        this._debugActive = this.xDebugId != agent.sessionId;\n\n        //console.debug(`New Agent Runtime initialized for agentId=${this.agent.id}  tag=${this.reqTag} debug file=${this.ctxFile}`);\n    }\n\n    public destroy() {\n        this.sessionClosed = true;\n        this.sync();\n    }\n\n    public incTag(componentId) {\n        if (!AgentRuntime.tagsData[this.reqTag][componentId]) AgentRuntime.tagsData[this.reqTag][componentId] = 0;\n        AgentRuntime.tagsData[this.reqTag][componentId]++;\n\n        // console.log(\n        //     `incTag agentId=${this.agent.id} componentId=${componentId} tag=${this.reqTag} ==> ${AgentRuntime.tagsData[this.reqTag][componentId]}`,\n        // );\n        //console.log('incTag tagsData', tagsData);\n    }\n\n    public async sync() {\n        //if (!this.ctxFile) return;\n\n        const deleteTag = (this.reqTagOwner && this.sessionClosed) || this.circularLimitReached;\n        if (deleteTag) {\n            console.log('>>>>>>>>>>>> deleting tagsData', this.reqTag);\n            delete AgentRuntime.tagsData[this.reqTag];\n        }\n\n        this.agentContext.sync();\n    }\n    public getWaitingComponents() {\n        const ctxData = this.agentContext;\n        const dbgComponents: any = Object.values(ctxData?.components || []).filter((c: any) => c?.ctx?.active == true);\n        const waitingComponents: any = dbgComponents.filter((c: any) => c?.ctx?.status && typeof c?.ctx?.output !== undefined);\n        return waitingComponents;\n    }\n    public getExclusiveActiveComponents() {\n        const ctxData = this.agentContext;\n        const dbgComponents: any = Object.values(ctxData?.components || []).filter((c: any) => c?.ctx?.active == true);\n        const exclusiveActiveComponents: any = dbgComponents.filter((c: any) => c?.ctx?.exclusive == true);\n        return exclusiveActiveComponents;\n    }\n    public readState(stateId: string, deltaOnly = false) {\n        //if (!this._debugActive || !this.xDebugRead) return null;\n        if (!this._debugActive || !stateId) return null;\n\n        //this.checkRuntimeContext();\n        const runtime = this;\n        const agent = this.agent;\n\n        const ctxData = runtime.agentContext;\n        const dbgAllComponents: any = runtime.xDebugPendingInject || Object.values(ctxData?.components || []);\n\n        //first try to find exclusive active components\n        let dbgActiveComponents: any;\n        dbgActiveComponents = dbgAllComponents.filter((c: any) => c?.ctx?.active == true && c?.ctx?.exclusive == true);\n        //if no exclusive active components, find all active components\n        if (!dbgActiveComponents || dbgActiveComponents.length == 0)\n            dbgActiveComponents = dbgAllComponents.filter(\n                (c: any) =>\n                    c?.ctx?.active == true ||\n                    (!c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0)\n            );\n        //find waiting components that was not previously run\n        const dbgActiveWaitingComponents: any = dbgAllComponents.filter(\n            (c: any) => c?.ctx?.active == true && c?.ctx?.status && typeof c?.ctx?.output !== undefined\n        );\n\n        const dbgActiveReadyComponents: any = dbgAllComponents.filter((c: any) => c?.ctx?.active == true && !c?.ctx?.status);\n\n        let state = {};\n        for (let dbgComponent of dbgAllComponents) {\n            state[dbgComponent.id] = dbgComponent.ctx;\n        }\n\n        //let dbgSession: any = runtime.xDebugRead;\n        let dbgSession: any = stateId;\n\n        // let alwaysActiveComponents = 0;\n        // for (let activeCpt of dbgActiveComponents) {\n        //     if (this.agent.alwaysActiveComponents[activeCpt.id]) alwaysActiveComponents++;\n        // }\n\n        if (!dbgActiveComponents || dbgActiveComponents.length == 0 /*|| dbgActiveComponents.length == alwaysActiveComponents*/) {\n            dbgSession = null;\n            runtime.sessionClosed = true;\n        }\n\n        const remainingActiveComponents: any = Object.values(ctxData?.components || []).filter(\n            (c: any) => c?.ctx?.active == true && !c?.ctx?.alwaysActive\n        );\n        const activeAsyncComponents: any = Object.values(ctxData?.components || []).filter(\n            (c: any) => !c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0\n        );\n\n        if (remainingActiveComponents.length == 0 && activeAsyncComponents.length == 0 /*&& awaitingInputs.length == 0*/) {\n            runtime.sessionClosed = true;\n        }\n\n        if (runtime.circularLimitReached) {\n            const circularLimitData = runtime.checkCircularLimit();\n            const error = `Circular Calls Limit Reached on ${circularLimitData}. Current agent circular limit is ${agent.circularLimit}`;\n            runtime.sessionClosed = true;\n            return { state, dbgSession, sessionClosed: runtime.sessionClosed, error };\n        }\n\n        const step = this.curStep >= 1 ? this.curStep - 1 : 0; //current state was executed in previous step\n\n        if (deltaOnly) {\n            const delta = {};\n            for (let cptId in state) {\n                const cpt = state[cptId];\n\n                //workaround, here we are supposed to test component steps that are equalt to current step\n                //but due to an inconsistency, the Async component has sometimes a step greater than the current step\n                if (cpt.step >= step) delta[cptId] = cpt;\n                //FIXME : identify the root cause of this issue and replace >= with ==\n            }\n            //return { state: delta, dbgSession, sessionClosed: runtime.sessionClosed, step };\n            state = delta;\n        }\n\n        return { state, dbgSession, sessionClosed: runtime.sessionClosed, step };\n    }\n\n    /**\n     * This method is called by the agent to run a process cycle, it will run all active components and return the results\n     * The function is called multiple times until all components are executed and no more active components are available\n     * @returns\n     */\n    public async runCycle() {\n        console.debug(\n            `runCycle agentId=${this.agent.id} wfReqId=${this.workflowReqId}  reqTag=${this.reqTag} session=${this.xDebugRun} cycleId=${this.processID}`\n        );\n        //this.checkRuntimeContext();\n\n        const runtime = this;\n        const agent = this.agent;\n        const ctxData = runtime.agentContext;\n        const dbgAllComponents: any = runtime.xDebugPendingInject || Object.values(ctxData?.components || []);\n\n        //first try to find exclusive active components\n        let dbgActiveComponents: any;\n        dbgActiveComponents = dbgAllComponents.filter((c: any) => c?.ctx?.active == true && c?.ctx?.exclusive == true);\n        //if no exclusive active components, find all active components\n        if (!dbgActiveComponents || dbgActiveComponents.length == 0)\n            dbgActiveComponents = dbgAllComponents.filter(\n                (c: any) =>\n                    c?.ctx?.active == true ||\n                    (!c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0)\n            );\n        //find waiting components that was not previously run\n        const dbgActiveWaitingComponents: any = dbgAllComponents.filter(\n            (c: any) => c?.ctx?.active == true && c?.ctx?.status && typeof c?.ctx?.output !== undefined\n        );\n        const dbgActiveReadyComponents: any = dbgAllComponents.filter(\n            (c: any) =>\n                (c?.ctx?.active == true && !c?.ctx?.status) ||\n                (!c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0)\n        );\n        //const dbgActiveReadyComponents: any = dbgActiveComponents.filter((c: any) => c?.ctx?.active == true && !c?.ctx?.status);\n\n        let step: any;\n\n        if (!dbgActiveComponents || dbgActiveComponents.length == 0) {\n            runtime.sessionClosed = true;\n            step = {\n                state: { sessionClosed: true },\n                dbgSession: null,\n                //expiredDbgSession: runtime.xDebugRun || runtime.xDebugStop,\n                expiredDbgSession: runtime.xDebugId,\n                sessionClosed: true,\n            };\n        }\n\n        if (!step && dbgActiveComponents.length == dbgActiveWaitingComponents.length && ctxData.sessionResult) {\n            runtime.sessionClosed = true;\n            step = {\n                state: { sessionClosed: true },\n                dbgSession: null,\n                //expiredDbgSession: runtime.xDebugRun,\n                expiredDbgSession: runtime.xDebugId,\n                sessionClosed: true,\n            };\n        }\n        if (!step && dbgActiveReadyComponents.length > 0) {\n            const promises: any = [];\n\n            for (let dbgComponent of dbgActiveReadyComponents) {\n                const injectInput = runtime.xDebugPendingInject ? dbgComponent.ctx.input : undefined;\n                promises.push(agent.callComponent(dbgComponent.ctx.sourceId, dbgComponent.id, injectInput));\n            }\n            const dbgResults = await Promise.all(promises);\n            const state = dbgResults.length == 1 ? dbgResults[0] : dbgResults;\n\n            runtime.xDebugPendingInject = null;\n\n            const remainingActiveComponents: any = Object.values(ctxData?.components || []).filter((c: any) => c?.ctx?.active == true);\n            const activeAsyncComponents: any = Object.values(ctxData?.components || []).filter(\n                (c: any) => !c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0\n            );\n            const dbgActiveWaitingComponents: any = dbgAllComponents.filter((c: any) => c?.ctx?.status && typeof c?.ctx?.output !== undefined);\n\n            if (dbgActiveWaitingComponents.length == remainingActiveComponents.length) {\n                ctxData.sessionResult = true;\n            }\n\n            //capture results\n            let sessionResults = dbgResults.flat().filter(\n                (e) =>\n                    e.id &&\n                    e.result &&\n                    !e.result._missing_inputs &&\n                    //check if this is the last component in the chain\n                    !agent.connections.find((c) => c.sourceId == e.id)\n            );\n\n            let errorResults = dbgResults.flat().filter((e) => e.id && (e.error || e.result?._error));\n            if (ctxData.sessionResult && sessionResults.length == 0 && runtime.sessionClosed) {\n                //no result ? check if we have errors\n                sessionResults = errorResults;\n            }\n\n            ctxData.sessionResults = sessionResults;\n            step = {\n                state,\n                dbgSession: runtime.xDebugRun,\n                sessionResult: runtime.agentContext.sessionResult,\n                sessionResults: runtime.agentContext.sessionResults,\n                errorResults,\n                sessionClosed: remainingActiveComponents.length == 0 && activeAsyncComponents.length == 0 /*&& awaitingInputs.length == 0*/,\n            };\n        } else {\n            runtime.sessionClosed = true;\n            //return { sessionClosed: true };\n            step = {\n                state: { sessionClosed: true },\n                dbgSession: null,\n                //expiredDbgSession: runtime.xDebugRun || runtime.xDebugStop,\n                expiredDbgSession: runtime.xDebugId,\n                sessionClosed: true,\n            };\n        }\n\n        this.checkCircularLimit();\n        if (step.sessionResults) {\n            AgentRuntime.processResults[this.processID].sessionResults.push(step.sessionResults);\n        }\n        if (step.errorResults) {\n            AgentRuntime.processResults[this.processID].errorResults.push(step.errorResults);\n        }\n\n        if (step?.sessionClosed || this.circularLimitReached) {\n            const finalResult = this.processResults();\n            step.finalResult = finalResult;\n            runtime.sessionClosed = true;\n        }\n\n        this.incStep();\n        this.sync();\n        return step;\n    }\n\n    private processResults() {\n        //this.checkCircularLimit();\n        let result: any = { error: 'Error processing results' };\n        const sessionResults = AgentRuntime.processResults[this.processID].sessionResults;\n        const errorResults = AgentRuntime.processResults[this.processID].errorResults;\n        if (this.circularLimitReached) {\n            const circularLimitData = this.circularLimitReached;\n            result = { error: `Circular Calls Limit Reached on ${circularLimitData}. Current circular limit is ${this.agent.circularLimit}` };\n        } else {\n            let state = [sessionResults, errorResults].flat(Infinity);\n            if (!state || state.length == 0) state = errorResults.flat(Infinity);\n\n            //post process run cycle results\n            //deduplicating redundant entries\n\n            const data = state\n                .reduce(\n                    (acc, current) => {\n                        if (!acc.seen[current.id]) {\n                            acc.result.push(current);\n                            acc.seen[current.id] = true;\n                        }\n                        return acc;\n                    },\n                    { seen: {}, result: [] }\n                )\n                .result.filter((e) => !e.result?._exclude);\n\n            //data.forEach((d: any) => delete d?.result?._debug);\n\n            result = data;\n            /////////////\n        }\n\n        //cleanup\n        delete AgentRuntime.processResults[this.processID];\n\n        this.sync();\n        return result;\n    }\n\n    public checkCircularLimit() {\n        if (this.circularLimitReached) return this.agentContext.circularLimitReached;\n        for (let componentId in AgentRuntime.tagsData[this.reqTag]) {\n            if (AgentRuntime.tagsData[this.reqTag][componentId] > this.agent.circularLimit) {\n                this.sessionClosed = true;\n                this.agentContext.circularLimitReached = componentId;\n                return componentId;\n            }\n        }\n        return false;\n    }\n\n    public async injectDebugOutput(componentId: string) {\n        if (this.xDebugPendingInject) {\n            const component = this.xDebugPendingInject.find((c: any) => c.id == componentId);\n            if (component?.ctx?.output) {\n                //if all outputs values are empty, we don't inject\n                let allEmpty = true;\n                for (let key in component.ctx.output) {\n                    if (component.ctx.output[key] != '') {\n                        allEmpty = false;\n                        break;\n                    }\n                }\n                if (allEmpty) return null;\n\n                return component.ctx.output;\n            }\n        }\n    }\n    public getRuntimeData(componentId) {\n        const componentData = this.getComponentData(componentId);\n        if (!componentData) return {};\n        const rData = componentData.runtimeData || {};\n\n        return rData;\n    }\n    public updateRuntimeData(componentId, data) {\n        const componentData = this.getComponentData(componentId);\n        if (!componentData) return;\n        componentData.runtimeData = { ...componentData.runtimeData, ...data };\n\n        this.sync();\n    }\n\n    public saveRuntimeComponentData(componentId, data) {\n        this.updateComponent(componentId, { runtimeData: data });\n    }\n\n    public incStep() {\n        this.agentContext.incStep();\n    }\n    public updateComponent(componentId: string, data: any) {\n        this.agentContext.updateComponent(componentId, data);\n    }\n\n    public resetComponent(componentId: string) {\n        this.agentContext.resetComponent(componentId);\n    }\n\n    public getComponentData(componentId: string) {\n        return this.agentContext.getComponentData(componentId);\n    }\n}\n","import os from 'os';\nimport process from 'process';\n\nconst OSResourceMonitor: any = {\n    mem: getMemoryUsage(),\n    //processMemory: getProcessMemoryUsage(),\n    cpu: getCpuUsage(),\n    //processCpu: getProcessCpuUsage(),\n};\nexport default OSResourceMonitor;\n\nfunction getCpuUsage() {\n    const cpus = os.cpus();\n    let user = 0;\n    let nice = 0;\n    let sys = 0;\n    let idle = 0;\n    let irq = 0;\n    let total = 0;\n\n    for (let cpu of cpus) {\n        user += cpu.times.user;\n        nice += cpu.times.nice;\n        sys += cpu.times.sys;\n        idle += cpu.times.idle;\n        irq += cpu.times.irq;\n    }\n\n    total = user + nice + sys + idle + irq;\n\n    return {\n        user: (user / total) * 100,\n        sys: (sys / total) * 100,\n        idle: (idle / total) * 100,\n        load: 100 - (idle / total) * 100,\n    };\n}\n\nfunction getMemoryUsage() {\n    const totalMemory = os.totalmem();\n    const freeMemory = os.freemem();\n    const usedMemory = totalMemory - freeMemory;\n\n    return {\n        totalMemory: (totalMemory / 1024 ** 3).toFixed(2) + ' GB',\n        freeMemory: (freeMemory / 1024 ** 3).toFixed(2) + ' GB',\n        usedMemory: (usedMemory / 1024 ** 3).toFixed(2) + ' GB',\n        memoryUsagePercentage: ((usedMemory / totalMemory) * 100).toFixed(2),\n    };\n}\n\nfunction getProcessMemoryUsage() {\n    const memoryUsage = process.memoryUsage();\n    return {\n        total: memoryUsage.rss,\n        heapTotal: (memoryUsage.heapTotal / 1024 ** 2).toFixed(2) + ' MB',\n        heapUsed: (memoryUsage.heapUsed / 1024 ** 2).toFixed(2) + ' MB',\n        external: (memoryUsage.external / 1024 ** 2).toFixed(2) + ' MB',\n    };\n}\n\nfunction getProcessCpuUsage() {\n    const cpuUsage = process.cpuUsage();\n    return {\n        user: cpuUsage.user,\n        system: cpuUsage.system,\n    };\n}\n\nfunction logSystemUsage() {\n    OSResourceMonitor.mem = getMemoryUsage();\n    OSResourceMonitor.cpu = getCpuUsage();\n    //OSResourceMonitor.processMemory = getProcessMemoryUsage();\n    //OSResourceMonitor.processCpu = getProcessCpuUsage();\n}\n\n//setInterval(logSystemUsage, 5000); // update every 5 seconds\n","import Component from '@sre/Components/Component.class';\nimport componentInstance from '@sre/Components/index';\nimport AgentLogger from './AgentLogger.class';\nimport AgentRequest from './AgentRequest.class';\nimport AgentRuntime from './AgentRuntime.class';\nimport AgentSettings from './AgentSettings.class';\nimport OSResourceMonitor from './OSResourceMonitor';\n\nimport config from '@sre/config';\nimport { delay, getCurrentFormattedDate, uid } from '@sre/utils/index';\n\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\nconst console = Logger('Agent');\nconst idPromise = (id) => id;\nexport default class Agent {\n    public name: any;\n    public data: any;\n    public teamId: any;\n    public components: any;\n    public connections: any;\n    public endpoints: any = {};\n    public sessionId;\n    public sessionTag = '';\n    public callerSessionId;\n    public apiBasePath = '/api';\n    public agentRuntime: AgentRuntime | any;\n\n    public usingTestDomain = false;\n    public domain = '';\n    public debugSessionEnabled = false;\n    public circularLimit = 100; //TODO : make it configurable from agent settings\n    public version = '';\n    //public baseUrl = '';\n    public agentVariables: any = {};\n    private _kill = false;\n    //public agentRequest: Request | AgentRequest | any;\n    public async = false;\n    public jobID = '';\n    public planInfo: any = {};\n\n    public agentRequest: AgentRequest;\n    constructor(\n        public id,\n        agentData,\n        public agentSettings: AgentSettings,\n        agentRequest?: AgentRequest | any //private req: express.Request,\n    ) {\n        //this.agentRequest = new AgentRequest(req);\n        const json = typeof agentData === 'string' ? JSON.parse(agentData) : agentData;\n        this.name = json.name;\n        this.data = json.data;\n        //this.agentVariables = json.data.variables || {};\n\n        this.version = this.data.agentVersion || ''; //when version is not set we load the latest dev version\n        this.teamId = json.teamId;\n        this.connections = this.data.connections;\n        this.debugSessionEnabled = this.data.debugSessionEnabled;\n\n        this.agentVariables = json.data.variables || {};\n\n        //parse vault agent variables\n        // if (typeof json.data.variables === 'object') {\n        //     for (let key in json.data.variables) {\n        //         const value = json.data.variables[key];\n        //         if (value.startsWith('{{') && value.endsWith('}}')) {\n        //             utils.parseKey(value, this.teamId).then((result) => {\n        //                 this.agentVariables[key] = result;\n        //             });\n        //         } else {\n        //             this.agentVariables[key] = value;\n        //         }\n        //     }\n        // }\n\n        // Base URL required to serve binary data\n        //this.baseUrl = `https://${id}.${config.env.AGENT_DOMAIN}`;\n        //if (config.env.AGENT_DOMAIN_PORT) this.baseUrl += `:${config.env.AGENT_DOMAIN_PORT}`;\n\n        const endpoints = this.data.components.filter((c) => c.name == 'APIEndpoint');\n        for (let endpoint of endpoints) {\n            let method = endpoint.data.method || 'POST';\n            method = method.toUpperCase();\n            if (!this.endpoints[`${this.apiBasePath}/${endpoint.data.endpoint}`])\n                this.endpoints[`${this.apiBasePath}/${endpoint.data.endpoint}`] = {};\n            this.endpoints[`${this.apiBasePath}/${endpoint.data.endpoint}`][method] = endpoint;\n        }\n\n        this.components = {};\n        for (let component of this.data.components) {\n            //FIXME : this does not persist in debug mode, it breaks key value mem logic\n\n            this.components[component.id] = component;\n        }\n\n        for (let connection of this.data.connections) {\n            const sourceComponent = this.components[connection.sourceId];\n            const targetComponent = this.components[connection.targetId];\n            const sourceIndex = connection.sourceIndex;\n            const targetIndex = connection.targetIndex;\n\n            if (!sourceComponent.outputs[sourceIndex].next) sourceComponent.outputs[sourceIndex].next = [];\n            sourceComponent.outputs[sourceIndex].next.push(targetComponent.id);\n\n            if (!targetComponent.inputs[targetIndex].prev) targetComponent.inputs[targetIndex].prev = [];\n            targetComponent.inputs[targetIndex].prev.push(sourceComponent.id);\n        }\n\n        this.tagAsyncComponents();\n\n        if (agentRequest) {\n            this.setRequest(agentRequest);\n        }\n\n        //this.settings = new AgentSettings(this.id);\n    }\n\n    public setRequest(agentRequest: AgentRequest | any) {\n        if (this.agentRequest) return;\n        this.agentRequest = agentRequest;\n        this.agentRequest = agentRequest;\n        const dateTime = getCurrentFormattedDate();\n        this.sessionId = 'rt-' + (this.agentRequest.sessionID || dateTime + '.' + uid());\n\n        const sessionTags = this?.agentRequest?.headers['x-session-tag'];\n        if (sessionTags) this.sessionTag += this.sessionTag ? `,${sessionTags}` : sessionTags;\n\n        var regex = new RegExp(`^\\/v[0-9]+(\\.[0-9]+)?${this.apiBasePath}\\/(.*)`);\n        if (this.agentRequest?.path?.startsWith(`${this.apiBasePath}/`) || this.agentRequest?.path?.match(regex)) {\n            //we only need runtime context for API calls\n            this.agentRuntime = new AgentRuntime(this);\n            this.callerSessionId =\n                this?.agentRequest?.headers['x-caller-session-id']?.substring(0, 256) || this.agentRuntime.workflowReqId || this.sessionId;\n        } else {\n            this.agentRuntime = AgentRuntime.dummy;\n        }\n    }\n\n    public kill() {\n        this._kill = true;\n    }\n    private async parseVariables() {\n        //parse vault agent variables\n        if (typeof this.agentVariables === 'object') {\n            for (let key in this.agentVariables) {\n                const value = this.agentVariables[key];\n                if (value.startsWith('{{') && value.endsWith('}}')) {\n                    //this.agentVariables[key] = (await parseKey(value, this.teamId)) || '';\n                    this.agentVariables[key] = await TemplateString(value).parseTeamKeys(this.teamId).asyncResult;\n                }\n            }\n        }\n    }\n\n    async process(endpointPath, input) {\n        //TODO: replace endpointPath + input params with a single agentRequest object. (This will require intensive regression testing)\n        let result: any;\n        let dbgSession: any = null;\n        let sessionClosed = false;\n\n        //this.agentRuntime.checkRuntimeContext();\n        //insert log\n        const logId = AgentLogger.log(this, null, {\n            sourceId: endpointPath,\n            componentId: `AGENT`,\n            domain: this.domain,\n            input,\n            workflowID: this.agentRuntime.workflowReqId,\n            processID: this.agentRuntime.processID,\n            inputTimestamp: new Date().toISOString(),\n            sessionID: this.callerSessionId,\n            tags: this.sessionTag,\n        });\n\n        const method = this.agentRequest.method.toUpperCase();\n        const endpoint = this.endpoints[endpointPath]?.[method];\n\n        //first check if this is a debug session, and return debug result if it's the case\n        if (this.agentRuntime.debug) {\n            if (!endpoint && this.agentRequest.path != '/api/') {\n                if (logId) AgentLogger.log(this, logId, { error: `Endpoint ${method} ${endpointPath} Not Found` });\n                throw new Error(`Endpoint ${method} ${endpointPath} Not Found`);\n            }\n            let dbgResult: any;\n            //let dbgResult: any = await this.agentRuntime.readState(true); //is this a debug read reqeust ?\n\n            if (!dbgResult) dbgResult = await this.agentRuntime.runCycle(); //no, is this a step over request ?\n\n            // result = dbgResult?.state;\n            // dbgSession = dbgResult?.dbgSession;\n            // sessionClosed = dbgResult?.sessionClosed;\n            if (dbgResult && typeof dbgResult?.state !== 'undefined') {\n                this.agentRuntime.sync();\n                if (dbgResult?.finalResult) {\n                    dbgResult.finalResult = await this.postProcess(dbgResult.finalResult).catch((error) => ({ error }));\n                }\n                return dbgResult;\n            }\n        }\n\n        if (!endpoint) {\n            if (logId) AgentLogger.log(this, logId, { error: `Endpoint ${method} ${endpointPath} Not Found` });\n            throw new Error(`Endpoint ${method} ${endpointPath} Not Found`);\n        }\n\n        this.agentRuntime.updateComponent(endpoint.id, { active: true, input, sourceId: null });\n\n        let step;\n        do {\n            step = await this.agentRuntime.runCycle();\n\n            //adjust latency based on cpu load\n            const qosLatency = Math.floor(OSResourceMonitor.cpu.load * this.planInfo?.maxLatency || 0);\n\n            await delay(30 + qosLatency);\n        } while (!step?.finalResult && !this._kill);\n\n        if (this._kill) {\n            console.warn(`Agent ${this.id} was killed`);\n            return { error: 'Agent killed' };\n        }\n        result = await this.postProcess(step?.finalResult).catch((error) => ({ error }));\n\n        //post process all results\n        if (this.agentRuntime.circularLimitReached) {\n            const circularLimitData = this.agentRuntime.circularLimitReached;\n            result = { error: `Circular Calls Limit Reached on ${circularLimitData}. Current circular limit is ${this.circularLimit}` };\n            throw new Error(`Circular Calls Limit Reached on ${circularLimitData}. Current circular limit is ${this.circularLimit}`);\n        }\n\n        if (logId) AgentLogger.log(this, logId, { outputTimestamp: '' + Date.now(), result });\n\n        this.updateTasksCount(); //Important, don't use await here, we need the call to be non blocking\n\n        //FIXME: does debug call ever reach this point ?\n        return this.agentRuntime.debug ? { state: result, dbgSession, sessionClosed } : result;\n    }\n\n    private async updateTasksCount() {\n        //tasks count update logic\n    }\n\n    public async postProcess(result) {\n        if (Array.isArray(result)) result = result.flat(Infinity);\n        if (!Array.isArray(result)) result = [result];\n\n        for (let i = 0; i < result.length; i++) {\n            const _result = result[i];\n            if (!_result) continue;\n            if (_result._debug) delete _result._debug;\n            if (_result._debug_time) delete _result._debug_time;\n            const _componentData = this.components[_result.id];\n            if (!_componentData) continue;\n            const _component: Component = componentInstance[_componentData.name];\n            if (!_component) continue;\n            //if (_component.hasPostProcess) {\n            const postProcessResult = await _component.postProcess(_result, _componentData, this).catch((error) => ({ error }));\n\n            result[i] = postProcessResult;\n            //}\n        }\n\n        if (result.length == 1) result = result[0];\n        return result;\n    }\n\n    // public saveRuntimeComponentData(componentId, data) {\n    //     //let runtimeData = { ...this.agentRuntime.getRuntimeData(componentId), ...data };\n    //     //this.agentRuntime.updateComponent(componentId, { runtimeData: data });\n\n    //     this.agentRuntime.saveRuntimeComponentData(componentId, data);\n    // }\n    // private getRuntimeData(componentId) {\n    //     // const componentData = this.agentRuntime.getComponentData(componentId);\n    //     // if (!componentData) return {};\n    //     // const rData = componentData.runtimeData || {};\n\n    //     return this.agentRuntime.getRuntimeData(componentId);\n    // }\n\n    // private clearRuntimeComponentData(componentId) {\n    //     this.agentRuntime.resetComponent(componentId);\n    // }\n\n    private hasLoopAncestor(inputEntry) {\n        if (!inputEntry.prev) return false;\n        for (let prevId of inputEntry.prev) {\n            const prevComponentData = this.components[prevId];\n            if (prevComponentData.name == 'ForEach') return true;\n\n            for (let inputEntry of prevComponentData.inputs) {\n                if (this.hasLoopAncestor(inputEntry)) return true;\n            }\n        }\n    }\n\n    private clearChildLoopRuntimeComponentData(componentId) {\n        const componentData = this.components[componentId];\n        const runtimeData = this.agentRuntime.getRuntimeData(componentId);\n        if (runtimeData._ChildLoopData) {\n            for (let inputEntry of componentData.inputs) {\n                if (this.hasLoopAncestor(inputEntry)) {\n                    delete runtimeData.input[inputEntry.name];\n                }\n            }\n        }\n    }\n    private getComponentMissingInputs(componentId, _input) {\n        let missingInputs: any = [];\n        const componentData = this.components[componentId];\n        const component: Component = componentInstance[componentData.name];\n        if (component.alwaysActive) return missingInputs;\n\n        const readablePredecessors = this.findReadablePredecessors(componentId);\n        const readableInputNames = {};\n        for (let pred of readablePredecessors) {\n            if (pred) {\n                readableInputNames[pred.input.name] = pred;\n            }\n        }\n        //readablePredecessors.map((e) => e.input.name);\n\n        const allInputIndexes = this.connections.filter((c) => c.targetId == componentId).map((e) => e.targetIndex);\n        const allInputs = componentData.inputs.filter((r) => allInputIndexes.includes(r.index));\n\n        if (Array.isArray(allInputs) && allInputs.length > 0) {\n            //if the next component has named inputs\n            for (let input of allInputs) {\n                if (input.optional) continue;\n                if (readableInputNames[input.name]) {\n                    const pred = readableInputNames[input.name];\n                    const component: Component = pred.component;\n                    const predComponentData = this.components[pred.id];\n                    const foundOutput = component.hasOutput(pred.output.name, predComponentData, this);\n                    if (foundOutput) continue; //if the input is readable, skip it, because we can read it's value when needed. Readable inputs are non blocking\n                }\n                if (typeof _input[input.name] == 'undefined' /* || _input[input.name] == null*/) {\n                    missingInputs.push(input.name);\n                }\n            }\n        }\n\n        return missingInputs;\n    }\n\n    public findReadablePredecessors(componentId) {\n        const componentData = this.components[componentId];\n        const component: Component = componentInstance[componentData.name];\n\n        const connections = this.connections.filter((c) => c.targetId == componentId);\n        const readablePredecessors = connections.map((c) => {\n            //this.components[c.sourceId])\n            const sourceComponentData = this.components[c.sourceId];\n            const sourceComponent: Component = componentInstance[sourceComponentData.name];\n            const output = sourceComponentData.outputs[c.sourceIndex];\n            const input = componentData.inputs[c.targetIndex];\n            if (sourceComponent.hasReadOutput) {\n                return { output, input, component: sourceComponent, id: c.sourceId };\n            }\n            return null;\n        });\n\n        return readablePredecessors.filter((e) => e != null);\n    }\n\n    /**\n     *\n     * @param sourceId\n     * @param componentId\n     */\n    private updateStep(sourceId, componentId) {\n        const agentRuntime = this.agentRuntime;\n        const step = agentRuntime.curStep;\n        const componentData = agentRuntime.getComponentData(componentId);\n\n        // if (!componentData.steps) componentData.steps = {};\n        // if (!componentData.steps[step]) componentData.steps[step] = { sources: [] };\n        // componentData.steps[step].sources.push(sourceId);\n\n        // if (!componentData.stepSources) componentData.stepSources = {};\n        // if (!componentData.stepSources[sourceId]) componentData.stepSources[sourceId] = [];\n        // componentData.stepSources[sourceId].push(step);\n\n        agentRuntime.updateComponent(componentId, { step });\n    }\n\n    async callComponent(sourceId, componentId, input?) {\n        const agentRuntime = this.agentRuntime;\n        const componentData = this.components[componentId];\n        const component: Component = componentInstance[componentData.name];\n\n        if (this._kill) {\n            console.warn(`Agent ${this.id} was killed, skipping component ${componentData.name}`);\n            return { id: componentData.id, name: componentData.displayName, result: null, error: 'Agent killed' };\n        }\n\n        if (!component) {\n            throw new Error(`Component ${componentData.name} not found`);\n        }\n\n        this.agentRuntime.incTag(componentId);\n        this.agentRuntime.checkCircularLimit();\n        if (this.agentRuntime.circularLimitReached) {\n            return { error: `Circular Calls Reached` };\n        }\n\n        const data = agentRuntime.getComponentData(componentId);\n        if (data?.output?._missing_inputs) {\n            agentRuntime.updateComponent(componentId, { output: {} });\n        }\n\n        const _input = this.prepareComponentInput(componentId, input);\n\n        //insert log\n        const logId = AgentLogger.log(this, null, {\n            sourceId: sourceId || 'AGENT',\n            componentId,\n            domain: this.domain,\n            workflowID: this.agentRuntime.workflowReqId,\n            processID: this.agentRuntime.processID,\n            input:\n                componentData.name == 'APIEndpoint' ? (this.agentRequest.method == 'GET' ? this.agentRequest.query : this.agentRequest.body) : _input,\n            inputTimestamp: new Date().toISOString(),\n            sessionID: this.callerSessionId,\n            tags: this.sessionTag,\n        });\n\n        let output: any = null;\n        let missingInputs: any = [];\n\n        //agentRuntime.updateComponent(componentId, { step: agentRuntime.curStep });\n        this.updateStep(sourceId, componentId);\n\n        //first we check if the debugger is injecting an output, if yes we skip the inputs check\n        if (agentRuntime.debug) {\n            output = await agentRuntime.injectDebugOutput(componentId);\n        }\n\n        if (!output) {\n            missingInputs = this.getComponentMissingInputs(componentId, _input);\n\n            if (missingInputs.length > 0) {\n                agentRuntime.updateComponent(componentId, { active: true, status: 'waiting' });\n                //check if _error output is connected to a component\n                const connections = this.connections.filter((c) => c.sourceId == componentId) || [];\n                let hasErrorHandler = false;\n                for (let connection of connections) {\n                    const outputEndpoint = componentData.outputs[connection.sourceIndex];\n                    if (outputEndpoint.name == '_error') {\n                        hasErrorHandler = true;\n                        break;\n                    }\n                }\n                //if (hasErrorHandler) return { id: componentData.id, name: componentData.name, result: null };\n\n                output = { _error: 'Missing inputs : ' + JSON.stringify(missingInputs), _missing_inputs: missingInputs };\n            }\n\n            if (!output) {\n                //the following case happens when no debugger injection was performed\n                const validationResult = await component.validateConfig(componentData);\n                if (validationResult._error) {\n                    output = validationResult;\n                } else {\n                    try {\n                        await this.parseVariables(); //make sure that any vault variable is loaded before processing the component\n                        //TODO: apply type inference here instead of in the component .process method\n                        output = await component.process({ ...this.agentVariables, ..._input }, componentData, this);\n                        console.log(output);\n                    } catch (error: any) {\n                        //this are fatal errors requiring to cancel the execution of this component.\n                        console.error('Error on component process: ', { componentId, name: componentData.name, input: _input }, error);\n                        if (error?.message) output = { Response: undefined, _error: error.message, _debug: error.message };\n                        else output = { Response: undefined, _error: error.toString(), _debug: error.toString() };\n                    }\n                }\n            }\n        }\n        const runtimeData = this.agentRuntime.getRuntimeData(componentId);\n        agentRuntime.updateComponent(componentId, { output });\n\n        if (output._in_progress) {\n            agentRuntime.updateComponent(componentId, { active: true, status: 'in_progress' });\n        }\n\n        if (output.error || output._error) {\n            //TODO : check if we need to keep loop data while clearing runtime data here\n            //in fact, output._error might be connected to a next component, in which case we need to keep the loop data\n            this.agentRuntime.resetComponent(componentId);\n\n            if (logId) {\n                //update log\n                AgentLogger.log(this, logId, { error: output.error || output._error });\n            }\n            if (output.error)\n                return [\n                    {\n                        id: componentData.id,\n                        name: componentData.displayName,\n                        result: null,\n                        error: output.error || output._error,\n                        _debug: output.error || output._error,\n                    },\n                ];\n        }\n\n        let results: any = [];\n        if (output /*&& !component.hasReadOutput*/ && !output._missing_inputs) {\n            AgentLogger.logTask(this, 1); //log successful task (non blocking call)\n\n            //proceed with the next component(s)\n            results = await this.callNextComponents(componentId, output).catch((error) => ({\n                error,\n                id: componentData.id,\n                name: componentData.displayName,\n            }));\n\n            //TODO : maybe handle the number of branches inside ForEach component\n            if (runtimeData._LoopData && output._in_progress && runtimeData._LoopData.branches == undefined) {\n                //handle loop branching\n                const branches = Array.isArray(results) ? results.length : 1;\n                if (output._in_progress) {\n                    runtimeData._LoopData.branches = branches;\n                    agentRuntime.updateRuntimeData(componentId, { _LoopData: runtimeData._LoopData });\n                }\n            }\n\n            if (results._is_leaf) {\n                //we reached the end of the execution tree, we need to check if this branch is a loop\n                delete results._is_leaf;\n                const _ChildLoopData = runtimeData._ChildLoopData;\n                if (_ChildLoopData && _ChildLoopData.parentId) {\n                    const parentId = _ChildLoopData.parentId;\n                    const _LoopData = this.agentRuntime.getRuntimeData(parentId)._LoopData;\n                    if (_LoopData) {\n                        if (!_LoopData.result) _LoopData.result = [];\n                        //we are in a loop, we need to update loop parent status in order to signal that we can run the next loop cycle\n\n                        let resultsCopy = JSON.parse(JSON.stringify(results));\n                        if (results.result) results.result._exclude = true;\n\n                        resultsCopy = await component.postProcess(resultsCopy, componentData, this);\n\n                        _LoopData.result.push(resultsCopy);\n                        _LoopData.branches--;\n\n                        if (_LoopData.branches <= 0) {\n                            agentRuntime.updateComponent(parentId, { active: true, status: '' }); //remove _in_progress status after processing all branches\n                        }\n                        //save the last result so that the loop parent can read it\n                        agentRuntime.updateRuntimeData(parentId, { _LoopData });\n                    }\n                } else {\n                    //leaf but no childLoopData, is this a loop component with no children ?\n                    const _LoopData = this.agentRuntime.getRuntimeData(componentId)._LoopData;\n                    if (_LoopData && _LoopData.loopIndex == 1) {\n                        _LoopData._in_progress = false;\n                        output._in_progress = false;\n                        agentRuntime.updateComponent(componentId, { active: true, status: '' });\n                        agentRuntime.updateRuntimeData(componentId, { _LoopData });\n                    }\n                }\n            }\n        }\n\n        //check if the component context is potentially needed in next cycles\n        if (!output._missing_inputs && !output._in_progress) {\n            //we processed the current component, we can now reset the runtime data and active status\n            const inLoop =\n                runtimeData?._ChildLoopData?._in_progress && runtimeData._ChildLoopData?.loopIndex < runtimeData._ChildLoopData?.loopLength;\n            if (inLoop) {\n                // loop children require to keep external runtime data, we only clear the data that was set inside the loop\n                this.clearChildLoopRuntimeComponentData(componentId);\n                agentRuntime.updateComponent(componentId, { active: true, status: 'waiting' });\n            } else {\n                this.agentRuntime.resetComponent(componentId); //also sets active to false\n            }\n        } //if inputs were missing, the output contains error information, not actual component processing output, in this case we keep the runtime data\n\n        //filter out null results\n        if (Array.isArray(results)) results = results.flat(Infinity).filter((r) => r.result != null);\n\n        if (logId) {\n            //update log\n            AgentLogger.log(this, logId, { output, outputTimestamp: '' + Date.now() });\n        }\n\n        //return this.agentRuntime.debug ? [results, { id: componentData.id, name: componentData.name, result: output }] : results;\n        return [results, { id: componentData.id, name: componentData.displayName, result: output }];\n    }\n    JSONExpression(obj, propertyString) {\n        const properties = propertyString.split(/\\.|\\[|\\]\\.|\\]\\[|\\]/).filter(Boolean);\n        let currentProperty = obj;\n\n        for (let property of properties) {\n            if (currentProperty === undefined || currentProperty === null) {\n                return undefined;\n            }\n\n            currentProperty = currentProperty[property];\n        }\n\n        return currentProperty;\n    }\n\n    //\n    async callNextComponents(componentId, output) {\n        const agentRuntime = this.agentRuntime;\n        //agentRuntime.incStep();\n\n        const componentData = this.components[componentId];\n        const component: Component = componentInstance[componentData.name];\n\n        //if (component.hasReadOutput) return [];\n\n        //get the list of connections for the current component in order to determine the next component(s) to call\n        let connections = this.connections\n            .filter((c) => c.sourceId == componentId /*|| this.alwaysActiveComponents[c.sourceId]*/)\n            .map((c) => ({ ...c, output, componentData }));\n\n        //also find connections from always active components to components with status 'waiting'\n\n        const waitingComponents = agentRuntime.getWaitingComponents();\n        const waitingComponentIds = waitingComponents.map((e) => e.id);\n        const alwaysActiveIds = Object.keys(this.agentRuntime.alwaysActiveComponents);\n        const alwaysActiveConnections = this.connections\n            .filter((c) => alwaysActiveIds.includes(c.sourceId) && waitingComponentIds.includes(c.targetId))\n            .map((c) => {\n                const output = {};\n                const waitingComponent = waitingComponents.find((e) => e.id == c.targetId);\n                const prevComponentData = this.components[c.sourceId];\n                const prevComponent: Component = componentInstance[prevComponentData.name];\n                const outputEndpoint = prevComponentData.outputs[c.sourceIndex];\n                output[outputEndpoint.name] = prevComponent.readOutput(outputEndpoint.name, prevComponentData, this);\n\n                return { ...c, output, componentData: this.components[c.sourceId] };\n            });\n        connections = [...connections, ...alwaysActiveConnections];\n\n        //no more components to call, return the output\n        if (!Array.isArray(connections) || connections.length == 0) {\n            return { id: componentData.id, name: componentData.name, result: output, _is_leaf: true };\n        }\n\n        const targetComponents = //classify connections by objects\n            connections.reduce((acc, obj) => {\n                let key = obj.targetId;\n                if (!acc[key]) {\n                    acc[key] = [];\n                }\n                acc[key].push(obj);\n                return acc;\n            }, {});\n\n        const promises: any = [];\n        for (let targetId in targetComponents) {\n            const targetComponentData = this.components[targetId];\n\n            //if we are not inside an async component, we skip async branches\n            //Note : we exclude Async component from this rule because it's the one that initiates the async job\n            if (!this.async && targetComponentData.async && targetComponentData.name !== 'Async') continue;\n\n            const targetComponent: Component = componentInstance[targetComponentData.name];\n            const connections = targetComponents[targetId];\n\n            if (Array.isArray(connections) && connections.length > 0) {\n                const nextInput = {};\n                for (let connection of connections) {\n                    const output = connection.output;\n                    const componentData = connection.componentData;\n                    const outputEndpoint = componentData.outputs[connection.sourceIndex]; //source\n                    const inputEndpoint = targetComponentData.inputs[connection.targetIndex]; //target\n\n                    //outputs can be named (e.g \"user:email\" or \"Req:body:data\") in which case they refer to a path in the output object\n                    const outputExpression = outputEndpoint.expression || outputEndpoint.name;\n                    const outputParts = outputExpression.split('.');\n\n                    const defaultOutputs = componentData.outputs.find((c) => c.default);\n                    let value: any = undefined;\n                    if (outputEndpoint.default) value = output[outputEndpoint.name] /* || null*/;\n                    else {\n                        if (defaultOutputs /* && output[defaultOutputs.name]?.[outputEndpoint.name]*/) {\n                            value = output[defaultOutputs.name]?.[outputEndpoint.name];\n                        }\n                    }\n                    if (/*value === null || */ value === undefined && outputParts.length >= 1) {\n                        let val = this.JSONExpression(output, outputExpression);\n                        if (val !== undefined) value = val;\n                    }\n\n                    // if (/*value !== null && */ value !== undefined) {\n                    //     nextInput[inputEndpoint.name] = [...new Set([[nextInput[inputEndpoint.name], value]].flat(Infinity))].filter(\n                    //         (e) => e !== undefined /*&& e !== null*/,\n                    //     );\n\n                    //     if (nextInput[inputEndpoint.name].length == 1) nextInput[inputEndpoint.name] = nextInput[inputEndpoint.name][0];\n                    // }\n\n                    //Fix suggested by Sentinel Agent\n                    if (/*value !== null && */ value !== undefined) {\n                        let combinedInput = [...[nextInput[inputEndpoint.name]].flat(), ...[value].flat()].filter(\n                            (e) => e !== undefined /*&& e !== null*/\n                        );\n\n                        nextInput[inputEndpoint.name] = combinedInput.length === 1 ? combinedInput[0] : combinedInput;\n                    }\n                }\n                if (!nextInput || JSON.stringify(nextInput) == '{}') continue;\n\n                const input = this.prepareComponentInput(targetId, nextInput);\n\n                const targetComponent = this.components[targetId];\n\n                const missingInputs = this.getComponentMissingInputs(targetId, input);\n                const status = missingInputs.length > 0 ? 'waiting' : undefined;\n\n                const sourceRuntimeData = this.agentRuntime.getRuntimeData(componentId); //We read the previous component runtime data\n\n                let _ChildLoopData = sourceRuntimeData._LoopData; //is the source a loop component ?\n\n                if (!_ChildLoopData || !_ChildLoopData._in_progress) {\n                    //if it's a loop component we need to check if the loop is still in progress\n\n                    _ChildLoopData = sourceRuntimeData._ChildLoopData; // if the loop is completed, check if the loop component is a nested loop, in which case we pass the parent context to the following component\n                }\n\n                agentRuntime.updateComponent(targetId, { active: true, input: nextInput, sourceId: componentId, status });\n                agentRuntime.updateRuntimeData(targetId, { _ChildLoopData, _LoopData: null });\n                promises.push(idPromise({ id: targetId, name: targetComponent.name, inputs: nextInput }));\n\n                if (status) {\n                    //if status is set, track the component status update\n                    //if not set, it means that the component is active and will be logged upon execution\n                    //this can be considered as a fake log step that help us keep track of the execution tree\n                    const logId = AgentLogger.log(this, null, {\n                        sourceId: componentId,\n                        componentId: targetId,\n                        step: this.agentRuntime.curStep + 1, //we force to next step because the current step order is updated in the next runCycle()\n                        domain: this.domain,\n                        workflowID: this.agentRuntime.workflowReqId,\n                        processID: this.agentRuntime.processID,\n                        input: { __action: 'status_update', __status: status, data: nextInput },\n                        inputTimestamp: new Date().toISOString(),\n                        sessionID: this.callerSessionId,\n                        tags: this.sessionTag,\n                    });\n                }\n            }\n        }\n\n        if (promises.length == 0) {\n            return { id: componentData.id, name: componentData.name, result: output, _is_leaf: true };\n        }\n        const results = await Promise.all(promises);\n\n        //TODO : exclusive components handling\n        //in order to run exclusive components first, we need to run them in current cycle\n        //then we signal to the caller component that one more run cycle is needed\n        return results.length == 1 ? results[0] : results;\n    }\n    private prepareComponentInput(targetId, inputs) {\n        const rData: any = this.agentRuntime.getRuntimeData(targetId);\n        const componentData = this.components[targetId];\n        const rDataInput = rData?.input || {};\n\n        let _input = { ...rDataInput };\n        if (inputs) {\n            // for (let key in inputs) {\n            //     let value = inputs[key];\n            //     //_input[key] = mergeJsonData(_input[key], value);\n\n            //     _input[key] = [...new Set([[rDataInput[key]], [value]].flat(Infinity))].filter((e) => e !== undefined /* && e !== null*/);\n            //     if (_input[key].length == 1) _input[key] = _input[key][0];\n            // }\n\n            //Fix suggested by Sentinel Agent\n            for (let key in inputs) {\n                let value = inputs[key];\n                // Concatenate the existing value with the new input, without using Set to preserve duplicates\n                _input[key] = [rDataInput[key], value].flat(Infinity).filter((e) => e !== undefined);\n\n                // Simplify the array to a single value if there is only one element after flattening\n                if (_input[key].length == 1) _input[key] = _input[key][0];\n            }\n        }\n\n        const readablePredecessors = this.findReadablePredecessors(targetId);\n        for (let c of readablePredecessors) {\n            if (c) {\n                const predComponentData = this.components[c.id];\n                const value = c.component.readOutput(c.output.name, predComponentData, this);\n                if (value && c.input?.name) {\n                    if (!_input) _input = {};\n                    _input[c.input.name] = value;\n                }\n            }\n        }\n\n        //this.saveRuntimeComponentData(targetId, { input: _input }); //TODO : check if we can use this.agentRuntime.updateRuntimeData instead (need to be carefully tested)\n        this.agentRuntime.updateRuntimeData(targetId, { input: _input });\n\n        for (let input of componentData.inputs) {\n            if (input.defaultVal && _input[input.name] === undefined) {\n                _input[input.name] = TemplateString(input.defaultVal).parse(this.agentVariables).result;\n                //parseTemplate(input.defaultVal, this.agentVariables, { escapeString: false, processUnmatched: false });\n            }\n        }\n        return _input;\n    }\n\n    public getConnectionSource(connection) {\n        return this.components[connection.sourceId].inputs.find((e) => e.index === connection.sourceIndex);\n    }\n\n    public getConnectionTarget(connection) {\n        return this.components[connection.targetId].inputs.find((e) => e.index === connection.targetIndex);\n    }\n\n    private recursiveTagAsyncComponents(component) {\n        const agent = this;\n        for (let output of component.outputs) {\n            if (component.name == 'Async' && output.name === 'JobID') continue; //'JobID' is a special output\n            const connected = agent.connections.filter((c) => c.sourceId === component.id && c.sourceIndex === output.index);\n            if (!connected) continue;\n            for (let con of connected) {\n                const targetComponent = agent.components[con.targetId];\n                if (!targetComponent) continue;\n                targetComponent.async = true;\n                this.recursiveTagAsyncComponents(targetComponent);\n            }\n        }\n    }\n    private tagAsyncComponents() {\n        const agent = this;\n        const componentsList: any[] = Object.values(agent.components);\n        const AsyncComponents: any[] = componentsList.filter((c) => c.name === 'Async');\n        if (!AsyncComponents || AsyncComponents.length == 0) return;\n        for (let AsyncComponent of AsyncComponents) {\n            AsyncComponent.async = true;\n            this.recursiveTagAsyncComponents(AsyncComponent);\n        }\n\n        //AsyncComponents.async = true;\n\n        //this.recursiveTagAsyncComponents(AsyncComponent, agent);\n    }\n}\n","import { SREConfig, TConnectorService } from '@sre/types/SRE.types';\nimport { ConnectorService } from './ConnectorsService';\nimport SystemEvents from './SystemEvents';\nimport { Logger } from '../helpers/Log.helper';\n\nconst logger = Logger('SRE');\nconst CInstance = ConnectorService;\n\nexport default class SmythRuntime {\n    public started = false;\n\n    protected constructor() {\n        this.started = true;\n    }\n\n    protected static instance?: SmythRuntime;\n    public static get Instance(): SmythRuntime {\n        if (!SmythRuntime.instance) {\n            SmythRuntime.instance = new SmythRuntime();\n        }\n        return SmythRuntime.instance;\n    }\n\n    private initialized = false;\n    public init(_config: SREConfig): SmythRuntime {\n        if (this.initialized) {\n            throw new Error('SRE already initialized');\n        }\n        this.initialized = true;\n\n        const config = this.autoConf(_config);\n\n        for (let connectorType in config) {\n            for (let configEntry of config[connectorType]) {\n                CInstance.init(connectorType as TConnectorService, configEntry.Connector, configEntry.Settings, configEntry.Default);\n            }\n        }\n\n        SystemEvents.emit('SRE:Initialized');\n        return SmythRuntime.Instance as SmythRuntime;\n    }\n\n    /**\n     * This function tries to auto configure, or fixes the provided configuration\n     *\n     * FIXME: The current version does not actually auto configure SRE, it just fixes the provided configuration for now\n     * TODO: Implement auto configuration based on present environment variables and auto-detected configs\n     * @param config\n     */\n    private autoConf(config: SREConfig) {\n        const newConfig: SREConfig = {};\n        for (let connectorType in config) {\n            newConfig[connectorType] = [];\n            if (typeof config[connectorType] === 'object') config[connectorType] = [config[connectorType]];\n\n            let hasDefault = false;\n            for (let connector of config[connectorType]) {\n                if (!connector.Connector) {\n                    console.warn(`Missing Connector Name in ${connectorType} entry ... it will be ignored`);\n                    continue;\n                }\n                if (connector.Default) {\n                    if (hasDefault) {\n                        console.warn(`Entry ${connectorType} has more than one default Connector ... only the first one will be used`);\n                    }\n                    hasDefault = true;\n                }\n                newConfig[connectorType].push(connector);\n            }\n\n            if (!hasDefault && newConfig[connectorType].length > 0) {\n                newConfig[connectorType][0].Default = true;\n            }\n        }\n\n        return newConfig;\n    }\n\n    public ready(): boolean {\n        return this.initialized;\n    }\n\n    public async _stop() {\n        logger.info('Shutting Down SmythRuntime ...');\n        CInstance._stop();\n        SmythRuntime.instance = undefined;\n        this.started = false;\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { ACLAccessDeniedError, IAccessCandidate, TAccessLevel, TAccessResult, TAccessTicket } from '@sre/types/ACL.types';\nimport { ACL } from './AccessControl/ACL.class';\nimport { AccessCandidate } from './AccessControl/AccessCandidate.class';\nimport { AccessRequest } from './AccessControl/AccessRequest.class';\n\nconst console = Logger('SecureConnector');\n\nexport abstract class SecureConnector extends Connector {\n    public abstract name: string;\n\n    //this determines the access rights for the requested resource\n    //the connector should check if the resource exists or not\n    //if the resource exists we read its ACL and return it\n    //if the resource does not exist we return an write access ACL for the candidate\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n\n    public async start() {\n        console.info(`Starting ${this.name} connector ...`);\n    }\n\n    public async stop() {\n        console.info(`Stopping ${this.name} connector ...`);\n    }\n\n    protected async hasAccess(acRequest: AccessRequest) {\n        const aclHelper = await this.getResourceACL(acRequest.resourceId, acRequest.candidate);\n\n        //const aclHelper = ACLHelper.from(acl);\n\n        const exactAccess = aclHelper.checkExactAccess(acRequest);\n        if (exactAccess) return true;\n\n        // if the exact access is denied, we check if the candidate has a higher access\n        const ownerRequest = AccessRequest.clone(acRequest).setLevel(TAccessLevel.Owner);\n        const ownerAccess = aclHelper.checkExactAccess(ownerRequest);\n        if (ownerAccess) return true;\n\n        // if the exact access is denied, we check if the requested resource has a public access\n        const publicRequest = AccessRequest.clone(acRequest).setCandidate(AccessCandidate.public());\n        const publicAccess = aclHelper.checkExactAccess(publicRequest);\n        if (publicAccess) return true;\n\n        // if the public access is denied, we check if the candidate's team has access\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n        const teamRequest = AccessRequest.clone(acRequest).setCandidate(AccessCandidate.team(teamId));\n        const teamAccess = aclHelper.checkExactAccess(teamRequest);\n        if (teamAccess) return true;\n\n        // if the team access is denied, we check if the team has a higher access\n        const teamOwnerRequest = AccessRequest.clone(teamRequest).setLevel(TAccessLevel.Owner);\n        const teamOwnerAccess = aclHelper.checkExactAccess(teamOwnerRequest);\n        if (teamOwnerAccess) return true;\n\n        return false;\n    }\n    public async getAccessTicket(resourceId: string, request: AccessRequest): Promise<TAccessTicket> {\n        const sysAcRequest = AccessRequest.clone(request).resource(resourceId);\n        const accessTicket = {\n            request,\n            access: (await this.hasAccess(sysAcRequest)) ? TAccessResult.Granted : TAccessResult.Denied,\n        };\n\n        return accessTicket as TAccessTicket;\n    }\n\n    //#region [ Decorators ]==========================\n\n    //AccessControl decorator\n    //This decorator will inject the access control logic into storage connector methods\n    // in order to work properly, the connector expects the resourceId to be the first argument and the access request to be the second argument\n\n    static AccessControl(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        // Store the original method in a variable\n        const originalMethod = descriptor.value;\n\n        // Modify the descriptor's value to wrap the original method\n        descriptor.value = async function (...args: any[]) {\n            // Extract the method arguments\n            const [acRequest, resourceId] = args;\n\n            // Inject the access control logic\n            const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n            if (accessTicket.access !== TAccessResult.Granted) throw new ACLAccessDeniedError('Access Denied');\n\n            // Call the original method with the original arguments\n            return originalMethod.apply(this, args);\n        };\n\n        // Return the modified descriptor\n        return descriptor;\n    }\n\n    //#endregion\n}\n","import { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL } from '@sre/types/ACL.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\n\nexport interface IStorageRequest {\n    read(resourceId: string): Promise<StorageData>;\n    write(resourceId: string, value: StorageData, acl?: IACL, metadata?: StorageMetadata): Promise<void>;\n    delete(resourceId: string): Promise<void>;\n    exists(resourceId: string): Promise<boolean>;\n    getMetadata(resourceId: string): Promise<StorageMetadata | undefined>;\n    setMetadata(resourceId: string, metadata: StorageMetadata): Promise<void>;\n    getACL(resourceId: string): Promise<ACL | undefined>;\n    setACL(resourceId: string, acl: IACL): Promise<void>;\n}\n\nexport abstract class StorageConnector extends SecureConnector {\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n    public abstract user(candidate: IAccessCandidate): IStorageRequest;\n    protected abstract read(acRequest: AccessRequest, resourceId: string): Promise<StorageData>;\n    protected abstract write(acRequest: AccessRequest, resourceId: string, value: StorageData, acl?: IACL, metadata?: StorageMetadata): Promise<void>;\n    protected abstract delete(acRequest: AccessRequest, resourceId: string): Promise<void>;\n    protected abstract exists(acRequest: AccessRequest, resourceId: string): Promise<boolean>;\n\n    protected abstract getMetadata(acRequest: AccessRequest, resourceId: string): Promise<StorageMetadata | undefined>;\n    protected abstract setMetadata(acRequest: AccessRequest, resourceId: string, metadata: StorageMetadata): Promise<void>;\n\n    protected abstract getACL(acRequest: AccessRequest, resourceId: string): Promise<ACL | undefined>;\n    protected abstract setACL(acRequest: AccessRequest, resourceId: string, acl: IACL): Promise<void>;\n}\n","//==[ SRE: S3Storage ]======================\n\nimport { DeleteObjectCommand, GetObjectCommand, HeadObjectCommand, PutObjectCommand, S3Client, S3ClientConfig } from '@aws-sdk/client-s3';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { IStorageRequest, StorageConnector } from '@sre/IO/Storage.service/StorageConnector';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { IAccessCandidate, IACL, TAccessLevel, TAccessResult, TAccessRole } from '@sre/types/ACL.types';\nimport { S3Config } from '@sre/types/AWS.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\nimport { streamToBuffer } from '@sre/utils';\nimport type { Readable } from 'stream';\n\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\n\nconst console = Logger('S3Storage');\n\nexport class S3Storage extends StorageConnector {\n    public name = 'S3Storage';\n    private client: S3Client;\n    private bucket: string;\n\n    constructor(private config: S3Config & { bucket: string }) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n        this.bucket = config.bucket;\n        const clientConfig: S3ClientConfig = {};\n        if (config.region) clientConfig.region = config.region;\n        if (config.accessKeyId && config.secretAccessKey) {\n            clientConfig.credentials = {\n                accessKeyId: config.accessKeyId,\n                secretAccessKey: config.secretAccessKey,\n            };\n        }\n\n        this.client = new S3Client(clientConfig);\n    }\n\n    public user(candidate: AccessCandidate): IStorageRequest {\n        return {\n            write: async (resourceId: string, value: StorageData, acl?: IACL, metadata?: StorageMetadata) => {\n                return await this.write(candidate.writeRequest, resourceId, value, acl, metadata);\n            },\n            read: async (resourceId: string) => {\n                return await this.read(candidate.readRequest, resourceId);\n            },\n            delete: async (resourceId: string) => {\n                await this.delete(candidate.readRequest, resourceId);\n            },\n            exists: async (resourceId: string) => {\n                return await this.exists(candidate.readRequest, resourceId);\n            },\n            getMetadata: async (resourceId: string) => {\n                return await this.getMetadata(candidate.readRequest, resourceId);\n            },\n            setMetadata: async (resourceId: string, metadata: StorageMetadata) => {\n                await this.setMetadata(candidate.writeRequest, resourceId, metadata);\n            },\n            getACL: async (resourceId: string) => {\n                return await this.getACL(candidate.readRequest, resourceId);\n            },\n            setACL: async (resourceId: string, acl: IACL) => {\n                return await this.setACL(candidate.writeRequest, resourceId, acl);\n            },\n        } as IStorageRequest;\n    }\n    /**\n     * Reads an object from the S3 bucket.\n     *\n     * @param {string} resourceId - The key of the object to be read.\n     * @returns {Promise<any>} - A promise that resolves with the object data.\n     */\n\n    @SecureConnector.AccessControl\n    public async read(acRequest: AccessRequest, resourceId: string) {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        const command = new GetObjectCommand({\n            Bucket: this.bucket,\n            Key: resourceId,\n        });\n\n        try {\n            const response = await this.client.send(command);\n            //const metadata = response.Metadata;\n            return await streamToBuffer(response.Body as Readable);\n        } catch (error) {\n            if (error.name === 'NotFound' || error.name === 'NoSuchKey') {\n                return undefined;\n            }\n            console.error(`Error reading object from S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async getMetadata(acRequest: AccessRequest, resourceId: string): Promise<StorageMetadata | undefined> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        try {\n            const s3Metadata = await this.getS3Metadata(resourceId);\n            return s3Metadata as StorageMetadata;\n        } catch (error) {\n            console.error(`Error getting access rights in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async setMetadata(acRequest: AccessRequest, resourceId: string, metadata: StorageMetadata) {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        try {\n            let s3Metadata = await this.getS3Metadata(resourceId);\n            if (!s3Metadata) s3Metadata = {};\n            //s3Metadata['x-amz-meta-data'] = metadata;\n            s3Metadata = { ...s3Metadata, ...metadata };\n            await this.setS3Metadata(resourceId, s3Metadata);\n        } catch (error) {\n            console.error(`Error setting access rights in S3`, error);\n            throw error;\n        }\n    }\n    /**\n     * Writes an object to the S3 bucket.\n     *\n     * @param {string} resourceId - The key of the object to be written.\n     * @param {any} value - The value of the object to be written.\n     * @param {Metadata} metadata - Optional metadata to be associated with the object.\n     * @returns {Promise<void>} - A promise that resolves when the object has been written.\n     */\n    @SecureConnector.AccessControl\n    async write(acRequest: AccessRequest, resourceId: string, value: StorageData, acl?: IACL, metadata?: StorageMetadata): Promise<void> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        const accessCandidate = acRequest.candidate;\n\n        let amzACL = ACL.from(acl).addAccess(accessCandidate.role, accessCandidate.id, TAccessLevel.Owner).ACL;\n        let s3Metadata = {\n            ...metadata,\n            'x-amz-meta-acl': amzACL,\n        };\n\n        const command = new PutObjectCommand({\n            Bucket: this.bucket,\n            Key: resourceId,\n            Body: value,\n            Metadata: this.serializeS3Metadata(s3Metadata),\n            ContentType: s3Metadata['ContentType'],\n        });\n\n        try {\n            const result: any = await this.client.send(command);\n        } catch (error) {\n            console.error(`Error writing object to S3`, error.name, error.message);\n            //console.error(error);\n            throw error;\n        }\n    }\n\n    /**\n     * Deletes an object from the S3 bucket.\n     *\n     * @param {string} resourceId - The key of the object to be deleted.\n     * @returns {Promise<void>} - A promise that resolves when the object has been deleted.\n     */\n    @SecureConnector.AccessControl\n    async delete(acRequest: AccessRequest, resourceId: string): Promise<void> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        const command = new DeleteObjectCommand({\n            Bucket: this.bucket,\n            Key: resourceId,\n        });\n\n        try {\n            await this.client.send(command);\n        } catch (error) {\n            console.error(`Error deleting object from S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async exists(acRequest: AccessRequest, resourceId: string): Promise<boolean> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n        const command = new HeadObjectCommand({\n            Bucket: this.bucket,\n            Key: resourceId,\n        });\n\n        try {\n            await this.client.send(command);\n            return true;\n        } catch (error) {\n            if (error.name === 'NotFound' || error.name === 'NoSuchKey') {\n                return false;\n            }\n\n            console.error(`Error checking object existence in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    //this determines the access rights for the requested resource\n    //the connector should check if the resource exists or not\n    //if the resource exists we read it's ACL and return it\n    //if the resource does not exist we return an write access ACL for the candidate\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate) {\n        const s3Metadata = await this.getS3Metadata(resourceId);\n        const exists = s3Metadata !== undefined; //undefined metadata means the resource does not exist\n        //let acl: ACL = ACL.from(s3Metadata?.['x-amz-meta-acl'] as IACL);\n\n        if (!exists) {\n            //the resource does not exist yet, we grant write access to the candidate in order to allow the resource creation\n            return new ACL().addAccess(candidate.role, candidate.id, TAccessLevel.Owner);\n        }\n        return ACL.from(s3Metadata?.['x-amz-meta-acl'] as IACL);\n    }\n\n    @SecureConnector.AccessControl\n    async getACL(acRequest: AccessRequest, resourceId: string): Promise<ACL | undefined> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        try {\n            const s3Metadata = await this.getS3Metadata(resourceId);\n            return ACL.from(s3Metadata?.['x-amz-meta-acl'] as IACL);\n        } catch (error) {\n            console.error(`Error getting access rights in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async setACL(acRequest: AccessRequest, resourceId: string, acl: IACL) {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        try {\n            let s3Metadata = await this.getS3Metadata(resourceId);\n            if (!s3Metadata) s3Metadata = {};\n            //when setting ACL make sure to not lose ownership\n            s3Metadata['x-amz-meta-acl'] = ACL.from(acl).addAccess(acRequest.candidate.role, acRequest.candidate.id, TAccessLevel.Owner).ACL;\n            await this.setS3Metadata(resourceId, s3Metadata);\n        } catch (error) {\n            console.error(`Error setting access rights in S3`, error);\n            throw error;\n        }\n    }\n\n    private migrateMetadata(metadata: Record<string, string>): Record<string, any> {\n        if (!metadata.agentid && !metadata.teamid && !metadata.userid) return metadata as Record<string, any>;\n        else {\n            const convertibleItems = ['agentid', 'teamid', 'userid'];\n            const aclHelper = new ACL();\n\n            for (let key of convertibleItems) {\n                if (!metadata[key]) continue;\n                const role = key === 'agentid' ? TAccessRole.Agent : key === 'teamid' ? TAccessRole.Team : TAccessRole.User;\n                aclHelper.addAccess(role, metadata[key].toString(), [TAccessLevel.Owner, TAccessLevel.Read, TAccessLevel.Write]);\n                delete metadata[key];\n            }\n            aclHelper.migrated = true;\n            const newMetadata: Record<string, any> = {\n                'x-amz-meta-acl': aclHelper.ACL,\n            };\n            //copy remaining metadata\n            for (let key in metadata) {\n                newMetadata[key] = metadata[key];\n            }\n\n            return newMetadata;\n        }\n    }\n\n    private serializeS3Metadata(s3Metadata: Record<string, any>): Record<string, string> {\n        let amzMetadata = {};\n        if (s3Metadata['x-amz-meta-acl']) {\n            //const acl: TACL = s3Metadata['x-amz-meta-acl'];\n            if (s3Metadata['x-amz-meta-acl']) {\n                amzMetadata['x-amz-meta-acl'] =\n                    typeof s3Metadata['x-amz-meta-acl'] == 'string'\n                        ? s3Metadata['x-amz-meta-acl']\n                        : ACL.from(s3Metadata['x-amz-meta-acl']).serializedACL;\n            }\n\n            delete s3Metadata['x-amz-meta-acl'];\n        }\n\n        for (let key in s3Metadata) {\n            if (key == 'ContentType') continue; //skip ContentType as it can only be set when writing the object\n            amzMetadata[key] = typeof s3Metadata[key] === 'string' ? s3Metadata[key] : JSON.stringify(s3Metadata[key]);\n        }\n\n        return amzMetadata;\n    }\n\n    private deserializeS3Metadata(amzMetadata: Record<string, string>): Record<string, any> {\n        let metadata: Record<string, any> = {};\n\n        for (let key in amzMetadata) {\n            if (key === 'x-amz-meta-acl') {\n                metadata[key] = ACL.from(amzMetadata[key]).ACL;\n                continue;\n            }\n\n            try {\n                metadata[key] = JSON.parse(amzMetadata[key]);\n            } catch (error) {\n                metadata[key] = amzMetadata[key];\n            }\n        }\n        //TODO : Remove this migration code after all metadata is migrated\n        //       Context : an old ACL metadata format was used in initial implementation of Smyth Storage\n        //       We need to ensure compatibility with legacy format and seamlessly convert it when reading\n        metadata = this.migrateMetadata(metadata) as Record<string, any>;\n\n        return metadata;\n    }\n\n    private async getS3Metadata(resourceId: string): Promise<Record<string, any> | undefined> {\n        try {\n            const command = new HeadObjectCommand({\n                Bucket: this.bucket,\n                Key: resourceId,\n            });\n            const response = await this.client.send(command);\n            const s3RawMetadata = response.Metadata;\n            if (!s3RawMetadata || Object.keys(s3RawMetadata).length === 0) return {};\n\n            let metadata: Record<string, any> = this.deserializeS3Metadata(s3RawMetadata);\n\n            if (!metadata['ContentType']) metadata['ContentType'] = response.ContentType ? response.ContentType : 'application/octet-stream';\n            return metadata;\n        } catch (error) {\n            if (error.name === 'NotFound' || error.name === 'NoSuchKey') {\n                return undefined;\n            }\n            console.error(`Error reading object metadata from S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    private async setS3Metadata(resourceId: string, metadata: Record<string, any>): Promise<void> {\n        try {\n            // Get the current object content\n            const getObjectCommand = new GetObjectCommand({\n                Bucket: this.bucket,\n                Key: resourceId,\n            });\n            const objectData = await this.client.send(getObjectCommand);\n\n            // Read the object's content\n            const bufferBody = await streamToBuffer(objectData.Body as Readable);\n\n            const amzMetadata = this.serializeS3Metadata(metadata);\n            // Put the object back with the new metadata and the same content\n            const putObjectCommand = new PutObjectCommand({\n                Bucket: this.bucket,\n                Key: resourceId,\n                Body: bufferBody,\n                Metadata: amzMetadata,\n            });\n\n            await this.client.send(putObjectCommand);\n        } catch (error) {\n            console.error(`Error setting object metadata in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n}\n","//==[ SRE: Storage ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { S3Storage } from './connectors/S3Storage.class';\n\nexport class StorageService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.Storage, 'S3', S3Storage);\n    }\n}\n","export default {\n    Echo: {\n        maxTokens: 'max_tokens',\n        temperature: 'temperature',\n        stopSequences: 'stop',\n        topP: 'top_p',\n        frequencyPenalty: 'frequency_penalty',\n        presencePenalty: 'presence_penalty',\n    },\n    OpenAI: {\n        maxTokens: 'max_tokens',\n        temperature: 'temperature',\n        stopSequences: 'stop',\n        topP: 'top_p',\n        frequencyPenalty: 'frequency_penalty',\n        presencePenalty: 'presence_penalty',\n    },\n    cohere: {\n        maxTokens: 'max_tokens',\n        temperature: 'temperature',\n        stopSequences: 'stop_sequences',\n        topP: 'p',\n        topK: 'k',\n        frequencyPenalty: 'frequency_penalty',\n        presencePenalty: 'presence_penalty',\n    },\n    togetherAI: {\n        maxTokens: 'max_tokens',\n        temperature: 'temperature',\n        stopSequences: 'stop',\n        topP: 'top_p',\n        topK: 'top_k',\n        frequencyPenalty: 'repetition_penalty',\n    },\n    AnthropicAI: {\n        maxTokens: 'max_tokens',\n        temperature: 'temperature',\n        stopSequences: 'stop_sequences',\n        topP: 'top_p',\n        topK: 'top_k',\n    },\n    GoogleAI: {\n        maxTokens: 'maxOutputTokens',\n        temperature: 'temperature',\n        stopSequences: 'stopSequences',\n        topP: 'topP',\n        topK: 'topK',\n    },\n    Groq: {\n        maxTokens: 'max_tokens',\n        temperature: 'temperature',\n        stopSequences: 'stop',\n        topP: 'top_p',\n    },\n};\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { Connector } from '@sre/Core/Connector.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport models from '@sre/LLMManager/models';\nimport paramMappings from '@sre/LLMManager/paramMappings';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { DEFAULT_MAX_TOKENS_FOR_LLM } from '@sre/constants';\nimport { JSONContent } from '@sre/helpers/JsonContent.helper';\nimport { IAccessCandidate } from '@sre/types/ACL.types';\nimport { LLMParams, LLMMessageBlock, LLMToolResultMessageBlock, ToolData } from '@sre/types/LLM.types';\nimport { isDataUrl, isUrl } from '@sre/utils';\nimport axios from 'axios';\nimport { encode } from 'gpt-tokenizer';\nimport imageSize from 'image-size';\nimport EventEmitter from 'events';\nimport { Readable } from 'stream';\nconst console = Logger('LLMConnector');\n\nexport interface ILLMConnectorRequest {\n    chatRequest(prompt, params: any): Promise<any>;\n    visionRequest(prompt, params: any): Promise<any>;\n    toolRequest(params: any): Promise<any>;\n    streamToolRequest(params: any): Promise<any>;\n    streamRequest(params: any): Promise<EventEmitter>;\n}\n\nexport type LLMChatResponse = {\n    content: string;\n    finishReason: string;\n};\n\nexport class LLMStream extends Readable {\n    private dataQueue: any[];\n    private toolsData: any[];\n    private hasData: boolean;\n    isReading: boolean;\n    constructor(options?) {\n        super(options);\n        this.dataQueue = [];\n        this.toolsData = [];\n        this.isReading = true;\n    }\n\n    _read(size) {\n        if (this.dataQueue.length > 0) {\n            while (this.dataQueue.length > 0) {\n                const chunk = this.dataQueue.shift();\n                if (!this.push(chunk)) {\n                    break;\n                }\n            }\n        } else {\n            this.push(null); // No more data\n        }\n    }\n\n    enqueueData(data) {\n        this.dataQueue.push(data);\n        this.read(0); // Trigger the _read method\n    }\n\n    endStream() {\n        this.isReading = false;\n        this.push(null); // End the stream\n    }\n}\n\nexport abstract class LLMConnector extends Connector {\n    public abstract name: string;\n    //public abstract user(candidate: AccessCandidate): ILLMConnectorRequest;\n    protected abstract chatRequest(acRequest: AccessRequest, prompt, params: any): Promise<LLMChatResponse>;\n    protected abstract visionRequest(acRequest: AccessRequest, prompt, params: any, agent: string | Agent): Promise<LLMChatResponse>;\n    protected abstract toolRequest(acRequest: AccessRequest, params: any): Promise<any>;\n    protected abstract streamToolRequest(acRequest: AccessRequest, params: any): Promise<any>;\n    protected abstract streamRequest(acRequest: AccessRequest, params: any): Promise<EventEmitter>;\n\n    public user(candidate: AccessCandidate): ILLMConnectorRequest {\n        if (candidate.role !== 'agent') throw new Error('Only agents can use LLM connector');\n        const vaultConnector = ConnectorService.getVaultConnector();\n        if (!vaultConnector) throw new Error('Vault Connector unavailable, cannot proceed');\n        return {\n            chatRequest: async (prompt, params: any) => {\n                const llm = models[params.model]?.llm;\n                if (!llm) throw new Error(`Model ${params.model} not supported`);\n                params.apiKey = await vaultConnector\n                    .user(candidate)\n                    .get(llm)\n                    .catch((e) => ''); //if vault access is denied we just return empty key\n                return this.chatRequest(candidate.readRequest, prompt, params);\n            },\n            visionRequest: async (prompt, params: any) => {\n                const llm = models[params.model]?.llm;\n                if (!llm) throw new Error(`Model ${params.model} not supported`);\n                params.apiKey = await vaultConnector\n                    .user(candidate)\n                    .get(llm)\n                    .catch((e) => ''); //if vault access is denied we just return empty key\n                return this.visionRequest(candidate.readRequest, prompt, params, candidate.id);\n            },\n            toolRequest: async (params: any) => {\n                const llm = models[params.model]?.llm;\n                if (!llm) throw new Error(`Model ${params.model} not supported`);\n                params.apiKey = await vaultConnector\n                    .user(candidate)\n                    .get(llm)\n                    .catch((e) => ''); //if vault access is denied we just return empty key\n                return this.toolRequest(candidate.readRequest, params);\n            },\n            streamToolRequest: async (params: any) => {\n                const llm = models[params.model]?.llm;\n                if (!llm) throw new Error(`Model ${params.model} not supported`);\n                params.apiKey = await vaultConnector\n                    .user(candidate)\n                    .get(llm)\n                    .catch((e) => ''); //if vault access is denied we just return empty key\n                return this.streamToolRequest(candidate.readRequest, params);\n            },\n            streamRequest: async (params: any) => {\n                const llm = models[params.model]?.llm;\n                if (!llm) throw new Error(`Model ${params.model} not supported`);\n                params.apiKey = await vaultConnector\n                    .user(candidate)\n                    .get(llm)\n                    .catch((e) => ''); //if vault access is denied we just return empty key\n                return this.streamRequest(candidate.readRequest, params);\n            },\n        };\n    }\n\n    private getAllowedCompletionTokens(model: string, hasTeamAPIKey: boolean = false) {\n        const alias = models[model]?.alias || model;\n\n        // Only allow full token limit if the API key is provided by the team\n        const maxTokens = hasTeamAPIKey\n            ? models[alias]?.keyOptions?.completionTokens || models[alias]?.keyOptions?.tokens\n            : models[alias]?.completionTokens || models[alias]?.tokens;\n\n        return +(maxTokens ?? DEFAULT_MAX_TOKENS_FOR_LLM);\n    }\n\n    private async getSafeMaxTokens(givenMaxTokens: number, model: string, hasApiKey: boolean): Promise<number> {\n        let allowedTokens = this.getAllowedCompletionTokens(model, hasApiKey);\n\n        // If the specified max tokens exceed the allowed limit, use the maximum allowed tokens instead.\n        let maxTokens = givenMaxTokens > allowedTokens ? allowedTokens : givenMaxTokens;\n\n        return +maxTokens;\n    }\n\n    protected async countVisionPromptTokens(prompt: any) {\n        let tokens = 0;\n\n        const textObj = prompt?.filter((item) => item.type === 'text');\n\n        /**\n         * encodeChat does not support object like {type: 'text', text: 'some text'}\n         * so count tokens of the text separately\n         * TODO: try to improve this later\n         */\n        const textTokens = encode(textObj?.[0]?.text).length;\n\n        const images = prompt?.filter((item) => item.type === 'image_url');\n        let imageTokens = 0;\n\n        for (const image of images) {\n            const image_url = image?.image_url?.url;\n            const { width, height } = await _getImageDimensions(image_url);\n\n            const tokens = _countImageTokens(width, height);\n\n            imageTokens += tokens;\n        }\n\n        tokens = textTokens + imageTokens;\n\n        return tokens;\n    }\n\n    public resolveModelName(model: string) {\n        return models[model]?.alias || model;\n    }\n    private getAllowedContextTokens(model: string, hasTeamAPIKey: boolean = false) {\n        const alias = this.resolveModelName(model);\n\n        // Only allow full token limit if the API key is provided by the team\n        const maxTokens = hasTeamAPIKey ? models[alias]?.keyOptions?.tokens : models[alias]?.tokens;\n\n        return +(maxTokens ?? DEFAULT_MAX_TOKENS_FOR_LLM);\n    }\n\n    // ! DEPRECATED: will be removed in favor of validateTokensLimit\n    public checkTokensLimit({\n        model,\n        promptTokens,\n        completionTokens,\n        hasTeamAPIKey = false,\n    }: {\n        model: string;\n        promptTokens: number;\n        completionTokens: number;\n        hasTeamAPIKey?: boolean;\n    }): { isExceeded: boolean; error: string } {\n        const allowedContextTokens = this.getAllowedContextTokens(model, hasTeamAPIKey);\n        const totalTokens = promptTokens + completionTokens;\n\n        if (totalTokens > allowedContextTokens) {\n            return {\n                isExceeded: true,\n                error: hasTeamAPIKey\n                    ? `This models' maximum content length is ${allowedContextTokens} tokens. (This is the sum of your prompt with all variables and the maximum output tokens you've set in Advanced Settings) However, you requested approx ${totalTokens} tokens (${promptTokens} in the prompt, ${completionTokens} in the output). Please reduce the length of either the input prompt or the Maximum output tokens.`\n                    : `Input exceeds max tokens limit of ${allowedContextTokens}. Please add your API key to unlock full length.`,\n            };\n        }\n\n        return { isExceeded: false, error: '' };\n    }\n\n    /**\n     * Validates if the total tokens (prompt input token + maximum output token) exceed the allowed context tokens for a given model.\n     *\n     * @param {Object} params - The function parameters.\n     * @param {string} params.model - The model identifier.\n     * @param {number} params.promptTokens - The number of tokens in the input prompt.\n     * @param {number} params.completionTokens - The number of tokens in the output completion.\n     * @param {boolean} [params.hasTeamAPIKey=false] - Indicates if the user has a team API key.\n     * @throws {Error} - Throws an error if the total tokens exceed the allowed context tokens.\n     */\n    public validateTokensLimit({\n        model,\n        promptTokens,\n        completionTokens,\n        hasTeamAPIKey = false,\n    }: {\n        model: string;\n        promptTokens: number;\n        completionTokens: number;\n        hasTeamAPIKey?: boolean;\n    }): void {\n        const allowedContextTokens = this.getAllowedContextTokens(model, hasTeamAPIKey);\n        const totalTokens = promptTokens + completionTokens;\n\n        const teamAPIKeyExceededMessage = `This models' maximum content length is ${allowedContextTokens} tokens. (This is the sum of your prompt with all variables and the maximum output tokens you've set in Advanced Settings) However, you requested approx ${totalTokens} tokens (${promptTokens} in the prompt, ${completionTokens} in the output). Please reduce the length of either the input prompt or the Maximum output tokens.`;\n        const noAPIKeyExceededMessage = `Input exceeds max tokens limit of ${allowedContextTokens}. Please add your API key to unlock full length.`;\n\n        if (totalTokens > allowedContextTokens) {\n            throw new Error(hasTeamAPIKey ? teamAPIKeyExceededMessage : noAPIKeyExceededMessage);\n        }\n    }\n\n    public enhancePrompt(prompt: string, config: any) {\n        if (!prompt) return prompt;\n        let newPrompt = prompt;\n        const outputs = {};\n        for (let con of config.outputs) {\n            if (con.default) continue;\n            outputs[con.name] = con?.description ? `<${con?.description}>` : '';\n        }\n\n        const excludedKeys = ['_debug', '_error'];\n        const outputKeys = Object.keys(outputs).filter((key) => !excludedKeys.includes(key));\n\n        if (outputKeys.length > 0) {\n            const outputFormat = {};\n            outputKeys.forEach((key) => (outputFormat[key] = '<value>'));\n\n            newPrompt +=\n                '\\n##\\nExpected output format = ' +\n                JSON.stringify(outputFormat) +\n                '\\nThe output JSON should only use the entries from the output format.';\n\n            //console.debug(` Enhanced prompt \\n`, prompt, '\\n');\n        }\n\n        return newPrompt;\n    }\n    public async extractLLMComponentParams(config: any) {\n        const params: LLMParams = {};\n        const model: string = config.data.model;\n        // Retrieve the API key and include it in the parameters here, as it is required for the max tokens check.\n\n        const apiKey = '';\n        //TODO: implement apiKey extraction from team vault\n        //const apiKey = await getLLMApiKey(model, agent?.teamId);\n        //if (apiKey) params.apiKey = apiKey;\n\n        /*** Prepare parameters from config data ***/\n\n        // * We need to keep the config.data unchanged to avoid any side effects, especially when run components with loop\n        const clonedConfigData = JSON.parse(JSON.stringify(config.data || {}));\n        const configParams = {};\n\n        for (const [key, value] of Object.entries(clonedConfigData)) {\n            let _value: string | number | string[] | null = value as string;\n\n            // When we have stopSequences, we need to split it into an array\n            if (key === 'stopSequences') {\n                _value = _value ? _value?.split(',') : null;\n            }\n\n            // When we have a string that is a number, we need to convert it to a number\n            if (typeof _value === 'string' && !isNaN(Number(_value))) {\n                _value = +_value;\n            }\n\n            // Always provide safe max tokens based on the model and apiKey\n            if (key === 'maxTokens') {\n                let maxTokens = Number(_value);\n\n                if (!maxTokens) {\n                    throw new Error('Max output token not provided');\n                }\n\n                maxTokens = await this.getSafeMaxTokens(maxTokens, model, !!apiKey);\n                _value = maxTokens;\n            }\n\n            configParams[key] = _value;\n        }\n\n        /*** Prepare LLM specific parameters ***/\n\n        const alias = models[model]?.alias || model;\n        const llm = models[alias]?.llm;\n\n        for (const [configKey, paramKey] of Object.entries(paramMappings[llm])) {\n            // we need to allow 0 as truthy\n            if (configParams?.[configKey] !== undefined || configParams?.[configKey] !== null || configParams?.[configKey] !== '') {\n                const value = configParams[configKey];\n\n                params[paramKey as string] = value;\n            }\n        }\n\n        return params;\n    }\n\n    public async extractVisionLLMParams(config: any) {\n        const params: LLMParams = {};\n        const model: string = config.data.model;\n        // Retrieve the API key and include it in the parameters here, as it is required for the max tokens check.\n\n        const apiKey = '';\n        //TODO: implement apiKey extraction from team vault\n        //const apiKey = await getLLMApiKey(model, agent?.teamId);\n        //if (apiKey) params.apiKey = apiKey;\n\n        const maxTokens = (await this.getSafeMaxTokens(+config.data.maxTokens, model, !!apiKey)) || 300;\n\n        const alias = models[model]?.alias || model;\n        const llm = models[alias]?.llm;\n\n        // as max output token prop name differs based on LLM provider, we need to get the actual prop from paramMappings\n        params[paramMappings[llm]?.maxTokens] = maxTokens;\n\n        return params;\n    }\n    public postProcess(response: string) {\n        try {\n            return JSONContent(response).tryParse();\n        } catch (error) {\n            return {\n                error: 'Invalid JSON response',\n                data: response,\n                details: 'The response from the model is not a valid JSON object. Please check the model output and try again.',\n            };\n        }\n    }\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        throw new Error('This model does not support tools');\n    }\n\n    public prepareInputMessageBlocks({\n        messageBlock,\n        toolsData,\n    }: {\n        messageBlock: LLMMessageBlock;\n        toolsData: ToolData[];\n    }): LLMToolResultMessageBlock[] {\n        throw new Error('This model does not support tools');\n    }\n\n    public hasSystemMessage(messages: any) {\n        if (!Array.isArray(messages)) return false;\n\n        return messages?.some((message) => message.role === 'system');\n    }\n\n    public separateSystemMessages(messages: LLMMessageBlock[]): {\n        systemMessage: LLMMessageBlock | {};\n        otherMessages: LLMMessageBlock[];\n    } {\n        const systemMessage = messages.find((message) => message.role === 'system' && message.content) || {};\n        const otherMessages = messages.filter((message) => message.role !== 'system' && message.content);\n\n        return { systemMessage, otherMessages };\n    }\n}\n\n// Function to calculate tokens from image\nfunction _countImageTokens(width: number, height: number, detailMode: string = 'auto') {\n    if (detailMode === 'low') return 85;\n\n    const maxDimension = Math.max(width, height);\n    const minDimension = Math.min(width, height);\n    let scaledMinDimension = minDimension;\n\n    if (maxDimension > 2048) {\n        scaledMinDimension = (2048 / maxDimension) * minDimension;\n    }\n\n    scaledMinDimension = Math.floor((768 / 1024) * scaledMinDimension);\n\n    let tileSize = 512;\n    let tiles = Math.ceil(scaledMinDimension / tileSize);\n    if (minDimension !== scaledMinDimension) {\n        tiles *= Math.ceil((scaledMinDimension * (maxDimension / minDimension)) / tileSize);\n    }\n\n    return tiles * 170 + 85;\n}\n\nasync function _getImageDimensions(url: string): Promise<{ width: number; height: number }> {\n    try {\n        let buffer: Buffer;\n\n        if (isDataUrl(url)) {\n            const base64Data = url.replace(/^data:image\\/\\w+;base64,/, '');\n\n            // Create a buffer from the base64-encoded string\n            buffer = Buffer.from(base64Data, 'base64');\n        } else if (isUrl(url)) {\n            const response = await axios.get(url, { responseType: 'arraybuffer' });\n\n            // Convert the response to a buffer\n            buffer = Buffer.from(response.data);\n        } else {\n            throw new Error('Please provide a valid image url!');\n        }\n\n        // Use the imageSize module to get the dimensions\n        const dimensions = imageSize(buffer);\n\n        return {\n            width: dimensions?.width || 0,\n            height: dimensions?.height || 0,\n        };\n    } catch (error) {\n        console.error('Error getting image dimensions', error);\n\n        throw new Error('Please provide a valid image url!');\n    }\n}\n","import { JSONContent } from '@sre/helpers/JsonContent.helper';\nimport { LLMChatResponse, LLMConnector } from '../LLMConnector';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport EventEmitter from 'events';\nimport { Readable } from 'stream';\n\nexport class EchoConnector extends LLMConnector {\n    public name = 'LLM:Echo';\n    protected async chatRequest(acRequest: AccessRequest, prompt, params): Promise<LLMChatResponse> {\n        return { content: prompt, finishReason: 'stop' } as LLMChatResponse;\n    }\n    protected async visionRequest(acRequest: AccessRequest, prompt, params) {\n        return { content: prompt, finishReason: 'stop' } as LLMChatResponse;\n    }\n    protected async toolRequest(acRequest: AccessRequest, params) {\n        throw new Error('Echo model does not support tool requests');\n    }\n    protected async streamToolRequest(acRequest: AccessRequest, params) {\n        throw new Error('Echo model does not support tool requests');\n    }\n    protected async streamRequest(acRequest: AccessRequest, params: any): Promise<Readable> {\n        throw new Error('Echo model does not support streaming');\n    }\n\n    public enhancePrompt(prompt: string, config: any) {\n        //Echo model does not require enhancements, because we are just echoing the prompt as is.\n        return prompt;\n    }\n\n    public postProcess(response: any) {\n        try {\n            return JSONContent(response).tryParse();\n        } catch (error) {\n            return response;\n        }\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { TOOL_USE_DEFAULT_MODEL } from '@sre/constants';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { LLMParams, ToolData, LLMMessageBlock, LLMToolResultMessageBlock } from '@sre/types/LLM.types';\nimport { encodeChat } from 'gpt-tokenizer';\nimport OpenAI from 'openai';\nimport { LLMChatResponse, LLMConnector, LLMStream } from '../LLMConnector';\nimport EventEmitter from 'events';\nimport { delay } from '@sre/utils/date-time.utils';\nimport { Readable } from 'stream';\n\nconst console = Logger('OpenAIConnector');\n\nexport class OpenAIConnector extends LLMConnector {\n    public name = 'LLM:OpenAI';\n\n    protected async chatRequest(acRequest: AccessRequest, prompt, params): Promise<LLMChatResponse> {\n        // if (!model) model = 'gpt-3.5-turbo';\n\n        //if (!params.model) params.model = 'gpt-4-turbo';\n\n        // Open to take system message with params, if no system message found then force to get JSON response in default\n        if (!params.messages) params.messages = [];\n\n        //FIXME: We probably need to separate the json system from default chatRequest\n        if (params.messages[0]?.role !== 'system') {\n            params.messages.unshift({\n                role: 'system',\n                content: 'All responses should be in valid json format. The returned json should not be formatted with any newlines or indentations.',\n            });\n\n            if (params.model.startsWith('gpt-4-turbo') || params.model.startsWith('gpt-3.5-turbo')) {\n                params.response_format = { type: 'json_object' };\n            }\n        }\n\n        if (prompt && params.messages.length === 1) {\n            params.messages.push({ role: 'user', content: prompt });\n        }\n        delete params.prompt;\n\n        // Check if the team has their own API key, then use it\n        const apiKey = params?.apiKey;\n        delete params.apiKey; // Remove apiKey from params\n\n        const openai = new OpenAI({\n            //FIXME: use config.env instead of process.env\n            apiKey: apiKey || process.env.OPENAI_API_KEY,\n        });\n\n        // Check token limit\n        const promptTokens = encodeChat(params.messages, 'gpt-4')?.length;\n\n        const tokensLimit = this.checkTokensLimit({\n            model: params.model,\n            promptTokens,\n            completionTokens: params?.max_tokens,\n            hasTeamAPIKey: !!apiKey,\n        });\n\n        if (tokensLimit.isExceeded) throw new Error(tokensLimit.error);\n\n        const response: any = await openai.chat.completions.create(params as OpenAI.ChatCompletionCreateParamsNonStreaming);\n\n        const content = response?.choices?.[0]?.message.content;\n\n        return { content, finishReason: response?.choices?.[0]?.finish_reason };\n    }\n    protected async visionRequest(acRequest: AccessRequest, prompt, params, agent?: string | Agent) {\n        //if (!params.model) params.model = 'gpt-4-vision-preview';\n\n        // Open to take system message with params, if no system message found then force to get JSON response in default\n        if (!params.messages || params.messages?.length === 0) params.messages = [];\n        if (params.messages?.role !== 'system') {\n            params.messages.unshift({\n                role: 'system',\n                content:\n                    'All responses should be in valid json format. The returned json should not be formatted with any newlines, indentations. For example: {\"<guess key from response>\":\"<response>\"}',\n            });\n        }\n\n        const sources: BinaryInput[] = params?.sources || [];\n        delete params?.sources; // Remove images from params\n\n        //const imageData = await prepareImageData(sources, 'OpenAI', agent);\n\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        const imageData = [];\n        for (let source of sources) {\n            const bufferData = await source.readData(AccessCandidate.agent(agentId));\n            const base64Data = bufferData.toString('base64');\n            const url = `data:${source.mimetype};base64,${base64Data}`;\n            imageData.push({\n                type: 'image_url',\n                image_url: {\n                    url,\n                },\n            });\n        }\n\n        // Add user message\n        const promptData = [{ type: 'text', text: prompt }, ...imageData];\n        params.messages.push({ role: 'user', content: promptData });\n\n        try {\n            // Check if the team has their own API key, then use it\n            const apiKey = params?.apiKey;\n            delete params.apiKey; // Remove apiKey from params\n\n            const openai = new OpenAI({\n                apiKey: apiKey || process.env.OPENAI_API_KEY,\n            });\n\n            // Check token limit\n            const promptTokens = await this.countVisionPromptTokens(promptData);\n\n            const tokenLimit = this.checkTokensLimit({\n                model: params.model,\n                promptTokens,\n                completionTokens: params?.max_tokens,\n                hasTeamAPIKey: !!apiKey,\n            });\n\n            if (tokenLimit.isExceeded) throw new Error(tokenLimit.error);\n\n            const response: any = await openai.chat.completions.create({ ...params });\n\n            const content = response?.choices?.[0]?.message.content;\n\n            return { content, finishReason: response?.choices?.[0]?.finish_reason };\n        } catch (error) {\n            console.log('Error in visionLLMRequest: ', error);\n\n            throw error;\n        }\n    }\n\n    protected async toolRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, max_tokens, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<any> {\n        try {\n            // We provide\n            const openai = new OpenAI({\n                apiKey: apiKey || process.env.OPENAI_API_KEY,\n            });\n\n            // sanity check\n            if (!Array.isArray(messages) || !messages?.length) {\n                return { error: new Error('Invalid messages argument for chat completion.') };\n            }\n\n            let args: OpenAI.ChatCompletionCreateParamsNonStreaming = {\n                model,\n                messages,\n                max_tokens,\n            };\n\n            if (tools && tools.length > 0) args.tools = tools;\n            if (tool_choice) args.tool_choice = tool_choice;\n\n            const result = await openai.chat.completions.create(args);\n            const message = result?.choices?.[0]?.message;\n            const finishReason = result?.choices?.[0]?.finish_reason;\n\n            let toolsData: ToolData[] = [];\n            let useTool = false;\n\n            if (finishReason === 'tool_calls') {\n                toolsData =\n                    message?.tool_calls?.map((tool, index) => ({\n                        index,\n                        id: tool?.id,\n                        type: tool?.type,\n                        name: tool?.function?.name,\n                        arguments: tool?.function?.arguments,\n                        role: 'tool',\n                    })) || [];\n\n                useTool = true;\n            }\n\n            return {\n                data: { useTool, message: message, content: message?.content ?? '', toolsData },\n            };\n        } catch (error: any) {\n            console.log('Error on toolUseLLMRequest: ', error);\n            return { error };\n        }\n    }\n\n    protected async streamToolRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<any> {\n        try {\n            // We provide\n            const openai = new OpenAI({\n                apiKey: apiKey || process.env.OPENAI_API_KEY,\n            });\n\n            // sanity check\n            if (!Array.isArray(messages) || !messages?.length) {\n                return { error: new Error('Invalid messages argument for chat completion.') };\n            }\n\n            console.log('model', model);\n            console.log('messages', messages);\n            let args: OpenAI.ChatCompletionCreateParamsStreaming = {\n                model,\n                messages,\n                stream: true,\n            };\n\n            if (tools && tools.length > 0) args.tools = tools;\n            if (tool_choice) args.tool_choice = tool_choice;\n\n            const stream: any = await openai.chat.completions.create(args);\n\n            // consumed stream will not be available for further use, so we need to clone it\n            const [toolCallsStream, contentStream] = stream.tee();\n\n            let useTool = false;\n            let delta: Record<string, any> = {};\n            let toolsData: ToolData[] = [];\n            let _stream;\n\n            let message = {\n                role: '',\n                content: '',\n                tool_calls: [],\n            };\n\n            for await (const part of toolCallsStream) {\n                delta = part.choices[0].delta;\n\n                message.role += delta?.role || '';\n                message.content += delta?.content || '';\n\n                //if it's not a tools call, stop processing the stream immediately in order to allow streaming the text content\n                //FIXME: OpenAI API returns empty content as first message for content reply, and null content for tool reply,\n                //       this doesn't seem to be a very accurate way but it's the only solution to detect tool calls early enough (without reading the whole stream)\n                if (!delta?.tool_calls && delta?.content === '') {\n                    _stream = contentStream;\n                    break;\n                }\n                //_stream = toolCallsStream;\n                if (delta?.tool_calls) {\n                    const toolCall = delta?.tool_calls?.[0];\n                    const index = toolCall?.index;\n\n                    toolsData[index] = {\n                        index,\n                        role: 'tool',\n                        id: (toolsData?.[index]?.id || '') + (toolCall?.id || ''),\n                        type: (toolsData?.[index]?.type || '') + (toolCall?.type || ''),\n                        name: (toolsData?.[index]?.name || '') + (toolCall?.function?.name || ''),\n                        arguments: (toolsData?.[index]?.arguments || '') + (toolCall?.function?.arguments || ''),\n                    };\n                }\n            }\n\n            if (toolsData?.length > 0) {\n                useTool = true;\n            }\n\n            message.tool_calls = toolsData.map((tool) => {\n                return {\n                    id: tool.id,\n                    type: tool.type,\n                    function: {\n                        name: tool.name,\n                        arguments: tool.arguments,\n                    },\n                };\n            });\n\n            //console.log('result', useTool, message, toolsData);\n\n            return {\n                data: { useTool, message, stream: _stream, toolsData },\n            };\n        } catch (error: any) {\n            console.log('Error on toolUseLLMRequest: ', error);\n            return { error };\n        }\n    }\n\n    // protected async stremRequest(\n    //     acRequest: AccessRequest,\n    //     { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    // ): Promise<Readable> {\n    //     const stream = new LLMStream();\n\n    //     const openai = new OpenAI({\n    //         apiKey: apiKey || process.env.OPENAI_API_KEY,\n    //     });\n\n    //     console.log('model', model);\n    //     console.log('messages', messages);\n\n    //     let args: OpenAI.ChatCompletionCreateParamsStreaming = {\n    //         model,\n    //         messages,\n    //         stream: true,\n    //     };\n\n    //     if (tools && tools.length > 0) args.tools = tools;\n    //     if (tool_choice) args.tool_choice = tool_choice;\n\n    //     const openaiStream: any = await openai.chat.completions.create(args);\n\n    //     let toolsData: any = [];\n    //     stream.enqueueData({ start: true });\n    //     (async () => {\n    //         for await (const part of openaiStream) {\n    //             const delta = part.choices[0].delta;\n    //             //stream.enqueueData(delta);\n\n    //             if (!delta?.tool_calls && delta?.content) {\n    //                 stream.enqueueData({ content: delta.content, role: delta.role });\n    //             }\n\n    //             if (delta?.tool_calls) {\n    //                 const toolCall = delta.tool_calls[0];\n    //                 const index = toolCall.index;\n\n    //                 toolsData[index] = {\n    //                     index,\n    //                     role: 'tool',\n    //                     id: (toolsData[index]?.id || '') + (toolCall?.id || ''),\n    //                     type: (toolsData[index]?.type || '') + (toolCall?.type || ''),\n    //                     name: (toolsData[index]?.name || '') + (toolCall?.function?.name || ''),\n    //                     arguments: (toolsData[index]?.arguments || '') + (toolCall?.function?.arguments || ''),\n    //                 };\n    //             }\n    //         }\n\n    //         stream.enqueueData({ toolsData });\n    //         //stream.endStream();\n    //     })();\n\n    //     return stream;\n    // }\n\n    protected async streamRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, max_tokens, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<EventEmitter> {\n        const emitter = new EventEmitter();\n        const openai = new OpenAI({\n            apiKey: apiKey || process.env.OPENAI_API_KEY,\n        });\n\n        //TODO: check token limits for non api key users\n        console.log('model', model);\n        console.log('messages', messages);\n        let args: OpenAI.ChatCompletionCreateParamsStreaming = {\n            model,\n            messages,\n            max_tokens,\n            stream: true,\n        };\n\n        if (tools && tools.length > 0) args.tools = tools;\n        if (tool_choice) args.tool_choice = tool_choice;\n        const stream: any = await openai.chat.completions.create(args);\n\n        (async () => {\n            let delta: Record<string, any> = {};\n\n            let toolsData: any = [];\n\n            for await (const part of stream) {\n                delta = part.choices[0].delta;\n                emitter.emit('data', delta);\n\n                if (!delta?.tool_calls && delta?.content) {\n                    emitter.emit('content', delta?.content, delta?.role);\n                }\n                //_stream = toolCallsStream;\n                if (delta?.tool_calls) {\n                    const toolCall = delta?.tool_calls?.[0];\n                    const index = toolCall?.index;\n\n                    toolsData[index] = {\n                        index,\n                        role: 'tool',\n                        id: (toolsData?.[index]?.id || '') + (toolCall?.id || ''),\n                        type: (toolsData?.[index]?.type || '') + (toolCall?.type || ''),\n                        name: (toolsData?.[index]?.name || '') + (toolCall?.function?.name || ''),\n                        arguments: (toolsData?.[index]?.arguments || '') + (toolCall?.function?.arguments || ''),\n                    };\n                }\n            }\n            if (toolsData?.length > 0) {\n                emitter.emit('toolsData', toolsData);\n            }\n\n            setTimeout(() => {\n                emitter.emit('end', toolsData);\n            }, 100);\n        })();\n        return emitter;\n    }\n\n    public async extractVisionLLMParams(config: any) {\n        const params: LLMParams = await super.extractVisionLLMParams(config);\n\n        return params;\n    }\n\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        let tools: OpenAI.ChatCompletionTool[] = [];\n\n        if (type === 'function') {\n            tools = toolDefinitions.map((tool) => {\n                const { name, description, properties, requiredFields } = tool;\n\n                return {\n                    type: 'function',\n                    function: {\n                        name,\n                        description,\n                        parameters: {\n                            type: 'object',\n                            properties,\n                            required: requiredFields,\n                        },\n                    },\n                };\n            });\n        }\n\n        return tools?.length > 0 ? { tools, tool_choice: toolChoice || 'auto' } : {};\n    }\n\n    public prepareInputMessageBlocks({\n        messageBlock,\n        toolsData,\n    }: {\n        messageBlock: LLMMessageBlock;\n        toolsData: ToolData[];\n    }): LLMToolResultMessageBlock[] {\n        const messageBlocks: LLMToolResultMessageBlock[] = [];\n\n        if (messageBlock) {\n            const transformedMessageBlock = {\n                ...messageBlock,\n                content: typeof messageBlock.content === 'object' ? JSON.stringify(messageBlock.content) : messageBlock.content,\n            };\n            messageBlocks.push(transformedMessageBlock);\n        }\n\n        const transformedToolsData = toolsData.map((toolData) => ({\n            tool_call_id: toolData.id,\n            role: toolData.role,\n            name: toolData.name,\n            content: typeof toolData.result === 'string' ? toolData.result : JSON.stringify(toolData.result), // Ensure content is a string\n        }));\n\n        return [...messageBlocks, ...transformedToolsData];\n    }\n}\n","import os from 'os';\nimport path from 'path';\nimport EventEmitter from 'events';\nimport fs from 'fs';\n\nimport axios from 'axios';\nimport { GoogleGenerativeAI } from '@google/generative-ai';\nimport { GoogleAIFileManager, FileState } from '@google/generative-ai/server';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { TOOL_USE_DEFAULT_MODEL, JSON_RESPONSE_INSTRUCTION } from '@sre/constants';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\n\nimport { processWithConcurrencyLimit, isDataUrl, isUrl, getMimeTypeFromUrl, isRawBase64, parseBase64, isValidString } from '@sre/utils';\n\nimport { LLMParams, LLMMessageBlock } from '@sre/types/LLM.types';\nimport { IAccessCandidate } from '@sre/types/ACL.types';\n\nimport { LLMChatResponse, LLMConnector } from '../LLMConnector';\n\nconst console = Logger('GoogleAIConnector');\n\ntype FileObject = {\n    url: string;\n    mimetype: string;\n};\n\nconst DEFAULT_MODEL = 'gemini-pro';\n\nconst MODELS_WITH_SYSTEM_MESSAGE = [\n    'gemini-1.5-pro-latest',\n    'gemini-1.5-pro',\n    'gemini-1.5-pro-001',\n    'gemini-1.5-flash-latest',\n    'gemini-1.5-flash',\n    'gemini-1.5-flash-001',\n];\nconst MODELS_WITH_JSON_RESPONSE = MODELS_WITH_SYSTEM_MESSAGE;\n\n// Supported file MIME types for Google AI's Gemini models\nconst VALID_MIME_TYPES = [\n    'video/mp4',\n    'video/mpeg',\n    'video/mov',\n    'video/avi',\n    'video/x-flv',\n    'video/mpg',\n    'video/webm',\n    'video/wmv',\n    'video/3gpp',\n    'image/png',\n    'image/jpeg',\n    'image/jpg',\n    'image/webp',\n    'image/heic',\n    'image/heif',\n    'audio/wav',\n    'audio/mp3',\n    'audio/aiff',\n    'audio/aac',\n    'audio/ogg',\n    'audio/flac',\n    'text/plain',\n    'text/html',\n    'text/css',\n    'text/javascript',\n    'application/x-javascript',\n    'text/x-typescript',\n    'application/x-typescript',\n    'text/csv',\n    'text/markdown',\n    'text/x-python',\n    'application/x-python-code',\n    'application/json',\n    'text/xml',\n    'application/rtf',\n    'text/rtf',\n];\n\n// Supported image MIME types for Google AI's Gemini models\nconst VALID_IMAGE_MIME_TYPES = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp', 'image/heic', 'image/heif'];\n\nexport type GetGenerativeModelArgs = {\n    model: string;\n    generationConfig: {\n        stopSequences: string[];\n        candidateCount: number;\n        maxOutputTokens: number;\n        temperature: number;\n        topP: number;\n        topK: number;\n    };\n    systemInstruction?: string;\n};\nexport class GoogleAIConnector extends LLMConnector {\n    public name = 'LLM:GoogleAI';\n\n    private validMimeTypes = VALID_MIME_TYPES;\n    private validImageMimeTypes = VALID_IMAGE_MIME_TYPES;\n\n    protected async chatRequest(acRequest: AccessRequest, prompt, params): Promise<LLMChatResponse> {\n        try {\n            const model = params?.model || DEFAULT_MODEL;\n\n            const apiKey = params?.apiKey;\n\n            const genAI = new GoogleGenerativeAI(apiKey || process.env.GOOGLEAI_API_KEY);\n\n            let messages = params?.messages || [];\n\n            let systemInstruction;\n            let systemMessage: LLMMessageBlock | {} = {};\n\n            if (this.hasSystemMessage(params?.messages)) {\n                const separateMessages = this.separateSystemMessages(messages);\n                systemMessage = separateMessages.systemMessage;\n                messages = separateMessages.otherMessages;\n            }\n\n            if (MODELS_WITH_SYSTEM_MESSAGE.includes(model)) {\n                systemInstruction = (systemMessage as LLMMessageBlock)?.content || '';\n            } else {\n                prompt = `${prompt}\\n${(systemMessage as LLMMessageBlock)?.content || ''}`;\n            }\n\n            if (params?.messages) {\n                // Concatenate messages with prompt and remove messages from params as it's not supported\n                prompt = params.messages.map((message) => message?.content || '').join('\\n');\n            }\n\n            // Need to return JSON for LLM Prompt component\n            const responseFormat = params?.responseFormat || 'json';\n            if (responseFormat === 'json') {\n                if (MODELS_WITH_JSON_RESPONSE.includes(model)) params.responseMimeType = 'application/json';\n                else prompt += JSON_RESPONSE_INSTRUCTION;\n            }\n\n            if (!prompt) throw new Error('Prompt is required!');\n\n            const args: GetGenerativeModelArgs = {\n                model,\n                generationConfig: params,\n            };\n\n            if (systemInstruction) args.systemInstruction = systemInstruction;\n\n            const generationConfig = {\n                stopSequences: params.stopSequences,\n                maxOutputTokens: params.maxOutputTokens,\n                temperature: params.temperature,\n                topP: params.topP,\n                topK: params.topK,\n            };\n\n            const $model = genAI.getGenerativeModel({\n                model,\n                systemInstruction,\n                generationConfig,\n            });\n\n            // Check token limit\n            const { totalTokens: promptTokens } = await $model.countTokens(prompt);\n\n            // * the function will throw an error if the token limit is exceeded\n            this.validateTokensLimit({\n                model,\n                promptTokens,\n                completionTokens: params?.maxOutputTokens,\n                hasTeamAPIKey: !!apiKey,\n            });\n\n            const result = await $model.generateContent(prompt);\n            const response = await result?.response;\n            const content = response?.text();\n            const finishReason = response.candidates[0].finishReason;\n\n            return { content, finishReason };\n        } catch (error) {\n            console.error('Error in googleAI componentLLMRequest', error);\n\n            throw error;\n        }\n    }\n\n    protected async visionRequest(acRequest: AccessRequest, prompt, params, agent?: string | Agent) {\n        try {\n            const model = params?.model || 'gemini-pro-vision';\n\n            const apiKey = params?.apiKey;\n\n            const fileSources = params?.fileSources || [];\n\n            const agentId = agent instanceof Agent ? agent.id : agent;\n            const agentCandidate = AccessCandidate.agent(agentId);\n\n            const validFiles = await this.processValidFiles(fileSources, agentCandidate);\n\n            const fileUploadingTasks = validFiles.map((file) => async () => {\n                try {\n                    const uploadedFile = await this.uploadFile({ file, apiKey });\n\n                    return { url: uploadedFile.url, mimetype: file.mimetype };\n                } catch {\n                    return null;\n                }\n            });\n\n            const uploadedFiles = await processWithConcurrencyLimit(fileUploadingTasks);\n\n            // We throw error when there are no valid uploaded files,\n            if (uploadedFiles?.length === 0) {\n                throw new Error(\n                    `Unsupported file(s). Please make sure your file is one of the following types: ${this.validImageMimeTypes.join(', ')}`\n                );\n            }\n\n            const fileDataObjectsArray = uploadedFiles.map((file: FileObject) => ({\n                fileData: {\n                    mimeType: file.mimetype,\n                    fileUri: file.url,\n                },\n            }));\n\n            // Adjust input structure handling for multiple image files to accommodate variations.\n            const promptWithFiles =\n                fileDataObjectsArray.length === 1 ? [...fileDataObjectsArray, { text: prompt }] : [prompt, ...fileDataObjectsArray];\n\n            const generationConfig = {\n                stopSequences: params.stopSequences,\n                maxOutputTokens: params.maxOutputTokens,\n                temperature: params.temperature,\n                topP: params.topP,\n                topK: params.topK,\n            };\n\n            const genAI = new GoogleGenerativeAI(apiKey || process.env.GOOGLEAI_API_KEY);\n            const $model = genAI.getGenerativeModel({ model, generationConfig });\n\n            const responseFormat = params?.responseFormat || 'json';\n            if (responseFormat) {\n                if (MODELS_WITH_JSON_RESPONSE.includes(model)) params.responseMimeType = 'application/json';\n                else prompt += JSON_RESPONSE_INSTRUCTION;\n            }\n\n            // Check token limit\n            const { totalTokens: promptTokens } = await $model.countTokens(promptWithFiles);\n\n            // * the function will throw an error if the token limit is exceeded\n            this.validateTokensLimit({\n                model,\n                promptTokens,\n                completionTokens: params?.maxOutputTokens,\n                hasTeamAPIKey: !!apiKey,\n            });\n\n            const result = await $model.generateContent(promptWithFiles);\n            const response = await result?.response;\n            const content = response?.text();\n            const finishReason = response.candidates[0].finishReason;\n\n            return { content, finishReason };\n        } catch (error) {\n            console.error('Error in googleAI visionLLMRequest', error);\n\n            throw error;\n        }\n    }\n\n    // TODO: Need to implement tool request with Google AI, not implemented in the SaaS app as well\n    protected async toolRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<any> {\n        try {\n            throw new Error('Tools are not yet implemented for Google AI.');\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    // TODO: Need to implement tool request with Google AI, not implemented in the SaaS app as well\n    protected async streamToolRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<any> {\n        try {\n            throw new Error('Tools are not yet implemented for Google AI.');\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    protected async streamRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<EventEmitter> {\n        try {\n            throw new Error('Tools are not yet implemented for Google AI.');\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async extractVisionLLMParams(config: any) {\n        const params: LLMParams = await super.extractVisionLLMParams(config);\n\n        return params;\n    }\n\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        const allowFunctionNames: string[] = [];\n        const functionDeclarations = toolDefinitions.map((item) => {\n            const { name, description, properties, requiredFields } = item;\n\n            allowFunctionNames.push(name);\n\n            return {\n                name,\n                description,\n                parameters: {\n                    type: 'OBJECT',\n                    properties,\n                    required: requiredFields,\n                },\n            };\n        });\n\n        const tools = [\n            {\n                function_declarations: functionDeclarations,\n            },\n        ];\n\n        const toolConfig = {\n            function_calling_config: {\n                mode: toolChoice || 'AUTO',\n                allowed_function_names: allowFunctionNames,\n            },\n        };\n\n        return {\n            tools,\n            tool_config: toolConfig,\n        };\n    }\n\n    private async processValidFiles(fileSources: string[] | Record<string, any>[], candidate: IAccessCandidate): Promise<FileObject[]> {\n        const fileProcessingTasks = fileSources.map((fileSource) => async (): Promise<FileObject> => {\n            if (!fileSource) return null;\n\n            if (typeof fileSource === 'object' && fileSource.url && fileSource.mimetype) {\n                return await this.processObjectFileSource(fileSource);\n            }\n\n            if (isValidString(fileSource as string)) {\n                return await this.processStringFileSource(fileSource as string, candidate);\n            }\n\n            return null;\n        });\n\n        const validFiles = await processWithConcurrencyLimit(fileProcessingTasks);\n\n        return validFiles as FileObject[];\n    }\n\n    private processObjectFileSource(fileSource: Record<string, string>) {\n        const { mimetype, url } = fileSource as Record<string, any>;\n\n        if (!this.validImageMimeTypes.includes(mimetype)) return null;\n\n        return { url, mimetype };\n    }\n\n    private async processStringFileSource(fileSource: string, candidate: IAccessCandidate): Promise<FileObject | null> {\n        if (isUrl(fileSource)) {\n            const mimetype = await getMimeTypeFromUrl(fileSource);\n            return this.validImageMimeTypes.includes(mimetype) ? { url: fileSource, mimetype } : null;\n        }\n\n        if (isDataUrl(fileSource) || isRawBase64(fileSource)) {\n            const { mimetype } = await parseBase64(fileSource);\n\n            if (!this.validImageMimeTypes.includes(mimetype)) return null;\n\n            const binaryInput = new BinaryInput(fileSource);\n\n            const fileData = await binaryInput.getJsonData(candidate);\n\n            return { url: fileData.url, mimetype };\n        }\n\n        return null;\n    }\n\n    private async uploadFile({ file, apiKey }: { file: FileObject; apiKey: string }): Promise<{ url: string }> {\n        try {\n            if (!apiKey || !file?.url || !file?.mimetype) {\n                throw new Error('Missing required parameters to save file for Google AI!');\n            }\n\n            // Download the file from source URL to a temp directory\n            const tempDir = os.tmpdir();\n            const fileName = path.basename(new URL(file.url).pathname);\n            const tempFilePath = path.join(tempDir, fileName);\n\n            const response = await axios.get(file.url, { responseType: 'stream' });\n\n            const writer = fs.createWriteStream(tempFilePath);\n            response.data.pipe(writer);\n\n            await new Promise((resolve, reject) => {\n                writer.on('finish', resolve);\n                writer.on('error', reject);\n            });\n\n            // Upload the file to the Google File Manager\n            const fileManager = new GoogleAIFileManager(apiKey);\n\n            const uploadResponse = await fileManager.uploadFile(tempFilePath, {\n                mimeType: file.mimetype,\n                displayName: fileName,\n            });\n\n            const name = uploadResponse.file.name;\n\n            // Poll getFile() on a set interval (10 seconds here) to check file state.\n            let uploadedFile = await fileManager.getFile(name);\n            while (uploadedFile.state === FileState.PROCESSING) {\n                process.stdout.write('.');\n                // Sleep for 10 seconds\n                await new Promise((resolve) => setTimeout(resolve, 10_000));\n                // Fetch the file from the API again\n                uploadedFile = await fileManager.getFile(name);\n            }\n\n            if (uploadedFile.state === FileState.FAILED) {\n                throw new Error('File processing failed.');\n            }\n\n            // Clean up temp file\n            fs.unlink(tempFilePath, (err) => {\n                if (err) console.error('Error deleting temp file: ', err);\n            });\n\n            return {\n                url: uploadResponse.file.uri || '',\n            };\n        } catch (error) {\n            throw new Error(`Error uploading file for Google AI ${error.message}`);\n        }\n    }\n}\n","import Anthropic from '@anthropic-ai/sdk';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { JSON_RESPONSE_INSTRUCTION } from '@sre/constants';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { LLMParams, ToolData, LLMMessageBlock, LLMToolResultMessageBlock } from '@sre/types/LLM.types';\nimport { IAccessCandidate } from '@sre/types/ACL.types';\nimport { LLMChatResponse, LLMConnector } from '../LLMConnector';\nimport EventEmitter from 'events';\n\nimport { processWithConcurrencyLimit, isDataUrl, isUrl, getMimeTypeFromUrl, isRawBase64, parseBase64, isValidString } from '@sre/utils';\n\nconst console = Logger('AnthropicAIConnector');\n\ntype FileObject = {\n    base64data: string;\n    mimetype: string;\n};\n\nconst VALID_IMAGE_MIME_TYPES = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp', 'image/gif'];\nconst PREFILL_TEXT_FOR_JSON_RESPONSE = '{';\nconst TOOL_USE_DEFAULT_MODEL = 'claude-3-5-sonnet-20240620';\n\nexport class AnthropicAIConnector extends LLMConnector {\n    public name = 'LLM:AnthropicAI';\n\n    private validImageMimeTypes = VALID_IMAGE_MIME_TYPES;\n\n    protected async chatRequest(acRequest: AccessRequest, prompt, params): Promise<LLMChatResponse> {\n        params.messages = params?.messages || [];\n\n        // set prompt as user message if provided\n        if (prompt) {\n            params.messages.push({\n                role: 'user',\n                content: prompt,\n            });\n        }\n\n        if (this.hasSystemMessage(params.messages)) {\n            // in AnthropicAI we need to provide system message separately\n            const { systemMessage, otherMessages } = this.separateSystemMessages(params.messages);\n\n            params.messages = otherMessages;\n\n            params.system = (systemMessage as LLMMessageBlock)?.content;\n        }\n\n        const responseFormat = params?.responseFormat || 'json';\n        if (responseFormat === 'json') {\n            params.system += JSON_RESPONSE_INSTRUCTION;\n            params.messages.push({ role: 'assistant', content: PREFILL_TEXT_FOR_JSON_RESPONSE });\n        }\n\n        const apiKey = params?.apiKey;\n\n        // We do not provide default API key for claude, so user/team must provide their own API key\n        if (!apiKey) throw new Error('Please provide an API key for AnthropicAI');\n\n        const anthropic = new Anthropic({ apiKey });\n\n        // TODO: implement claude specific token counting to validate token limit\n        // this.validateTokenLimit(params);\n\n        try {\n            const messageCreateArgs = {\n                model: params.model,\n                messages: params.messages,\n                max_tokens: params.max_tokens,\n                temperature: params.temperature,\n                stop_sequences: params.stop_sequences,\n                top_p: params.top_p,\n                top_k: params.top_k,\n            };\n            const response = await anthropic.messages.create(messageCreateArgs);\n            let content = (response.content?.[0] as Anthropic.TextBlock)?.text;\n            const finishReason = response?.stop_reason;\n\n            if (responseFormat === 'json') {\n                content = `${PREFILL_TEXT_FOR_JSON_RESPONSE}${content}`;\n            }\n\n            return { content, finishReason };\n        } catch (error) {\n            console.error('Error in componentLLMRequest in AnthropicAI: ', error);\n\n            if (error instanceof Anthropic.APIError) {\n                throw error;\n            } else {\n                throw new Error('Internal server error! Please try again later or contact support.');\n            }\n        }\n    }\n    protected async visionRequest(acRequest: AccessRequest, prompt, params, agent?: string | Agent) {\n        params.messages = params?.messages || [];\n\n        const fileSources = params?.fileSources || [];\n\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        const agentCandidate = AccessCandidate.agent(agentId);\n\n        const validFiles = await this.processValidFiles(fileSources, agentCandidate);\n\n        if (validFiles?.length === 0) {\n            throw new Error(`Unsupported file(s). Please make sure your file is one of the following types: ${this.validImageMimeTypes.join(', ')}`);\n        }\n\n        const fileObjectsArray = validFiles.map((file) => ({\n            type: 'image',\n            source: {\n                type: 'base64',\n                data: file.base64data,\n                media_type: file.mimetype,\n            },\n        }));\n\n        const content = [{ type: 'text', text: prompt }, ...fileObjectsArray];\n        params.messages.push({ role: 'user', content });\n\n        const responseFormat = params?.responseFormat || 'json';\n        if (responseFormat === 'json') {\n            params.system = JSON_RESPONSE_INSTRUCTION;\n            params.messages.push({ role: 'assistant', content: PREFILL_TEXT_FOR_JSON_RESPONSE });\n        }\n\n        const apiKey = params?.apiKey;\n\n        // We do not provide default API key for claude, so user/team must provide their own API key\n        if (!apiKey) throw new Error('Please provide an API key for AnthropicAI');\n\n        const anthropic = new Anthropic({ apiKey });\n\n        // TODO (Forhad): implement claude specific token counting properly\n        // this.validateTokenLimit(params);\n\n        try {\n            const messageCreateArgs = {\n                model: params.model,\n                messages: params.messages,\n                max_tokens: params.max_tokens,\n                temperature: params.temperature,\n                stop_sequences: params.stop_sequences,\n                top_p: params.top_p,\n                top_k: params.top_k,\n            };\n\n            const response = await anthropic.messages.create(messageCreateArgs);\n            let content = (response?.content?.[0] as Anthropic.TextBlock)?.text;\n            const finishReason = response?.stop_reason;\n\n            if (responseFormat === 'json') {\n                content = `${PREFILL_TEXT_FOR_JSON_RESPONSE}${content}`;\n            }\n\n            return { content, finishReason };\n        } catch (error) {\n            console.error('Error in componentLLMRequest in Calude: ', error);\n\n            if (error instanceof Anthropic.APIError) {\n                throw error;\n            } else {\n                throw new Error('Internal server error! Please try again later or contact support.');\n            }\n        }\n    }\n\n    protected async toolRequest(\n        acRequest: AccessRequest,\n        { model = 'claude-3-opus-20240229', messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<any> {\n        try {\n            // We do not provide default API key for claude, so user/team must provide their own API key\n            if (!apiKey) throw new Error('Please provide an API key for AnthropicAI');\n\n            const anthropic = new Anthropic({ apiKey });\n\n            const messageCreateArgs: Anthropic.MessageCreateParamsNonStreaming = {\n                model,\n                messages: [],\n                // TODO (Forhad): Need to set max dynamically based on the model\n                max_tokens: 4096, // * max token is required\n            };\n\n            if (this.hasSystemMessage(messages)) {\n                // in AnthropicAI we need to provide system message separately\n                const { systemMessage, otherMessages } = this.separateSystemMessages(messages);\n\n                messageCreateArgs.system = ((systemMessage as LLMMessageBlock)?.content as string) || '';\n\n                messageCreateArgs.messages = otherMessages as Anthropic.MessageParam[];\n            }\n\n            if (tools && tools.length > 0) messageCreateArgs.tools = tools;\n\n            // TODO (Forhad): implement claude specific token counting properly\n            // this.validateTokenLimit(params);\n\n            const result = await anthropic.messages.create(messageCreateArgs);\n            const message = {\n                role: result?.role || 'user',\n                content: result?.content || '',\n            };\n            const stopReason = result?.stop_reason;\n\n            let toolsData: ToolData[] = [];\n            let useTool = false;\n\n            if ((stopReason as 'tool_use') === 'tool_use') {\n                const toolUseContentBlocks = result?.content?.filter((c) => (c.type as 'tool_use') === 'tool_use');\n\n                if (toolUseContentBlocks?.length === 0) return;\n\n                message.content = toolUseContentBlocks;\n\n                toolUseContentBlocks.forEach((toolUseBlock: Anthropic.Messages.ToolUseBlock, index) => {\n                    toolsData.push({\n                        index,\n                        id: toolUseBlock?.id,\n                        type: 'function', // We call API only when the tool type is 'function' in `src/helpers/Conversation.helper.ts`. Even though Anthropic AI returns the type as 'tool_use', it should be interpreted as 'function'.\n                        name: toolUseBlock?.name,\n                        arguments: toolUseBlock?.input,\n                        role: 'user',\n                    });\n                });\n\n                useTool = true;\n            }\n\n            const content = (result?.content?.[0] as Anthropic.TextBlock)?.text;\n\n            return {\n                data: {\n                    useTool,\n                    message,\n                    content,\n                    toolsData,\n                },\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    // ! DEPRECATED METHOD\n    protected async streamToolRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<any> {\n        throw new Error('streamToolRequest() is Deprecated!');\n    }\n\n    protected async streamRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<EventEmitter> {\n        try {\n            const emitter = new EventEmitter();\n\n            // We do not provide default API key for claude, so user/team must provide their own API key\n            if (!apiKey) throw new Error('Please provide an API key for AnthropicAI');\n\n            const anthropic = new Anthropic({ apiKey });\n\n            const messageCreateArgs: Anthropic.Messages.MessageStreamParams = {\n                model,\n                messages: [],\n                // TODO (Forhad): Need to set max dynamically based on the model\n                max_tokens: 4096, // * max token is required\n            };\n\n            if (this.hasSystemMessage(messages)) {\n                // in Anthropic AI we need to provide system message separately\n                const { systemMessage, otherMessages } = this.separateSystemMessages(messages);\n\n                messageCreateArgs.system = ((systemMessage as LLMMessageBlock)?.content as string) || '';\n\n                messageCreateArgs.messages = this.checkMessagesConsistency(otherMessages as Anthropic.MessageParam[]);\n            } else {\n                messageCreateArgs.messages = this.checkMessagesConsistency(messages);\n            }\n\n            if (tools && tools.length > 0) messageCreateArgs.tools = tools;\n\n            const stream = anthropic.messages.stream(messageCreateArgs);\n\n            stream.on('error', (error) => {\n                emitter.emit('error', error);\n            });\n\n            let toolsData: ToolData[] = [];\n\n            stream.on('text', (text: string) => {\n                emitter.emit('content', text);\n            });\n\n            stream.on('finalMessage', (finalMessage) => {\n                const toolUseContentBlocks = finalMessage?.content?.filter((c) => (c.type as 'tool_use') === 'tool_use');\n\n                if (toolUseContentBlocks?.length > 0) {\n                    toolUseContentBlocks.forEach((toolUseBlock: Anthropic.Messages.ToolUseBlock, index) => {\n                        toolsData.push({\n                            index,\n                            id: toolUseBlock?.id,\n                            type: 'function', // We call API only when the tool type is 'function' in `src/helpers/Conversation.helper.ts`. Even though Anthropic AI returns the type as 'tool_use', it should be interpreted as 'function'.\n                            name: toolUseBlock?.name,\n                            arguments: toolUseBlock?.input,\n                            role: 'user',\n                        });\n                    });\n\n                    emitter.emit('toolsData', toolsData);\n                }\n\n                //only emit enf event after processing the final message\n                setTimeout(() => {\n                    emitter.emit('end', toolsData);\n                }, 100);\n            });\n\n            return emitter;\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    private checkMessagesConsistency(messages: Anthropic.MessageParam[]): Anthropic.MessageParam[] {\n        //handle models specific messages content consistency\n        //   identified case that need to be handled\n\n        if (messages.length <= 0) return messages;\n\n        //[FIXED] - `tool_result` block(s) provided when previous message does not contain any `tool_use` blocks\" (handler)\n        if (messages[0].role === 'user' && Array.isArray(messages[0].content)) {\n            const hasToolResult = messages[0].content.find((content) => content.type === 'tool_result');\n\n            //we found a tool result in the first message, so we need to remove the user message\n            if (hasToolResult) {\n                messages.shift();\n            }\n        }\n\n        //   - Error: 400 {\"type\":\"error\",\"error\":{\"type\":\"invalid_request_error\",\"message\":\"messages: first message must use the \\\"user\\\" role\"}}\n        if (messages[0].role !== 'user') {\n            messages.unshift({ role: 'user', content: 'continue' }); //add an empty user message to keep the consistency\n        }\n\n        return messages;\n    }\n    public async extractVisionLLMParams(config: any) {\n        const params: LLMParams = await super.extractVisionLLMParams(config);\n\n        return params;\n    }\n\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        let tools: {\n            name: string;\n            description: string;\n            input_schema: {\n                type: 'object';\n                properties: Record<string, unknown>;\n                required: string[];\n            };\n        }[] = [];\n\n        if (type === 'function') {\n            tools = toolDefinitions.map((tool) => {\n                const { name, description, properties, requiredFields } = tool;\n\n                return {\n                    name,\n                    description,\n                    input_schema: {\n                        type: 'object',\n                        properties,\n                        required: requiredFields,\n                    },\n                };\n            });\n        }\n\n        return tools?.length > 0 ? { tools } : {};\n    }\n\n    public prepareInputMessageBlocks({\n        messageBlock,\n        toolsData,\n    }: {\n        messageBlock: LLMMessageBlock;\n        toolsData: ToolData[];\n    }): LLMToolResultMessageBlock[] {\n        const messageBlocks: LLMToolResultMessageBlock[] = [];\n\n        if (messageBlock) {\n            const content = [];\n            if (typeof messageBlock.content === 'object') {\n                content.push(messageBlock.content);\n            } else {\n                content.push({ type: 'text', text: messageBlock.content });\n            }\n            if (messageBlock.tool_calls) {\n                const calls = messageBlock.tool_calls.map((toolCall: any) => ({\n                    type: 'tool_use',\n                    id: toolCall.id,\n                    name: toolCall?.function?.name,\n                    input: toolCall?.function?.arguments,\n                }));\n\n                content.push(...calls);\n            }\n\n            // const transformedMessageBlock = {\n            //     role: messageBlock.role,\n            //     content: typeof messageBlock.content === 'object' ?  messageBlock.content : ,\n            //     //...messageBlock,\n            //     //content: typeof messageBlock.content === 'object' ? JSON.stringify(messageBlock.content) : messageBlock.content,\n            // };\n            messageBlocks.push({\n                role: messageBlock.role,\n                content: content,\n            });\n        }\n\n        const transformedToolsData = toolsData.map((toolData) => ({\n            role: 'user',\n            content: [\n                {\n                    type: 'tool_result',\n                    tool_use_id: toolData.id,\n                    content: toolData.result,\n                },\n            ],\n        }));\n\n        return [...messageBlocks, ...transformedToolsData];\n    }\n\n    private async processValidFiles(fileSources: string[] | Record<string, any>[], candidate: IAccessCandidate): Promise<FileObject[]> {\n        const fileProcessingTasks = fileSources.map((fileSource) => async (): Promise<FileObject> => {\n            if (!fileSource) return null;\n\n            if (typeof fileSource === 'object' && fileSource.url && fileSource.mimetype) {\n                return await this.processObjectFileSource(fileSource, candidate);\n            }\n\n            if (isValidString(fileSource as string)) {\n                return await this.processStringFileSource(fileSource as string, candidate);\n            }\n\n            return null;\n        });\n\n        const validFiles = await processWithConcurrencyLimit(fileProcessingTasks);\n\n        return validFiles as FileObject[];\n    }\n\n    private async processObjectFileSource(fileSource: Record<string, string>, candidate: IAccessCandidate): Promise<FileObject | null> {\n        const { mimetype } = fileSource;\n\n        if (!this.validImageMimeTypes.includes(mimetype)) return null;\n\n        const binaryInput = new BinaryInput(fileSource);\n        const base64data = (await binaryInput.getBuffer()).toString('base64');\n\n        return { base64data, mimetype };\n    }\n\n    private async processStringFileSource(fileSource: string, candidate: IAccessCandidate): Promise<FileObject | null> {\n        let mimetype = '';\n\n        if (isUrl(fileSource)) {\n            mimetype = await getMimeTypeFromUrl(fileSource);\n        } else if (isDataUrl(fileSource) || isRawBase64(fileSource)) {\n            const parsedBase64 = await parseBase64(fileSource);\n            mimetype = parsedBase64.mimetype;\n        }\n\n        if (!this.validImageMimeTypes.includes(mimetype)) return null;\n\n        const binaryInput = new BinaryInput(fileSource);\n        const base64data = (await binaryInput.getBuffer()).toString('base64');\n\n        return { base64data, mimetype };\n    }\n}\n","//==[ SRE: LLM ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { EchoConnector } from './connectors/Echo.class';\nimport { OpenAIConnector } from './connectors/OpenAI.class';\nimport { GoogleAIConnector } from './connectors/GoogleAI.class';\nimport { AnthropicAIConnector } from './connectors/AnthropicAI.class';\n\nexport class LLMService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.LLM, 'Echo', EchoConnector);\n        ConnectorService.register(TConnectorService.LLM, 'OpenAI', OpenAIConnector);\n        ConnectorService.register(TConnectorService.LLM, 'GoogleAI', GoogleAIConnector);\n        ConnectorService.register(TConnectorService.LLM, 'AnthropicAI', AnthropicAIConnector);\n    }\n\n    public init() {\n        //auto initialize builting models\n        ConnectorService.init(TConnectorService.LLM, 'Echo');\n        ConnectorService.init(TConnectorService.LLM, 'OpenAI');\n        ConnectorService.init(TConnectorService.LLM, 'GoogleAI');\n        ConnectorService.init(TConnectorService.LLM, 'AnthropicAI');\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IACL, IAccessCandidate, IAccessRequest } from '@sre/types/ACL.types';\nimport { CacheMetadata } from '@sre/types/Cache.types';\n\nexport interface ICacheRequest {\n    get: (key: string) => Promise<any>;\n\n    /**\n     * Set a value in the cache\n     * @param key\n     * @param data\n     * @param acl\n     * @param metadata\n     * @param ttl Cache time to live in seconds\n     * @returns\n     */\n    set: (key: string, data: any, acl?: IACL, metadata?: CacheMetadata, ttl?: number) => Promise<boolean>;\n    delete: (key: string) => Promise<void>;\n    exists: (key: string) => Promise<boolean>;\n\n    getMetadata: (key: string) => Promise<CacheMetadata | undefined>;\n    setMetadata: (key: string, metadata: CacheMetadata) => Promise<void>;\n\n    updateTTL: (key: string, ttl?: number) => Promise<void>;\n    getTTL: (key: string) => Promise<number>;\n\n    getACL: (key: string) => Promise<IACL | undefined>;\n    setACL: (key: string, acl: IACL) => Promise<void>;\n}\n\nexport abstract class CacheConnector extends SecureConnector {\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n    public user(candidate: AccessCandidate): ICacheRequest {\n        return {\n            get: async (key: string) => {\n                return await this.get(candidate.readRequest, key);\n            },\n            set: async (key: string, data: any, acl?: IACL, metadata?: CacheMetadata, ttl?: number) => {\n                return await this.set(candidate.writeRequest, key, data, acl, metadata, ttl);\n            },\n            delete: async (key: string) => {\n                await this.delete(candidate.writeRequest, key);\n            },\n            exists: async (key: string) => {\n                return await this.exists(candidate.readRequest, key);\n            },\n\n            getMetadata: async (key: string) => {\n                return await this.getMetadata(candidate.readRequest, key);\n            },\n            setMetadata: async (key: string, metadata: CacheMetadata) => {\n                await this.setMetadata(candidate.writeRequest, key, metadata);\n            },\n            updateTTL: async (key: string, ttl?: number) => {\n                await this.updateTTL(candidate.writeRequest, key, ttl);\n            },\n            getTTL: async (key: string) => {\n                return await this.getTTL(candidate.readRequest, key);\n            },\n            getACL: async (key: string) => {\n                return await this.getACL(candidate.readRequest, key);\n            },\n            setACL: async (key: string, acl: IACL) => {\n                await this.setACL(candidate.writeRequest, key, acl);\n            },\n        };\n    }\n\n    abstract get(acRequest: AccessRequest, key: string): Promise<any>;\n    abstract set(acRequest: AccessRequest, key: string, data: any, acl?: IACL, metadata?: CacheMetadata, ttl?: number): Promise<boolean>;\n    abstract delete(acRequest: AccessRequest, key: string): Promise<void>;\n    abstract exists(acRequest: AccessRequest, key: string): Promise<boolean>;\n\n    abstract getMetadata(acRequest: AccessRequest, key: string): Promise<CacheMetadata | undefined>;\n    abstract setMetadata(acRequest: AccessRequest, key: string, metadata: CacheMetadata): Promise<void>;\n\n    abstract updateTTL(acRequest: AccessRequest, key: string, ttl?: number): Promise<void>;\n    abstract getTTL(acRequest: AccessRequest, key: string): Promise<number>;\n\n    abstract getACL(acRequest: AccessRequest, key: string): Promise<IACL | undefined>;\n    abstract setACL(acRequest: AccessRequest, key: string, acl: IACL): Promise<void>;\n}\n","import { Logger } from '@sre/helpers/Log.helper';\nimport { IAccessCandidate, IACL, TAccessLevel } from '@sre/types/ACL.types';\nimport { CacheMetadata } from '@sre/types/Cache.types';\nimport IORedis from 'ioredis';\nimport { CacheConnector } from '../CacheConnector';\n\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { RedisConfig } from '@sre/types/Redis.types';\n\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\n\nconst console = Logger('RedisCache');\n\nexport class RedisCache extends CacheConnector {\n    public name: string = 'RedisCache';\n    private redis: IORedis;\n    private _prefix: string = 'smyth:cache';\n    private _mdPrefix: string = 'smyth:metadata';\n    private accountConnector: AccountConnector;\n\n    constructor(settings: RedisConfig) {\n        super();\n        const sentinels = parseSentinelHosts(settings.hosts);\n\n        this.redis = new IORedis({\n            sentinels,\n            name: settings.name,\n            password: settings.password,\n        });\n\n        this.redis.on('error', (error) => {\n            console.error('Redis Error:', error);\n        });\n\n        this.redis.on('connect', () => {\n            console.log('Redis connected!');\n        });\n\n        this.accountConnector = ConnectorService.getAccountConnector();\n    }\n\n    public get client() {\n        return this.redis;\n    }\n\n    public prefix(teamId: string) {\n        return `${this._prefix}:team_${teamId}`;\n    }\n\n    public mdPrefix(teamId: string) {\n        return `${this._mdPrefix}:team_${teamId}`;\n    }\n\n    @SecureConnector.AccessControl\n    public async get(acRequest: AccessRequest, key: string): Promise<string | null> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const value = await this.redis.get(`${this.prefix(teamId)}:${key}`);\n        return value;\n    }\n\n    @SecureConnector.AccessControl\n    public async set(acRequest: AccessRequest, key: string, data: any, acl?: IACL, metadata?: CacheMetadata, ttl?: number): Promise<boolean> {\n        const accessCandidate = acRequest.candidate;\n        const promises: any[] = [];\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n\n        promises.push(this.redis.set(`${this.prefix(teamId)}:${key}`, data));\n\n        const newMetadata: CacheMetadata = metadata || {};\n        newMetadata.acl = ACL.from(acl).addAccess(accessCandidate.role, accessCandidate.id, TAccessLevel.Owner).ACL;\n        promises.push(this.setMetadata(acRequest, key, newMetadata));\n\n        if (ttl) {\n            promises.push(this.updateTTL(acRequest, key, ttl));\n        }\n\n        await Promise.all(promises);\n        return true;\n    }\n\n    @SecureConnector.AccessControl\n    public async delete(acRequest: AccessRequest, key: string): Promise<void> {\n        //delete both the key and its metadata\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        await Promise.all([this.redis.del(`${this.prefix(teamId)}:${key}`), this.redis.del(`${this.mdPrefix(teamId)}:${key}`)]);\n    }\n\n    @SecureConnector.AccessControl\n    public async exists(acRequest: AccessRequest, key: string): Promise<boolean> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        return !!(await this.redis.exists(`${this.prefix(teamId)}:${key}`));\n    }\n\n    @SecureConnector.AccessControl\n    public async getMetadata(acRequest: AccessRequest, key: string): Promise<CacheMetadata> {\n        if (!this.exists(acRequest, key)) return undefined;\n        try {\n            const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n            const metadata = await this.redis.get(`${this.mdPrefix(teamId)}:${key}`);\n            return metadata ? (this.deserializeRedisMetadata(metadata) as CacheMetadata) : {};\n        } catch (error) {\n            return {};\n        }\n    }\n\n    @SecureConnector.AccessControl\n    public async setMetadata(acRequest: AccessRequest, key: string, metadata: CacheMetadata): Promise<void> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        await this.redis.set(`${this.mdPrefix(teamId)}:${key}`, this.serializeRedisMetadata(metadata));\n    }\n\n    @SecureConnector.AccessControl\n    public async updateTTL(acRequest: AccessRequest, key: string, ttl?: number): Promise<void> {\n        if (ttl) {\n            const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n            await Promise.all([this.redis.expire(`${this.prefix(teamId)}:${key}`, ttl), this.redis.expire(`${this.mdPrefix(teamId)}:${key}`, ttl)]);\n        }\n    }\n\n    @SecureConnector.AccessControl\n    public async getTTL(acRequest: AccessRequest, key: string): Promise<number> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        return this.redis.ttl(`${this.prefix(teamId)}:${key}`);\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL> {\n        const teamId = await this.accountConnector.getCandidateTeam(candidate);\n        const _metadata: any = await this.redis.get(`${this.mdPrefix(teamId)}:${resourceId}`).catch((error) => {});\n        const exists = _metadata !== undefined && _metadata !== null; //null or undefined metadata means the resource does not exist\n        const metadata = exists ? this.deserializeRedisMetadata(_metadata) : {};\n\n        if (!exists) {\n            //the resource does not exist yet, we grant write access to the candidate in order to allow the resource creation\n            return new ACL().addAccess(candidate.role, candidate.id, TAccessLevel.Owner);\n        }\n        return ACL.from(metadata?.acl as IACL);\n    }\n\n    // async hasAccess(request: IAccessRequest): Promise<boolean> {\n    //     try {\n    //         const metadata = await this.getMetadata(request.resourceId);\n    //         const acl: IACL = metadata?.acl as IACL;\n    //         return ACL.from(acl).checkExactAccess(request);\n    //     } catch (error) {\n    //         if (error.name === 'NotFound') {\n    //             return false;\n    //         }\n    //         console.error(`Error checking access rights in S3`, error.name, error.message);\n    //         throw error;\n    //     }\n    // }\n\n    @SecureConnector.AccessControl\n    async getACL(acRequest: AccessRequest, key: string): Promise<IACL> {\n        try {\n            const metadata = await this.getMetadata(acRequest, key);\n            return (metadata?.acl as IACL) || {};\n        } catch (error) {\n            console.error(`Error getting access rights in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async setACL(acRequest: AccessRequest, key: string, acl: IACL) {\n        try {\n            let metadata = await this.getMetadata(acRequest, key);\n            if (!metadata) metadata = {};\n            //when setting ACL make sure to not lose ownership\n            metadata.acl = ACL.from(acl).addAccess(acRequest.candidate.role, acRequest.candidate.id, TAccessLevel.Owner).ACL;\n            await this.setMetadata(acRequest, key, metadata);\n        } catch (error) {\n            console.error(`Error setting access rights in S3`, error);\n            throw error;\n        }\n    }\n\n    private serializeRedisMetadata(redisMetadata: Record<string, any> | undefined): string {\n        if (!redisMetadata) return '';\n        if (redisMetadata.acl) {\n            const acl: IACL = redisMetadata.acl;\n            if (acl) {\n                redisMetadata.acl = ACL.from(acl).serializedACL;\n            }\n        }\n\n        return JSON.stringify(redisMetadata);\n    }\n\n    private deserializeRedisMetadata(strMetadata: string): Record<string, any> {\n        try {\n            const redisMetadata = JSON.parse(strMetadata);\n            if (redisMetadata.acl) {\n                const acl: IACL = ACL.from(redisMetadata.acl).ACL;\n                redisMetadata.acl = acl;\n            }\n\n            return redisMetadata;\n        } catch (error) {\n            console.warn(`Error deserializing metadata`, strMetadata);\n            return {};\n        }\n    }\n\n    public async stop() {\n        super.stop();\n        await this.redis.quit();\n    }\n}\n\n/**\n * hosts can take any of the following formats:\n * 1. A string with comma-separated host:port pairs\n * 2. An array of strings with host:port pairs\n * 3. An array of objects with host and port properties\n * @param hosts\n */\nfunction parseSentinelHosts(hosts: string | string[] | any[]) {\n    //handle all possible formats of hosts\n    if (typeof hosts === 'string') {\n        return hosts.split(',').map((host) => {\n            const [hostName, port] = host.split(':');\n            return {\n                host: hostName,\n                port: Number(port),\n            };\n        });\n    } else if (Array.isArray(hosts)) {\n        return hosts.map((host) => {\n            if (typeof host === 'string') {\n                const [hostName, port] = host.split(':');\n                return {\n                    host: hostName,\n                    port: Number(port),\n                };\n            } else {\n                return host;\n            }\n        });\n    } else {\n        return [];\n    }\n}\n","//==[ SRE: Cache ]======================\nexport * from './CacheConnector';\nimport { ConnectorServiceProvider, ConnectorService } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { ICacheConnector } from './CacheConnector';\nimport { RedisCache } from './connectors/RedisCache.class';\n\nexport class CacheService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.Cache, 'Redis', RedisCache);\n    }\n}\n","import { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL } from '@sre/types/ACL.types';\n\nexport interface IVaultRequest {\n    get(keyId: string): Promise<string>;\n    set(keyId: string, value: string): Promise<void>;\n    delete(keyId: string): Promise<void>;\n    exists(keyId: string): Promise<boolean>;\n}\n\nexport abstract class VaultConnector extends SecureConnector {\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n    public abstract user(candidate: AccessCandidate): IVaultRequest;\n    protected abstract get(acRequest: AccessRequest, keyId: string): Promise<string>;\n    protected abstract set(acRequest: AccessRequest, keyId: string, value: string): Promise<void>;\n    protected abstract delete(acRequest: AccessRequest, keyId: string): Promise<void>;\n    protected abstract exists(acRequest: AccessRequest, keyId: string): Promise<boolean>;\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { JSONFileVaultConfig } from '@sre/types/Security.types';\nimport fs from 'fs';\nimport { IVaultRequest, VaultConnector } from '../VaultConnector';\n\nconst console = Logger('JSONFileVault');\nexport class JSONFileVault extends VaultConnector {\n    public name: string = 'JSONFileVault';\n    private vaultData: any;\n    private index: any;\n\n    constructor(private config: JSONFileVaultConfig) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n\n        if (fs.existsSync(config.file)) {\n            try {\n                this.vaultData = JSON.parse(fs.readFileSync(config.file).toString());\n            } catch (e) {\n                this.vaultData = {};\n            }\n\n            for (let teamId in this.vaultData) {\n                for (let resourceId in this.vaultData[teamId]) {\n                    if (!this.index) this.index = {};\n                    if (!this.index[resourceId]) this.index[resourceId] = {};\n                    const value = this.vaultData[teamId][resourceId];\n                    this.index[resourceId][teamId] = value;\n                }\n            }\n        }\n    }\n\n    user(candidate: AccessCandidate): IVaultRequest {\n        return {\n            get: async (keyId: string) => this.get(candidate.readRequest, keyId),\n            set: async (keyId: string, value: string) => this.set(candidate.writeRequest, keyId, value),\n            delete: async (keyId: string) => this.delete(candidate.writeRequest, keyId),\n            exists: async (keyId: string) => this.exists(candidate.readRequest, keyId),\n        };\n    }\n\n    @SecureConnector.AccessControl\n    protected async get(acRequest: AccessRequest, keyId: string) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n\n        return this.vaultData?.[teamId]?.[keyId];\n    }\n\n    @SecureConnector.AccessControl\n    protected async set(acRequest: AccessRequest, keyId: string, value: string) {\n        throw new Error('JSONFileVault.set not allowed');\n    }\n\n    @SecureConnector.AccessControl\n    protected async delete(acRequest: AccessRequest, keyId: string) {\n        throw new Error('JSONFileVault.delete not allowed');\n    }\n\n    @SecureConnector.AccessControl\n    protected async exists(acRequest: AccessRequest, keyId: string) {\n        return false;\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(candidate);\n\n        const acl = new ACL();\n\n        if (!this.vaultData?.[teamId]?.[resourceId]) return acl;\n\n        acl.addAccess(TAccessRole.Team, teamId, TAccessLevel.Owner)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Read)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Write);\n\n        return acl;\n    }\n}\n","import { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { JSONFileVault } from './connectors/JSONFileVault.class';\n\nexport class VaultService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.Vault, 'JSONFileVault', JSONFileVault);\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL, TAccessRole } from '@sre/types/ACL.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\n\nexport abstract class AccountConnector extends Connector {\n    public name = 'Account';\n    public isTeamMember(team: string, candidate: IAccessCandidate): Promise<boolean> {\n        return Promise.resolve(true);\n    }\n    public getCandidateTeam(candidate: IAccessCandidate): Promise<string | undefined> {\n        if (candidate.role === TAccessRole.Team) {\n            return Promise.resolve(candidate.id);\n        }\n\n        return Promise.resolve('default');\n    }\n}\n","//==[ SRE: LLM ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { AccountConnector } from './AccountConnector';\n\nexport class AccountService extends ConnectorServiceProvider {\n    public register() {\n        //FIXME : register an actual account connector, not the abstract one\n        ConnectorService.register(TConnectorService.Account, 'Account', AccountConnector);\n    }\n\n    public init() {\n        //auto initialize builtin account connector\n        ConnectorService.init(TConnectorService.Account, 'Account');\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { IAccessCandidate } from '@sre/types/ACL.types';\nimport config from '@sre/config';\nimport { escapeString, TemplateString } from '@sre/helpers/TemplateString.helper';\n\nexport interface IAgentDataConnector {\n    getAgentData(agentId: string, version?: string): Promise<any>;\n    getAgentIdByDomain(domain: string): Promise<string>;\n    getAgentSettings(agentId: string, version?: string): Promise<any>;\n}\n\nconst openapiTemplate = JSON.stringify({\n    openapi: '3.0.1',\n    info: {\n        title: '{{model_name}}',\n        description: '{{model_description}}',\n        version: '{{version}}',\n    },\n    servers: [\n        {\n            url: '{{server_url}}',\n        },\n    ],\n    paths: {},\n    components: {\n        schemas: {},\n    },\n});\n\nconst openapiEndpointTemplate = JSON.stringify({\n    summary: '{{summary}}',\n    operationId: '{{operationId}}',\n    'x-openai-isConsequential': false,\n    requestBody: {\n        required: true,\n        content: {},\n    },\n    responses: {\n        '200': {\n            description: 'response',\n            content: {\n                'text/plain': {\n                    schema: {\n                        type: 'string',\n                    },\n                },\n            },\n        },\n    },\n});\nexport abstract class AgentDataConnector extends Connector implements IAgentDataConnector {\n    public name = 'AgentDataConnector';\n    public abstract getAgentData(agentId: string, version?: string): Promise<any>;\n    public abstract getAgentIdByDomain(domain: string): Promise<string>;\n    public abstract getAgentSettings(agentId: string, version?: string): Promise<any>;\n    public abstract isDeployed(agentId: string): Promise<boolean>;\n\n    /**\n     * Loads openAPI JSON for the agent\n     * @param source this represents either the agentId or the agent data\n     * @param domain\n     * @param version\n     * @param aiOnly\n     * @returns\n     */\n    public async getOpenAPIJSON(source: string | Record<string, any>, server_url, version, aiOnly: boolean = false) {\n        if (!source) {\n            throw new Error('Agent not found');\n        }\n\n        const apiBasePath = version && version != 'latest' ? `/v${version}/api` : '/api';\n\n        const agentData: any = typeof source === 'object' ? source : await this.getAgentData(source, version);\n        const name = agentData.name;\n\n        let description = aiOnly ? agentData.data.behavior : agentData.data.shortDescription;\n        if (!description) description = agentData.data.description; //data.description is deprecated, we just use it as a fallback for now\n\n        const _version = agentData.data.version || '1.0.0';\n        //replace all non printable characters with spaces\n        //description = description.replace(/[^\\x20-\\x7E]+/g, ' ');\n        //const version = '1.0.0';\n\n        // const server_url_scheme =\n        //     config.env.NODE_ENV === 'DEV' && config.env.AGENT_DOMAIN_PORT && domain.includes(config.env.AGENT_DOMAIN) ? 'http' : 'https';\n        // const server_url_port =\n        //     config.env.NODE_ENV === 'DEV' && config.env.AGENT_DOMAIN_PORT && domain.includes(config.env.AGENT_DOMAIN)\n        //         ? `:${config.env.AGENT_DOMAIN_PORT}`\n        //         : '';\n        // const server_url = `${server_url_scheme}://${domain}${server_url_port}`;\n\n        const openAPITpl = TemplateString(openapiTemplate)\n            .parse({\n                model_name: escapeString(name),\n                model_description: escapeString(description),\n                server_url,\n                version: _version,\n            })\n            .clean().result;\n        const openAPIObj = JSON.parse(openAPITpl);\n\n        const components = agentData.data.components.filter((component: any) => component.name === 'APIEndpoint');\n        for (let component of components) {\n            const ai_exposed = component.data.ai_exposed || typeof component.data.ai_exposed === 'undefined';\n            if (aiOnly && !ai_exposed) continue;\n            let method = (component.data.method || 'post').toLowerCase();\n            let summary = aiOnly ? component.data.description || component.data.doc : component.data.doc || component.data.description;\n\n            const openAPIEntry = JSON.parse(\n                TemplateString(openapiEndpointTemplate)\n                    .parse({\n                        summary,\n                        operationId: component.data.endpoint,\n                    })\n                    .clean().result\n            );\n            if (!openAPIObj.paths[apiBasePath + '/' + component.data.endpoint]) openAPIObj.paths[apiBasePath + '/' + component.data.endpoint] = {};\n            //const componentsSchemas = openAPIObj.components.schemas;\n\n            openAPIObj.paths[apiBasePath + '/' + component.data.endpoint][method] = openAPIEntry;\n\n            if (component.inputs.length > 0) {\n                if (method === 'get') {\n                    delete openAPIEntry.requestBody;\n\n                    openAPIEntry.parameters = [];\n\n                    for (let input of component.inputs) {\n                        const parameter: {\n                            name: string;\n                            in: string;\n                            description: string;\n                            required: boolean;\n                            schema: { type: string };\n                            style?: string;\n                            explode?: boolean;\n                        } = {\n                            name: input.name,\n                            in: 'query',\n                            description: input.description,\n                            required: !input.optional,\n                            schema: getOpenAPIInputSchema(input.type),\n                        };\n\n                        // for array and object types\n                        const { style, explode } = getOpenAPIParameterStyle(input.type);\n                        if (style) {\n                            parameter.style = style;\n                            parameter.explode = explode;\n                        }\n\n                        openAPIEntry.parameters.push(parameter);\n                    }\n                } else {\n                    const requiredProps: any = [];\n\n                    const hasBinaryType = !aiOnly && component.inputs.some((input) => input.type.toLowerCase().trim() === 'binary');\n                    //if it's an AI format, we force application/json format, becauwe we want to receive binary data as a url\n                    const mimetype = hasBinaryType ? 'multipart/form-data' : 'application/json';\n                    openAPIEntry.requestBody.content[mimetype] = {};\n                    for (let input of component.inputs) {\n                        if (!input.optional) requiredProps.push(input.name);\n\n                        if (!openAPIEntry.requestBody.content[mimetype].schema)\n                            openAPIEntry.requestBody.content[mimetype].schema = { type: 'object' };\n\n                        const schema: any = openAPIEntry.requestBody.content[mimetype].schema || {\n                            type: 'object',\n                        };\n\n                        if (!schema.properties) schema.properties = {};\n                        schema.properties[input.name] = {\n                            ...getOpenAPIInputSchema(input.type),\n                            format: !aiOnly && input.type.toLowerCase().trim() === 'binary' ? 'binary' : undefined,\n                            description: input.description,\n                            default: input.defaultVal,\n                        };\n                        schema.required = requiredProps;\n\n                        if (!openAPIEntry.requestBody.content[mimetype].schema) openAPIEntry.requestBody.content['application/json'].schema = schema;\n                    }\n                }\n            } else {\n                delete openAPIEntry.requestBody;\n            }\n        }\n\n        return openAPIObj;\n    }\n}\n\nfunction getOpenAPIInputSchema(input_type) {\n    switch (input_type?.toLowerCase()) {\n        case 'binary':\n        case 'string':\n        case 'any':\n            return { type: 'string' };\n        case 'number':\n        case 'float':\n            return { type: 'number' };\n        case 'integer':\n            return { type: 'integer' };\n        case 'boolean':\n            return { type: 'boolean' };\n        case 'array':\n            return { type: 'array', items: {} };\n        case 'object':\n            return { type: 'object', additionalProperties: {} };\n        default:\n            return { type: 'string' };\n    }\n}\n\nfunction getOpenAPIParameterStyle(input_type) {\n    switch (input_type.toLowerCase()) {\n        case 'array':\n            return {\n                style: 'form',\n                explode: false, // results in `ids=1,2,3`\n            };\n        case 'object':\n            return {\n                style: 'deepObject',\n                explode: true, // results in `lat=value1&long=value2`\n            };\n        default:\n            return { style: '', explode: false };\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { CLIConnector } from '@sre/IO/CLI.service/CLIConnector';\nimport fs from 'fs';\nimport path from 'path';\nimport { AgentDataConnector } from '../AgentDataConnector';\n\ntype TArgs = { args: Record<string, any> };\nexport class CLIAgentDataConnector extends AgentDataConnector {\n    public name: string = 'CLIAgentDataConnector';\n    private argv;\n    constructor(settings: TArgs) {\n        super();\n        this.argv = settings.args || process.argv;\n    }\n    public async getAgentData(agentId: string, version?: string) {\n        const cliConnector: CLIConnector = ConnectorService.getCLIConnector();\n\n        const params: any = cliConnector.get('agent');\n\n        //get current directory\n        const __dirname = fs.realpathSync(process.cwd());\n        const filePath = path.join(__dirname, params.agent);\n\n        if (fs.existsSync(filePath)) {\n            const data = fs.readFileSync(filePath, 'utf8');\n\n            return { data: JSON.parse(data), version: version || '1.0' };\n        }\n    }\n\n    public getAgentIdByDomain(domain: string): Promise<string> {\n        return Promise.resolve('');\n    }\n    public async getAgentSettings(agentId: string, version?: string) {\n        const cliConnector: CLIConnector = ConnectorService.getCLIConnector();\n\n        const params: any = cliConnector.get('settings');\n        let settings: any;\n\n        if (typeof params.settings === 'string') {\n            if (fs.existsSync(params.settings)) {\n                settings = JSON.parse(fs.readFileSync(params.settings, 'utf8'));\n            }\n        } else {\n            settings = params.settings;\n        }\n        return settings;\n    }\n    public async isDeployed(agentId: string): Promise<boolean> {\n        return true;\n    }\n}\n","import fs from 'fs';\nimport path from 'path';\nimport { AgentDataConnector } from '../AgentDataConnector';\nimport { uid } from '@sre/utils/general.utils';\n\nexport type LocalAgentDataSettings = { devDir: string; prodDir: string };\n\n/**\n * This connector loads Agent data and settings from a provided directory, it then indexes the loaded agents and settings by agent IDs.\n * Agent data files should be in JSON format and contain an 'id' field with the agent ID and at least a 'components' field.\n * Settings files should be in JSON format and contain an 'id' field with the agent ID and the settings in a 'settings' field.\n *     'settings' field is a key-value object with the Agent settings.\n */\nexport class LocalAgentDataConnector extends AgentDataConnector {\n    public name: string = 'LocalAgentDataConnector';\n    private devDir;\n    private prodDir;\n    private agentsData = { dev: {}, prod: {} };\n    private agentSettings = { dev: {}, prod: {} };\n\n    constructor(settings: LocalAgentDataSettings) {\n        super();\n        this.devDir = settings.devDir;\n        this.prodDir = settings.prodDir;\n    }\n\n    private indexDir(dir: string) {\n        const agents = fs.readdirSync(dir);\n\n        const agentsData = {};\n        const agentSettings = {};\n        for (const agent of agents) {\n            const agentData = fs.readFileSync(path.join(dir, agent), 'utf8');\n            let jsonData;\n            try {\n                jsonData = JSON.parse(agentData);\n\n                if (!jsonData.id) {\n                    console.warn(`Agent data for ${agent} does not contain an id, generating one...`);\n                    jsonData.id = 'tmp-' + uid();\n                }\n            } catch (e) {\n                console.warn(`Error parsing agent data for ${agent}: ${e.message}`);\n            }\n\n            //is this an agent data file?\n            if (jsonData.components) agentsData[jsonData.id] = jsonData;\n\n            //does this file contain settings?\n            if (jsonData.settings) agentSettings[jsonData.id] = jsonData.settings;\n        }\n\n        return { agentsData, agentSettings };\n    }\n    private indexAgentsData() {\n        const { agentsData: devAgentsData, agentSettings: devAgentSettings } = this.indexDir(this.devDir);\n        const { agentsData: prodAgentsData, agentSettings: prodAgentSettings } = this.indexDir(this.prodDir);\n        this.agentsData = { dev: devAgentsData, prod: prodAgentsData };\n        this.agentSettings = { dev: devAgentSettings, prod: prodAgentSettings };\n    }\n\n    public async start() {\n        super.start();\n        this.started = false;\n        this.indexAgentsData();\n        this.started = true;\n    }\n\n    /**\n     * returns the agent data for the provided agent ID\n     * if the version is not provided, it defaults to the dev version\n     * otherwise it loads the corresponding prod version\n     * @param agentId\n     * @param version\n     * @returns\n     */\n    public async getAgentData(agentId: string, version?: string) {\n        const ready = await this.ready();\n        if (!ready) {\n            throw new Error('Connector not ready');\n        }\n\n        const data = version ? this.agentsData.prod[agentId] : this.agentsData.dev[agentId];\n\n        if (data) {\n            return { data, version: version || '1.0' };\n        } else {\n            throw new Error(`Agent with id ${agentId} not found`);\n        }\n    }\n\n    public getAgentIdByDomain(domain: string): Promise<string> {\n        return Promise.resolve('');\n    }\n\n    /**\n     * returns the agent settings for the provided agent ID\n     * if the version is not provided, it defaults to the dev version\n     * otherwise it loads the corresponding prod version\n     * @param agentId\n     * @param version\n     * @returns\n     */\n    public async getAgentSettings(agentId: string, version?: string) {\n        const ready = await this.ready();\n        if (!ready) {\n            throw new Error('Connector not ready');\n        }\n\n        const settings = version ? this.agentSettings.prod[agentId] : this.agentSettings.dev[agentId];\n\n        if (settings) {\n            return settings;\n        } else {\n            throw new Error(`Settings for agent with id ${agentId} not found`);\n        }\n    }\n\n    public async isDeployed(agentId: string): Promise<boolean> {\n        return !!this.agentsData.prod[agentId];\n    }\n}\n","//==[ SRE: LLM ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { CLIAgentDataConnector } from './connectors/CLIAgentDataConnector.class';\nimport { AgentDataConnector } from './AgentDataConnector';\nimport { LocalAgentDataConnector } from './connectors/LocalAgentDataConnector.class';\n\nexport class AgentDataService extends ConnectorServiceProvider {\n    public register() {\n        //FIXME : register an actual account connector, not the abstract one\n        ConnectorService.register(TConnectorService.AgentData, 'AgentData', AgentDataConnector);\n        ConnectorService.register(TConnectorService.AgentData, 'CLI', CLIAgentDataConnector);\n        ConnectorService.register(TConnectorService.AgentData, 'Local', LocalAgentDataConnector);\n    }\n}\n","import { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL } from '@sre/types/ACL.types';\nimport { IVectorDataSourceDto, QueryOptions, Source, VectorDBMetadata, VectorsResultData } from '@sre/types/VectorDB.types';\nimport { Document } from '@langchain/core/documents';\n\nexport interface IVectorDBRequest {\n    search(namespace: string, query: string | number[], options?: QueryOptions): Promise<VectorsResultData>;\n    insert(namespace: string, source: IVectorDataSourceDto | IVectorDataSourceDto[]): Promise<string[]>;\n    delete(namespace: string, id: string | string[]): Promise<void>;\n    createNamespace(namespace: string): Promise<void>;\n    deleteNamespace(namespace: string): Promise<void>;\n}\n\nexport abstract class VectorDBConnector extends SecureConnector {\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n    public abstract user(candidate: IAccessCandidate): IVectorDBRequest;\n\n    protected abstract search(\n        acRequest: AccessRequest,\n        data: { indexName: string; namespace: string; query: string | number[] },\n        options: QueryOptions\n    ): Promise<VectorsResultData>;\n\n    protected abstract insert(\n        acRequest: AccessRequest,\n        data: {\n            indexName: string;\n            namespace: string;\n            source: IVectorDataSourceDto | IVectorDataSourceDto[];\n        }\n    ): Promise<string[]>;\n\n    protected abstract delete(acRequest: AccessRequest, data: { id: string | string[]; indexName: string; namespace: string }): Promise<void>;\n\n    protected abstract createNamespace(acRequest: AccessRequest, namespace: string, indexName: string): Promise<void>;\n\n    protected abstract deleteNamespace(acRequest: AccessRequest, namespace: string, indexName: string): Promise<void>;\n\n    // protected abstract updateVectors(acRequest: AccessRequest, resourceId: string): Promise<void>;\n\n    // protected abstract getMetadata(acRequest: AccessRequest, resourceId: string): Promise<StorageMetadata | undefined>;\n    // protected abstract setMetadata(acRequest: AccessRequest, resourceId: string, metadata: StorageMetadata): Promise<void>;\n\n    // protected abstract getACL(acRequest: AccessRequest, resourceId: string): Promise<ACL | undefined>;\n    // protected abstract setACL(acRequest: AccessRequest, resourceId: string, acl: IACL): Promise<void>;\n}\n","//==[ SRE: S3Storage ]======================\n\nimport { IStorageRequest, StorageConnector } from '@sre/IO/Storage.service/StorageConnector';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { IAccessCandidate, IACL, TAccessLevel, TAccessResult, TAccessRole } from '@sre/types/ACL.types';\n\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IVectorDBRequest, VectorDBConnector } from '../VectorDBConnector';\nimport { IVectorDataSourceDto, PineconeConfig, QueryOptions, Source, VectorDBMetadata, VectorsResultData } from '@sre/types/VectorDB.types';\nimport { Pinecone } from '@pinecone-database/pinecone';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { OpenAIEmbeddings } from '@langchain/openai';\nimport { VectorsHelper } from '../Vectors.helper';\nimport { isUrl } from '@sre/utils/data.utils';\nimport { Logger } from '@sre/helpers/Log.helper';\n\nconst console = Logger('Pinecone VectorDB');\n\ntype SupportedSources = 'text' | 'vector' | 'url';\n\nexport class PineconeVectorDB extends VectorDBConnector {\n    public name = 'PineconeVectorDB';\n    private _client: Pinecone;\n    private indexName: string;\n\n    constructor(private config: PineconeConfig) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n        if (!config.pineconeApiKey) throw new Error('Pinecone API key is required');\n        if (!config.indexName) throw new Error('Pinecone index name is required');\n\n        this._client = new Pinecone({\n            apiKey: config.pineconeApiKey,\n        });\n\n        console.info('Pinecone client initialized');\n        console.info('Pinecone index name:', config.indexName);\n        this.indexName = config.indexName;\n    }\n\n    public get client() {\n        return this._client;\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL> {\n        //FIXME: store the ACLs in a durable storage. currently, they are stored in cache.\n\n        const namespaceId = resourceId;\n\n        //FIXME enable ACL check. For now, we return Owner access to all resources\n        // const metadata = await this.getNamespaceMetadata(namespaceId);\n\n        // if (!metadata) {\n        return new ACL().addAccess(candidate.role, candidate.id, TAccessLevel.Owner);\n        // }\n\n        // return ACL.from(metadata.acl as IACL);\n    }\n\n    // @SecureConnector.AccessControl\n    public user(candidate: AccessCandidate): IVectorDBRequest {\n        // search: async (namespace: string, query: string, options: QueryOptions) => {\n        //     return (await this.search(candidate.readRequest, { indexName: this.indexName, namespace, query }, options)).map((match) => ({\n        //         id: match.id,\n        //         values: match.values,\n        //         metadata: match.metadata,\n        //     }));\n        // },\n        return {\n            search: async (namespace: string, query: string | number[], options: QueryOptions) => {\n                return await this.search(candidate.readRequest, { indexName: this.indexName, namespace, query }, options);\n            },\n\n            insert: async (namespace: string, source: IVectorDataSourceDto | IVectorDataSourceDto[]) => {\n                return this.insert(candidate.writeRequest, { indexName: this.indexName, namespace, source });\n            },\n\n            delete: async (namespace: string, id: string | string[]) => {\n                await this.delete(candidate.writeRequest, { id, indexName: this.indexName, namespace });\n            },\n            createNamespace: async (namespace: string) => {\n                await this.createNamespace(candidate.writeRequest, namespace, this.indexName);\n            },\n            deleteNamespace: async (namespace: string) => {\n                await this.deleteNamespace(candidate.writeRequest, namespace, this.indexName);\n            },\n        };\n    }\n\n    @SecureConnector.AccessControl\n    protected async createNamespace(acRequest: AccessRequest, namespace: string, indexName: string): Promise<void> {\n        //* Pinecone does not need explicit namespace creation, instead, it creates the namespace when the first vector is inserted\n\n        // store ACL\n        //FIXME: store the ACLs in a durable storage. //!\n\n        // POSSIBLE PROBLEM: maybe we need to prefix the namespace with the a unique id in case of mutliple users/agents etc.\n\n        return new Promise<void>((resolve) => resolve());\n    }\n\n    @SecureConnector.AccessControl\n    protected async deleteNamespace(acRequest: AccessRequest, namespace: string, indexName: string): Promise<void> {\n        await this._client.Index(indexName).namespace(namespace).deleteAll();\n\n        //TODO: delete ACL\n    }\n\n    @SecureConnector.AccessControl\n    protected async search(\n        acRequest: AccessRequest,\n        data: { indexName: string; namespace: string; query: string | number[] },\n        options: QueryOptions = {}\n    ): Promise<VectorsResultData> {\n        const pineconeIndex = this.client.Index(data.indexName).namespace(data.namespace);\n        let _vector = data.query;\n        if (typeof data.query === 'string') {\n            _vector = await VectorsHelper.load().embedText(data.query);\n        }\n\n        const results = await pineconeIndex.query({\n            topK: options?.topK || 10,\n            vector: _vector as number[],\n            includeMetadata: true,\n            includeValues: true,\n        });\n\n        return results.matches.map((match) => ({\n            id: match.id,\n            values: match.values,\n            metadata: match.metadata,\n        }));\n    }\n\n    @SecureConnector.AccessControl\n    protected async insert(\n        acRequest: AccessRequest,\n        data: { indexName: string; namespace: string; source: IVectorDataSourceDto | IVectorDataSourceDto[] }\n    ): Promise<string[]> {\n        let { source: sourceWrapper } = data;\n        sourceWrapper = Array.isArray(sourceWrapper) ? sourceWrapper : [sourceWrapper];\n\n        // make sure that all sources are of the same type (source.source)\n        if (sourceWrapper.some((s) => this.detectSourceType(s.source) !== this.detectSourceType(sourceWrapper[0].source))) {\n            throw new Error('All sources must be of the same type');\n        }\n\n        const sourceType = this.detectSourceType(sourceWrapper[0].source);\n        if (sourceType === 'unknown' || sourceType === 'url') throw new Error('Invalid source type');\n        const transformedSource = await this.transformSource(sourceWrapper, sourceType);\n        const preparedSource = transformedSource.map((s) => ({\n            id: s.id,\n            values: s.source as number[],\n            metadata: s.metadata,\n        }));\n\n        // await pineconeStore.addDocuments(chunks, ids);\n        await this._client.Index(data.indexName).namespace(data.namespace).upsert(preparedSource);\n\n        return preparedSource.map((s) => s.id);\n    }\n\n    @SecureConnector.AccessControl\n    protected async delete(acRequest: AccessRequest, data: { id: string | string[]; indexName: string; namespace?: string }): Promise<void> {\n        const _ids = Array.isArray(data.id) ? data.id : [data.id];\n        const res = await this._client.Index(data.indexName).namespace(data.namespace).deleteMany(_ids);\n    }\n\n    // private async getNamespaceMetadata(namespaceId: string): Promise<Record<string, any>> {\n    //     const cache = ConnectorService.getCacheConnector();\n\n    //     const metadata = await cache.get(namespaceId);\n\n    //     return metadata;\n    // }\n\n    private detectSourceType(source: Source): SupportedSources | 'unknown' {\n        if (typeof source === 'string') {\n            return isUrl(source) ? 'url' : 'text';\n        } else if (Array.isArray(source) && source.every((v) => typeof v === 'number')) {\n            return 'vector';\n        } else {\n            return 'unknown';\n        }\n    }\n\n    private transformSource<T extends Source>(source: IVectorDataSourceDto[], sourceType: SupportedSources) {\n        //* as the accepted sources increases, you will need to implement the strategy pattern instead of a switch case\n        switch (sourceType) {\n            case 'text': {\n                const texts = source.map((s) => s.source as string);\n\n                return VectorsHelper.load()\n                    .embedTexts(texts)\n                    .then((vectors) => {\n                        return source.map((s, i) => ({\n                            ...s,\n                            source: vectors[i],\n                            metadata: { ...s.metadata, text: texts[i] },\n                        }));\n                    });\n            }\n            case 'vector': {\n                return source;\n            }\n        }\n    }\n}\n","//==[ SRE: Storage ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { PineconeVectorDB } from './connectors/PineconeVectorDB.class';\n\nexport class VectorDBService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.VectorDB, 'Pinecone', PineconeVectorDB);\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { getMainArgs, parseCLIArgs } from '@sre/utils/cli.utils';\n\nexport class CLIConnector extends Connector {\n    public name = 'CLI';\n    public params: any;\n    constructor() {\n        super();\n        this.params = this.parse(process.argv);\n    }\n\n    /**\n     * Parses the command line arguments, and returns the parsed arguments object\n     * if args is provided, it will only parse the provided args\n     * @param argv The command line arguments, usually process.argv\n     * @param args The arguments to parse\n     * @returns\n     */\n    public parse(argv: string[], args?: string | string[]) {\n        let _keys = args;\n        if (_keys && !Array.isArray(_keys)) _keys = [_keys];\n\n        const argsList = _keys || getMainArgs(argv);\n        const params = parseCLIArgs(argsList, argv);\n\n        return params;\n    }\n\n    /**\n     * Get the parsed arguments as an object\n     * @param args The arguments to get\n     * @returns\n     */\n    public get(args: string | string[]) {\n        let _keys = args;\n        if (!Array.isArray(_keys)) _keys = [_keys];\n\n        const result = {};\n        _keys.forEach((key) => {\n            if (this.params[key]) {\n                result[key] = this.params[key];\n            }\n        });\n\n        return result;\n    }\n}\n","import { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { CLIConnector } from './CLIConnector';\n\nexport class CLIService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.CLI, 'CLI', CLIConnector);\n    }\n}\n","import { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL } from '@sre/types/ACL.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\n\nexport interface INKVRequest {\n    get(namespace: string, key: string): Promise<StorageData>;\n    set(namespace: string, key: string, value: StorageData): Promise<void>;\n    delete(namespace: string, key: string): Promise<void>;\n    exists(namespace: string, key: string): Promise<boolean>;\n    deleteAll(namespace: string): Promise<void>;\n    list(namespace: string): Promise<{ key: string; data: StorageData }[]>;\n}\n\n/**\n * NKV = Namespace-Key-Value Connector\n */\nexport abstract class NKVConnector extends SecureConnector {\n    public user(candidate: AccessCandidate): INKVRequest {\n        return {\n            get: async (namespace: string, key: string) => this.get(candidate.readRequest, namespace, key),\n            set: async (namespace: string, key: string, value: StorageData) => this.set(candidate.writeRequest, namespace, key, value),\n            delete: async (namespace: string, key: string) => this.delete(candidate.writeRequest, namespace, key),\n            exists: async (namespace: string, key: string) => this.exists(candidate.readRequest, namespace, key),\n            deleteAll: async (namespace: string) => this.deleteAll(candidate.writeRequest, namespace),\n            list: async (namespace: string) => this.list(candidate.readRequest, namespace),\n        };\n    }\n\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n\n    protected abstract get(acRequest: AccessRequest, namespace: string, key: string): Promise<StorageData>;\n    protected abstract set(acRequest: AccessRequest, namespace: string, key: string, value: StorageData): Promise<void>;\n\n    protected abstract delete(acRequest: AccessRequest, namespace: string, key: string): Promise<void>;\n    protected abstract exists(acRequest: AccessRequest, namespace: string, key: string): Promise<boolean>;\n    protected abstract deleteAll(acRequest: AccessRequest, namespace: string): Promise<void>;\n    protected abstract list(acRequest: AccessRequest, namespace: string): Promise<{ key: string; data: StorageData }[]>;\n}\n","import { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { INKVRequest, NKVConnector } from '../NKVConnector';\nimport { ACLAccessDeniedError, IAccessCandidate, TAccessLevel, TAccessResult } from '@sre/types/ACL.types';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { CacheConnector } from '@sre/MemoryManager/Cache.service/CacheConnector';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { StorageData } from '@sre/types/Storage.types';\nimport { RedisCache } from '@sre/MemoryManager/Cache.service/connectors/RedisCache.class';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport Joi from 'joi';\n\nexport class NKVRedis extends NKVConnector {\n    public name = 'Redis';\n    private redisCacheConnector: RedisCache;\n    private accountConnector: AccountConnector;\n    private schemaValidator: Joi.ObjectSchema;\n    constructor() {\n        super();\n        this.redisCacheConnector = ConnectorService.getCacheConnector('Redis') as RedisCache;\n        this.accountConnector = ConnectorService.getAccountConnector();\n        this.schemaValidator = Joi.object().keys({\n            namespace: Joi.string().min(1).required(),\n            key: Joi.string().min(1).required(),\n        });\n    }\n\n    @NKVRedis.Validate\n    @NKVRedis.NamespaceAccessControl\n    protected async get(acRequest: AccessRequest, namespace: string, key: string): Promise<StorageData> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        return await this.redisCacheConnector.user(AccessCandidate.team(teamId)).get(`${namespace}:${key}`);\n    }\n\n    @NKVRedis.Validate\n    @NKVRedis.NamespaceAccessControl\n    protected async set(acRequest: AccessRequest, namespace: string, key: string, value: any) {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n\n        await this.redisCacheConnector.user(AccessCandidate.team(teamId)).set(`${namespace}:${key}`, value);\n        // to set namespace ownership\n        const isNewNs = !(await this.redisCacheConnector.user(AccessCandidate.team(teamId)).exists(namespace));\n        if (isNewNs) {\n            await this.redisCacheConnector.user(AccessCandidate.team(teamId)).set(namespace, '', undefined, { ns: true });\n        }\n    }\n\n    @NKVRedis.Validate\n    @NKVRedis.NamespaceAccessControl\n    protected async delete(acRequest: AccessRequest, namespace: string, key: string): Promise<void> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        await this.redisCacheConnector.user(AccessCandidate.team(teamId)).delete(`${namespace}:${key}`);\n    }\n\n    @NKVRedis.Validate\n    @NKVRedis.NamespaceAccessControl\n    protected async exists(acRequest: AccessRequest, namespace: string, key: string): Promise<boolean> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        return await this.redisCacheConnector.user(AccessCandidate.team(teamId)).exists(`${namespace}:${key}`);\n    }\n\n    @NKVRedis.NamespaceAccessControl\n    public async list(acRequest: AccessRequest, namespace: string): Promise<{ key: string; data: StorageData }[]> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        let keys = await this.fetchKeysByPrefix(`${this.redisCacheConnector.prefix(teamId)}:${namespace}`);\n\n        // filter out metadata keys & namespace sentinel keys\n        keys = keys.filter(\n            (key) => key !== `${this.redisCacheConnector.prefix(teamId)}:${namespace}` // if not the namespace sentinel key\n        );\n\n        if (keys.length <= 0) return [];\n        // Start a transaction\n        const pipeline = this.redisCacheConnector.client.pipeline();\n\n        // Add get commands for all keys to the transaction\n        keys.forEach((key) => {\n            pipeline.get(key);\n        });\n\n        // Execute the transaction\n        const results = await pipeline.exec();\n\n        // Combine the keys and their corresponding values\n        return keys.map((key, index) => {\n            return {\n                key: key.replace(`${this.redisCacheConnector.prefix(teamId)}:${namespace}:`, ''),\n                data: results[index][1] as StorageData,\n            };\n        });\n    }\n\n    @NKVRedis.NamespaceAccessControl\n    public async deleteAll(acRequest: AccessRequest, namespace: string): Promise<void> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        let keys = await this.fetchKeysByPrefix(`${this.redisCacheConnector.prefix(teamId)}:${namespace}`);\n        // filter out namespace sentinel key + namespace metadata key metadata key\n        keys = keys.filter((key) => {\n            return ![`${this.redisCacheConnector.prefix(teamId)}:${namespace}`].includes(key);\n        });\n        await this.redisCacheConnector.client.del(keys);\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL> {\n        return this.redisCacheConnector.getResourceACL(resourceId, candidate);\n    }\n\n    private async fetchKeysByPrefix(prefix: string): Promise<string[]> {\n        let cursor = '0';\n        const keys = [];\n\n        do {\n            // SCAN with match for the prefix and count for batch size (optional)\n            const result = await this.redisCacheConnector.client.scan(cursor, 'MATCH', `${prefix}*`, 'COUNT', 10000);\n            cursor = result[0];\n            keys.push(...result[1]);\n        } while (cursor !== '0');\n\n        return keys;\n    }\n\n    static NamespaceAccessControl(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        // Store the original method in a variable\n        const originalMethod = descriptor.value;\n\n        // Modify the descriptor's value to wrap the original method\n        descriptor.value = async function (...args: any[]) {\n            // Extract the method arguments\n            let [acRequest, namespace, key] = args;\n            const isNamespaceSearch = key === undefined;\n\n            // Inject the access control logic\n            const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n            const resourceId = isNamespaceSearch ? namespace : `${namespace}:${key}`;\n            const finalKey = `${this.redisCacheConnector.prefix(teamId)}:${resourceId}`;\n            const accessTicket = await this.getAccessTicket(finalKey, acRequest);\n\n            if (accessTicket.access !== TAccessResult.Granted) throw new ACLAccessDeniedError('Access Denied');\n\n            // Call the original method with the original arguments\n            return originalMethod.apply(this, args);\n        };\n\n        // Return the modified descriptor\n        return descriptor;\n    }\n\n    static Validate(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        // Store the original method in a variable\n        const originalMethod = descriptor.value;\n\n        // Modify the descriptor's value to wrap the original method\n        descriptor.value = async function (...args: any[]) {\n            // Extract the method arguments\n            let [acRequest, namespace, key] = args;\n\n            // Validate the arguments\n            const validationResult = this.schemaValidator.validate({ namespace, key });\n\n            if (validationResult.error) {\n                throw new Error(`Validation Error: ${validationResult.error.message}`);\n            }\n\n            // Call the original method with the original arguments\n            return originalMethod.apply(this, args);\n        };\n\n        // Return the modified descriptor\n        return descriptor;\n    }\n}\n","//==[ SRE: Storage ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { NKVRedis } from './connectors/NKVRedis.class';\n\nexport class NKVService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.NKV, 'Redis', NKVRedis);\n    }\n}\n","import { StorageService } from '@sre/IO/Storage.service';\nimport { LLMService } from '@sre/LLMManager/LLM.service';\nimport SystemEvents from './SystemEvents';\nimport { CacheService } from '@sre/MemoryManager/Cache.service';\nimport { Logger } from '../helpers/Log.helper';\nimport { TServiceRegistry } from '@sre/types/SRE.types';\nimport { VaultService } from '@sre/Security/Vault.service';\nimport { AccountService } from '@sre/Security/Account.service';\nimport { AgentDataService } from '@sre/AgentManager/AgentData.service';\nimport { VectorDBService } from '@sre/IO/VectorDB.service';\nimport { CLIService } from '@sre/IO/CLI.service';\nimport { NKVService } from '@sre/IO/NKV.service';\nconst console = Logger('Boot');\n\nexport function boot() {\n    console.debug('SRE Boot sequence started');\n    const service: TServiceRegistry = {};\n    service.Account = new AccountService();\n    service.Storage = new StorageService();\n    service.VectorDB = new VectorDBService();\n    service.Cache = new CacheService();\n    service.LLM = new LLMService();\n    service.Vault = new VaultService();\n    service.AgentData = new AgentDataService();\n    service.CLI = new CLIService();\n    service.NKV = new NKVService();\n\n    SystemEvents.on('SRE:Initialized', () => {\n        console.debug('SRE Initialized');\n        for (let key in service) {\n            service[key].init();\n        }\n\n        SystemEvents.emit('SRE:Booted', service);\n\n        console.debug('SRE Boot sequence completed');\n    });\n}\n","import 'source-map-support/register.js';\nimport AgentRequest from './subsystems/AgentManager/AgentRequest.class';\nimport AgentSettings from './subsystems/AgentManager/AgentSettings.class';\n//import SRE from './Core/SRE.class';\nimport Agent from './subsystems/AgentManager/Agent.class';\nimport SmythRuntime from './Core/SmythRuntime.class';\nimport { boot } from './Core/boot';\nimport { ConnectorService } from './Core/ConnectorsService';\nimport { CLIAgentDataConnector } from './subsystems/AgentManager/AgentData.service/connectors/CLIAgentDataConnector.class';\nimport { AgentProcess } from './Core/AgentProcess.helper';\nimport { Conversation } from './helpers/Conversation.helper';\nimport config from './config';\n\nboot();\n\nexport { Agent, AgentRequest, AgentSettings, AgentProcess, SmythRuntime, Conversation, ConnectorService, CLIAgentDataConnector, config };\n"],"names":["e","Object","defineProperty","i","a","s","t","enumerable","configurable","writable","value","h","AgentRequest","constructor","req","__publicField","this","headers","JSON","parse","stringify","body","data","query","params","url","parsedUrl","URL","path","pathname","method","sessionID","files","_agent_authinfo","res","header","name","toLowerCase","TConnectorService","Storage","VectorDB","Cache","LLM","Vault","Account","AgentData","CLI","NKV","uid","Date","now","Math","random","toString","replace","toUpperCase","async","processWithConcurrencyLimit","tasks","maxConcurrentTasks","limit","pLimit","limitedTasks","map","task","Promise","allSettled","flatMap","result","status","delay","ms","r","setTimeout","isValidString","str","cleanBase64","isDataUrl","input","test","isRawBase64","cleanedBase64Data","length","Buffer","from","parseBase64","dataUrlPattern","matches","match","Error","mimetype","parseDataUrl","cleanedData","identifyMimetypeFromRawBase64","parseRawBase64","error","message","buffer","fileTypeFromBuffer","mime","streamToBuffer","stream","chunks","chunk","push","concat","getSizeFromBinary","bufferData","ArrayBuffer","Uint8Array","isView","DataView","byteOffset","byteLength","isBuffer","dataToBuffer","isPlainObject","Array","isArray","prototype","call","isUrl","parseCLIArgs","argList","argv","process","args","forEach","mainArg","mainArgIndex","indexOf","values","startsWith","includes","keyValuePairs","key","valParts","split","val","join","getMimeTypeFromUrl","axios","get","responseType","Range","type","validateCharacterSet","parts","filter","Boolean","part","endsWith","slice","trim","validateInteger","helpers","numValue","Number","fieldName","schema","_flags","label","state","isNaN","min","max","dotenv","config","env","LOG_LEVEL","LOG_FILTER","OPENAI_API_KEY","ANTHROPIC_API_KEY","DATA_PATH","NODE_ENV","AGENT_DOMAIN","AGENT_DOMAIN_PORT","CODE_SANDBOX_URL","TOGETHER_AI_API_URL","REDIS_SENTINEL_HOSTS","REDIS_MASTER_NAME","REDIS_PASSWORD","AWS_ACCESS_KEY_ID","AWS_SECRET_ACCESS_KEY","AWS_S3_REGION","AWS_S3_BUCKET_NAME","PINECONE_API_KEY","PINECONE_INDEX_NAME","agent","ENDPOINT_PREFIX","u","m","winston","addColors","warn","info","debug","logLevel","namespaces","namespaceFilter","format","some","ns","module","ArrayTransport","Transport","opts","super","logs","log","callback","setImmediate","emit","level","LogHelper","_logger","labels","output","elapsedTime","startTime","formatLogMessage","verbose","stack","close","clear","arg","String","createLabeledLogger","memoryStore","logger","createLogger","combine","timestamp","errors","splat","json","transports","Console","printf","stderrLevels","colorize","add","createBaseLogger","defaultMeta","Logger","withMemoryStore","DummyConnector","Proxy","target","prop","receiver","console","Connector","start","started","stop","ready","_readyPromise","resolve","maxWait","interval","setInterval","clearInterval","SystemEvents","EventEmitter","Connectors","ConnectorInstances","ServiceRegistry","_ready","on","services","ConnectorService","service","register","connectorType","connectorName","connectorConstructor","subClass","superClass","getPrototypeOf","depth","isSubclassOf","init","settings","isDefault","entry","connector","default","_stop","allConnectors","index","self","getInstance","keys","getStorageConnector","getCacheConnector","getVectorDBConnector","getNKVConnector","getLLMConnector","getVaultConnector","getAccountConnector","getAgentDataConnector","getCLIConnector","hasInstance","instance","ConnectorServiceProvider","EmbodimentSettings","agentId","_embodiments","reject","embodimentType","_embodiment","find","embodiment","properties","o","n","AgentSettings","agentDataConnector","_settings","getAgentSettings","catch","embodiments","set","has","TAccessLevel","None","Owner","Read","Write","TAccessRole","Agent","User","Team","Public","RoleMap","user","team","public","LevelMap","none","owner","read","write","ReverseRoleMap","fromEntries","entries","k","v","ReverseLevelMap","TAccessResult","Granted","Denied","ACLAccessDeniedError","c","d","AccessRequest","object","id","every","candidate","acReq","resourceId","clone","request","setLevel","addLevel","resource","setCandidate","AccessCandidate","role","readRequest","writeRequest","ownerRequest","teamId","userId","p","A","L","ACLHashAlgo","source","xxh3","xxh64","ACL","acl","deserializeACL","hashAlgorithm","migrated","serializedACL","serializeACL","checkExactAccess","acRequest","entryId","access","addPublicAccess","ownerId","hashedOwner","curLevel","removePublicAccess","l","addAccess","_level","removeAccess","tacl","compressed","roleShort","entriesArray","hashedOwnerKey","accessLevels","accessLevelsShort","substring","entriesObj","short","w","y","_SmythFS","storage","Instance","URIParser","uri","parsed","tld","hostname","pop","hash","getStoragePath","smythURI","_candidate","toBuffer","Readable","err","metadata","isTeamMember","ContentType","getMimeType","ext","getType","Blob","FileType","delete","exists","SmythFS","BinaryInput","_name","load","size","getUrlInfo","contentType","contentLength","response","_source","getExtension","base64FileInfo","getBase64FileInfo","fileType","head","base64Data","filetype","upload","_uploading","getCandidateTeam","getJsonData","readData","getBuffer","JSONContentHelper","dataString","_current","create","tryParse","strInput","extractJsonFromString","isDigits","num","parseFloat","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","isSafeNumber","jsonrepair","regex","JSONContent","InferenceStrategies","any","string","number","floatVal","integer","intVal","parseInt","boolean","lowerCaseValue","array","obj","binary","date","errMsg","dayjs","locale","unix","isValid","toISOString","performTypeInference","inputs","inputConfig","_inputs","_inputConfig","Component","createComponentLogger","agentRuntime","validateConfig","configSchema","_templateVars","tplVar","append","Joi","valid","validate","_error","displayName","title","_debug","_input","postProcess","enable","disable","readOutput","hasOutput","VaultHelper","getTeamKey","getUserKey","vaultConnector","getAgentKey","Match","doubleCurly","singleCurly","prefix","RegExp","suffix","prefSuf","fn","TPLProcessor","vaultTeam","token","TemplateStringHelper","templateString","_promiseQueue","asyncResult","all","parseTeamKeys","processor","tokens","prosessorPromises","exec","_processor","then","clean","escapeString","TemplateString","V","j","f","E","isEmpty","isTemplateVar","isKeyTemplateVar","parseKey","i$7","echo","llm","alias","Echo","completionTokens","enabled","components","tags","keyOptions","hidden","LLMHelper","model","llmName","models","_modelId","_modelInfo","_llmConnector","modelInfo","promptRequest","prompt","customParams","details","extractLLMComponentParams","assign","enhancePrompt","chatRequest","content","finishReason","visionRequest","sources","extractVisionLLMParams","toolRequest","streamToolRequest","streamRequest","PromptGenerator","required","temperature","maxTokens","stopSequences","allow","topP","topK","frequencyPenalty","presencePenalty","llmHelper","Reply","b","_","VectorsHelper","_connector","embeddingsProvider","OpenAIEmbeddings","_vectorDimention","dimensions","options","vectorDimention","setVectorDimention","chunkText","text","chunkSize","chunkOverlap","RecursiveCharacterTextSplitter","splitText","ingestText","namespace","chunkedText","ids","crypto","randomUUID","doc","stringifyMetadata","insert","embedText","embedQuery","embedTexts","texts","embedDocuments","g","AgentProcess","agentData","initAgent","connections","version","jsonRegex","jsonData","idRegex","getAgentData","agentSettings","_loadPromise","itv","run","reqConfig","parseReqConfig","setRequest","pathMatches","endpointPath","reset","parseCLI","cli","usedMethod","endpoint","session","filePath","cwd","fileName","basename","fs","existsSync","fileBuffer","readFileSync","fileObj","fieldname","originalname","post","LLMContext","_model","_systemPrompt","_messages","_llmHelper","messages","addUserMessage","getContextWindow","maxOutputTokens","maxModelContext","maxInputContext","systemMessage","encodeChat","unshift","__smyth_data__","textContent","encoded","encode","excessPercentage","floor","REQUEST_METHODS","EMBODIMENT_TYPES","ChatBot","ChatGPT","DEFAULT_MAX_TOKENS_FOR_LLM","TOOL_USE_DEFAULT_MODEL","JSON_RESPONSE_INSTRUCTION","swaggerParser","SwaggerParser","OpenAPIParser","mapReqMethods","paths","methods","Map","pathData","operationId","mapEndpoints","operationIds","yamlToJson","yamlData","yaml","$RefParser","dereference","getJson","_data","getJsonFromUrl","isValidOpenAPI","openapi","servers","Conversation","_specSource","maxContextSize","_maxContextSize","_maxOutputTokens","loadSpecFromSource","spec","_status","_spec","updateModel","context","_context","specSource","_currentWaitPromise","waitTime","wait","toolHeaders","reqMethods","_reqMethods","toolsConfig","_toolsConfig","endpoints","_endpoints","baseUrl","_baseUrl","contextWindow","llmResponse","max_tokens","_agentId","code","useTool","toolsData","tool","parsedArgs","arguments","toolArgs","plugin_url","functionResponse","messagesWithToolResult","prepareInputMessageBlocks","messageBlock","streamPrompt","concurrentToolCalls","_content","eventEmitter","toolsContent","hasTools","llmMessage","tool_calls","function","toolProcessingTasks","processedToolsData","_streamPrompt","delta","choices","resolveToolEndpoint","templateParams","parameters","in","parsedEndpoint","searchParams","functionDeclarations","getFunctionDeclarations","formatToolsConfig","toolDefinitions","toolChoice","systemPrompt","patchSpec","description","assistantName","defaultBaseUrl","origin","behavior","templateInfo","getOpenAPIJSON","declarations","requiredFields","requestBody","declaration","summary","T","cacheConnector","Note","APIEndpoint","pattern","ai_exposed","agentRequest","_authInfo","inputsWithDefaultValue","defaultVal","bodyInputNames","queryInputNames","outputs","outputName","expression","inputName","_inputWithDefaultValue","inputValue","isFile","binaryInput","file","APIOutput","Output","agentVar","agentVariables","LLMPrompt","APICall","_templateSettings","proxy","oauthService","scope","authorizationURL","tokenURL","clientID","clientSecret","oauth2CallbackURL","callbackURL","requestTokenURL","accessTokenURL","userAuthorizationURL","consumerKey","consumerSecret","oauth1CallbackURL","authenticate","Response","Headers","VisionLLM","images","Images","promises","image","FSleep","Input","_debug_time","FHash","Data","algorithm","encoding","hashAlgo","createHash","update","Hash","digest","FEncDec","action","FTimestamp","Timestamp","DataSourceLookup","custom","postprocess","strict","includeMetadata","optional","componentId","con","Query","vectorDB","results","search","parseMetadata","Results","DataSourceIndexer","debugOutput","_config","namespaceId","inputSchema","validateInput","providedId","dsId","generateContextUID","indexRes","Source","addDSFromText","Success","dataSource","unknown","parseContextUID","dsData","embeddingIds","addDSFromUrl","DataSourceCleaner","validateConfigData","dsUrl","dataBuffer","JSONFilter","fields","fieldList","field","filterObject","reduce","acc","filterFields","LogicAND","cfgInput","Verified","Unverified","LogicOR","LogicXOR","trueCount","LogicAtLeast","minSetInputs","LogicAtMost","maxSetInputs","AgentPlugin","openAiModel","descForModel","desc","logoUrl","domain","subAgentId","reqTag","Prompt","isSubAgentDeployed","isDeployed","callerSessionId","LLMAssistant","ttl","userInput","UserInput","UserId","conversationId","ConversationId","conv_uid","sessionData","filteredMessages","messageTokens","readMessagesFromSession","round","saveMessagesToSession","_AgentLogger","cleanup","trIds","transactions","trId","canDelete","logData","logTask","AgentLogger","RuntimeContext","runtime","dbgFolder","mkdirSync","recursive","reqId","processID","xDebugId","ctxFile","jobID","initRuntimeContext","serialize","step","sessionResult","sessionResults","deserialize","_runtimeFileReady","endpointDBGCall","ctxData","cptId","ctx","active","cpt","writeFileSync","sync","sessionClosed","unlinkSync","incStep","updateComponent","component","resetComponent","runtimeData","getComponentData","AgentRuntimeUnavailable","_AgentRuntime","isNestedProcess","xDebugStop","xDebugRun","xDebugInject","xDebugRead","reqTagOwner","xDebugPendingInject","sessionId","workflowReqId","tagsData","processResults","errorResults","agentContext","alwaysActiveComponents","exclusiveComponents","componentInstance","alwaysActive","getRuntimeData","saveRuntimeComponentData","exclusive","_debugActive","circularLimitReached","curStep","destroy","incTag","getWaitingComponents","getExclusiveActiveComponents","readState","stateId","deltaOnly","dbgAllComponents","dbgActiveComponents","_job_components","dbgComponent","dbgSession","remainingActiveComponents","activeAsyncComponents","checkCircularLimit","circularLimit","runCycle","dbgActiveWaitingComponents","dbgActiveReadyComponents","expiredDbgSession","injectInput","callComponent","sourceId","dbgResults","flat","_missing_inputs","finalResult","current","seen","_exclude","injectDebugOutput","allEmpty","componentData","updateRuntimeData","AgentRuntime","totalMemory","os","totalmem","freeMemory","freemem","usedMemory","toFixed","getMemoryUsage","OSResourceMonitor","cpus","nice","sys","idle","irq","total","cpu","times","getCpuUsage","F","M","agentVersion","debugSessionEnabled","variables","apiBasePath","connection","sourceComponent","targetComponent","targetId","sourceIndex","targetIndex","next","prev","tagAsyncComponents","dateTime","getFullYear","getMonth","padStart","getDate","getHours","getMinutes","getSeconds","getCurrentFormattedDate","sessionTags","sessionTag","dummy","kill","_kill","parseVariables","logId","workflowID","inputTimestamp","dbgResult","qosLatency","planInfo","maxLatency","circularLimitData","outputTimestamp","updateTasksCount","_result","_componentData","_component","postProcessResult","hasLoopAncestor","inputEntry","prevId","prevComponentData","clearChildLoopRuntimeComponentData","_ChildLoopData","getComponentMissingInputs","missingInputs","readablePredecessors","findReadablePredecessors","readableInputNames","pred","allInputIndexes","allInputs","predComponentData","sourceComponentData","hasReadOutput","updateStep","prepareComponentInput","validationResult","_in_progress","callNextComponents","_LoopData","branches","_is_leaf","parentId","resultsCopy","loopIndex","loopLength","JSONExpression","propertyString","currentProperty","property","waitingComponents","waitingComponentIds","alwaysActiveIds","alwaysActiveConnections","prevComponent","outputEndpoint","targetComponents","targetComponentData","nextInput","inputEndpoint","outputExpression","outputParts","defaultOutputs","combinedInput","sourceRuntimeData","__action","__status","rData","rDataInput","getConnectionSource","getConnectionTarget","recursiveTagAsyncComponents","connected","AsyncComponents","AsyncComponent","CInstance","_SmythRuntime","initialized","autoConf","configEntry","Settings","Default","newConfig","hasDefault","SmythRuntime","SecureConnector","hasAccess","aclHelper","getResourceACL","publicRequest","teamRequest","teamOwnerRequest","getAccessTicket","sysAcRequest","AccessControl","propertyKey","descriptor","originalMethod","apply","StorageConnector","getOwnPropertyDescriptor","q","S3Storage","bucket","clientConfig","region","accessKeyId","secretAccessKey","credentials","client","S3Client","getMetadata","setMetadata","getACL","setACL","command","GetObjectCommand","Bucket","Key","send","Body","getS3Metadata","s3Metadata","setS3Metadata","accessCandidate","PutObjectCommand","Metadata","serializeS3Metadata","DeleteObjectCommand","HeadObjectCommand","migrateMetadata","agentid","teamid","userid","convertibleItems","newMetadata","amzMetadata","deserializeS3Metadata","s3RawMetadata","getObjectCommand","objectData","bufferBody","putObjectCommand","__decorateClass","StorageService","f$1","OpenAI","cohere","togetherAI","AnthropicAI","GoogleAI","Groq","LLMConnector","apiKey","getAllowedCompletionTokens","hasTeamAPIKey","getSafeMaxTokens","givenMaxTokens","hasApiKey","allowedTokens","countVisionPromptTokens","textObj","item","textTokens","imageTokens","image_url","width","height","_getImageDimensions","_countImageTokens","resolveModelName","getAllowedContextTokens","checkTokensLimit","promptTokens","allowedContextTokens","totalTokens","isExceeded","validateTokensLimit","newPrompt","excludedKeys","outputKeys","outputFormat","clonedConfigData","configParams","_value","configKey","paramKey","paramMappings","hasSystemMessage","separateSystemMessages","otherMessages","detailMode","maxDimension","minDimension","scaledMinDimension","tiles","ceil","imageSize","EchoConnector","I","OpenAIConnector","response_format","openai","tokensLimit","chat","completions","finish_reason","imageData","promptData","tokenLimit","tools","tool_choice","toolCallsStream","contentStream","tee","_stream","toolCall","emitter","messageBlocks","transformedMessageBlock","transformedToolsData","toolData","tool_call_id","MODELS_WITH_SYSTEM_MESSAGE","MODELS_WITH_JSON_RESPONSE","VALID_MIME_TYPES","VALID_IMAGE_MIME_TYPES","GoogleAIConnector","genAI","GoogleGenerativeAI","GOOGLEAI_API_KEY","systemInstruction","separateMessages","responseFormat","responseMimeType","generationConfig","$model","getGenerativeModel","countTokens","generateContent","candidates","fileSources","agentCandidate","fileUploadingTasks","processValidFiles","uploadFile","uploadedFiles","validImageMimeTypes","fileDataObjectsArray","fileData","mimeType","fileUri","promptWithFiles","allowFunctionNames","function_declarations","tool_config","function_calling_config","mode","allowed_function_names","fileProcessingTasks","fileSource","processObjectFileSource","processStringFileSource","tempDir","tmpdir","tempFilePath","writer","createWriteStream","pipe","fileManager","GoogleAIFileManager","uploadResponse","uploadedFile","getFile","FileState","PROCESSING","stdout","FAILED","unlink","PREFILL_TEXT_FOR_JSON_RESPONSE","AnthropicAIConnector","system","anthropic","Anthropic","messageCreateArgs","stop_sequences","top_p","top_k","stop_reason","APIError","validFiles","base64data","media_type","stopReason","toolUseContentBlocks","toolUseBlock","checkMessagesConsistency","finalMessage","shift","input_schema","calls","tool_use_id","LLMService","CacheConnector","updateTTL","getTTL","RedisCache","sentinels","hosts","host","hostName","port","parseSentinelHosts","redis","IORedis","password","accountConnector","_prefix","mdPrefix","_mdPrefix","del","deserializeRedisMetadata","serializeRedisMetadata","expire","_metadata","redisMetadata","strMetadata","quit","CacheService","VaultConnector","C","JSONFileVault","vaultData","keyId","VaultService","AccountConnector","AccountService","openapiTemplate","schemas","openapiEndpointTemplate","responses","AgentDataConnector","server_url","aiOnly","shortDescription","_version","openAPITpl","model_name","model_description","openAPIObj","openAPIEntry","parameter","getOpenAPIInputSchema","style","explode","getOpenAPIParameterStyle","requiredProps","input_type","items","additionalProperties","CLIAgentDataConnector","__dirname","realpathSync","getAgentIdByDomain","D","LocalAgentDataConnector","dev","prod","devDir","prodDir","indexDir","dir","agents","readdirSync","agentsData","indexAgentsData","devAgentsData","devAgentSettings","prodAgentsData","prodAgentSettings","AgentDataService","VectorDBConnector","x","PineconeVectorDB","pineconeApiKey","indexName","_client","Pinecone","createNamespace","deleteNamespace","Index","deleteAll","pineconeIndex","_vector","vector","includeValues","sourceWrapper","detectSourceType","sourceType","preparedSource","transformSource","upsert","_ids","deleteMany","vectors","VectorDBService","CLIConnector","_keys","argsList","getMainArgs","CLIService","NKVConnector","list","$","_NKVRedis","redisCacheConnector","schemaValidator","fetchKeysByPrefix","pipeline","cursor","scan","NamespaceAccessControl","isNamespaceSearch","finalKey","Validate","NKVRedis","NKVService","boot","re","$t","Ne","Nn","Qa","_r","Pt","Ke"],"mappings":"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"}