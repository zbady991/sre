{"version":3,"file":"index.js","sources":["../src/subsystems/AgentManager/AgentRequest.class.ts","../src/types/SRE.types.ts","../src/utils/general.utils.ts","../src/utils/date-time.utils.ts","../src/utils/string.utils.ts","../src/constants.ts","../src/utils/base64.utils.ts","../src/utils/data.utils.ts","../src/utils/cli.utils.ts","../src/utils/numbers.utils.ts","../src/utils/validation.utils.ts","../src/config.ts","../src/helpers/Log.helper.ts","../src/Core/DummyConnector.ts","../src/Core/Connector.class.ts","../src/helpers/LocalCache.helper.ts","../src/Core/SystemEvents.ts","../src/Core/ConnectorsService.ts","../src/subsystems/AgentManager/EmbodimentSettings.class.ts","../src/subsystems/AgentManager/AgentSettings.class.ts","../src/types/ACL.types.ts","../src/subsystems/Security/AccessControl/AccessRequest.class.ts","../src/subsystems/Security/AccessControl/AccessCandidate.class.ts","../src/subsystems/Security/AccessControl/ACL.class.ts","../src/helpers/JsonContent.helper.ts","../src/subsystems/IO/Storage.service/SmythFS.class.ts","../src/helpers/BinaryInput.helper.ts","../src/helpers/TypeChecker.helper.ts","../src/Components/Component.class.ts","../src/subsystems/Security/Vault.service/Vault.helper.ts","../src/helpers/TemplateString.helper.ts","../src/Components/APIEndpoint.class.ts","../src/Components/APIOutput.class.ts","../src/types/LLM.types.ts","../src/subsystems/LLMManager/models.ts","../src/subsystems/LLMManager/LLMRegistry.class.ts","../src/subsystems/LLMManager/custom-models.ts","../src/subsystems/LLMManager/CustomLLMRegistry.class.ts","../src/subsystems/LLMManager/LLM.inference.ts","../src/Components/PromptGenerator.class.ts","../src/Components/APICall/parseData.ts","../src/Components/APICall/mimeTypeCategories.ts","../src/Components/APICall/ArrayBufferResponse.helper.ts","../src/Components/APICall/AccessTokenManager.ts","../src/Components/APICall/OAuth.helper.ts","../src/Components/APICall/APICall.class.ts","../src/Components/VisionLLM.class.ts","../src/Core/SmythRuntime.class.ts","../src/subsystems/Security/SecureConnector.class.ts","../src/subsystems/IO/VectorDB.service/VectorDBConnector.ts","../src/subsystems/IO/VectorDB.service/connectors/PineconeVectorDB.class.ts","../src/subsystems/IO/VectorDB.service/Vectors.helper.ts","../src/Components/DataSourceLookup.class.ts","../src/Components/DataSourceIndexer.class.ts","../src/Components/LogicAtLeast.class.ts","../src/Components/LogicAtMost.class.ts","../src/Core/AgentProcess.helper.ts","../src/subsystems/MemoryManager/LLMContext.ts","../src/helpers/OpenApiParser.helper.ts","../src/helpers/Conversation.helper.ts","../src/Components/AgentPlugin.class.ts","../src/Components/LLMAssistant.class.ts","../src/subsystems/AgentManager/ForkedAgent.class.ts","../src/Components/Async.class.ts","../src/Components/Await.class.ts","../src/Components/ForEach.class.ts","../src/Components/HuggingFace.class.ts","../src/Components/ZapierAction.class.ts","../src/Components/GPTPlugin.class.ts","../src/Components/ImageGenerator.class.ts","../src/Components/Classifier.class.ts","../src/Components/MultimodalLLM.class.ts","../src/Components/index.ts","../src/Components/APICall/parseUrl.ts","../src/Components/APICall/parseHeaders.ts","../src/Components/APICall/parseProxy.ts","../src/Components/FSleep.class.ts","../src/Components/FHash.class.ts","../src/Components/FEncDec.class.ts","../src/Components/FSign.class.ts","../src/Components/FTimestamp.class.ts","../src/Components/DataSourceCleaner.class.ts","../src/Components/JSONFilter.class.ts","../src/Components/LogicAND.class.ts","../src/Components/LogicOR.class.ts","../src/Components/LogicXOR.class.ts","../src/Components/Code.class.ts","../src/subsystems/AgentManager/AgentLogger.class.ts","../src/subsystems/MemoryManager/RuntimeContext.ts","../src/subsystems/AgentManager/AgentRuntime.class.ts","../src/subsystems/AgentManager/OSResourceMonitor.ts","../src/subsystems/AgentManager/Agent.class.ts","../src/subsystems/IO/Storage.service/StorageConnector.ts","../src/subsystems/IO/Storage.service/connectors/S3Storage.class.ts","../src/subsystems/IO/Storage.service/index.ts","../src/subsystems/LLMManager/LLM.service/LLMConnector.ts","../src/subsystems/LLMManager/LLM.service/connectors/Echo.class.ts","../src/subsystems/LLMManager/LLM.helper.ts","../src/subsystems/LLMManager/LLM.service/connectors/OpenAI.class.ts","../src/subsystems/LLMManager/LLM.service/connectors/GoogleAI.class.ts","../src/subsystems/LLMManager/LLM.service/connectors/AnthropicAI.class.ts","../src/subsystems/LLMManager/LLM.service/connectors/Groq.class.ts","../src/subsystems/LLMManager/LLM.service/connectors/Bedrock.class.ts","../src/subsystems/LLMManager/LLM.service/connectors/VertexAI.class.ts","../src/subsystems/LLMManager/LLM.service/index.ts","../src/subsystems/MemoryManager/Cache.service/CacheConnector.ts","../src/subsystems/MemoryManager/Cache.service/connectors/RedisCache.class.ts","../src/subsystems/MemoryManager/Cache.service/index.ts","../src/subsystems/Security/Vault.service/VaultConnector.ts","../src/subsystems/Security/Vault.service/connectors/JSONFileVault.class.ts","../src/utils/oauth.utils.ts","../src/subsystems/Security/Vault.service/connectors/SmythVault.class.ts","../src/subsystems/Security/Vault.service/connectors/SecretsManager.class.ts","../src/subsystems/Security/Vault.service/index.ts","../src/subsystems/Security/Account.service/AccountConnector.ts","../src/subsystems/Security/Account.service/connectors/SmythAccount.class.ts","../src/subsystems/Security/Account.service/connectors/DummyAccount.class.ts","../src/subsystems/Security/Account.service/connectors/AWSAccount.class.ts","../src/subsystems/Security/Account.service/index.ts","../src/subsystems/AgentManager/AgentData.service/AgentDataConnector.ts","../src/subsystems/AgentManager/AgentData.service/connectors/CLIAgentDataConnector.class.ts","../src/subsystems/AgentManager/AgentData.service/connectors/LocalAgentDataConnector.class.ts","../src/subsystems/AgentManager/AgentData.service/connectors/SmythAgentDataConnector.class.ts","../src/subsystems/AgentManager/AgentData.service/index.ts","../src/subsystems/IO/VectorDB.service/connectors/SmythManagedVectorDB.class.ts","../src/subsystems/IO/VectorDB.service/index.ts","../src/subsystems/IO/CLI.service/CLIConnector.ts","../src/subsystems/IO/CLI.service/index.ts","../src/subsystems/IO/NKV.service/NKVConnector.ts","../src/subsystems/IO/NKV.service/connectors/NKVRedis.class.ts","../src/subsystems/IO/NKV.service/index.ts","../src/subsystems/IO/Router.service/RouterConnector.ts","../src/subsystems/IO/Router.service/connectors/ExpressRouter.class.ts","../src/subsystems/IO/Router.service/index.ts","../src/subsystems/Security/ManagedVault.service/ManagedVaultConnector.ts","../src/subsystems/Security/ManagedVault.service/connectors/SmythManagedVault.ts","../src/subsystems/Security/ManagedVault.service/index.ts","../src/Core/boot.ts","../src/index.ts"],"sourcesContent":["export default class AgentRequest {\n    public headers: any;\n    public body: any;\n    public query: any;\n    public params: any;\n    public method: string = 'GET';\n    public path: string = '';\n    public sessionID: string = '';\n    public res: Response | null = null;\n    public req: Request | null = null;\n    public files: any[] = [];\n    public _agent_authinfo: any;\n    constructor(req?: AgentRequest | string[] | any) {\n        if (!req) return;\n        this.headers = JSON.parse(JSON.stringify(req.headers || {}));\n        this.body = JSON.parse(JSON.stringify(req.body || req.data || {}));\n        this.query = JSON.parse(JSON.stringify(req.query || {}));\n        this.params = JSON.parse(JSON.stringify(req.params || {}));\n\n        if (req.url) {\n            const parsedUrl = new URL(req.url || '');\n            this.path = parsedUrl.pathname;\n        }\n        if (req.path) this.path = req.path;\n\n        this.method = req.method;\n\n        this.sessionID = req.sessionID;\n        this.files = req.files || [];\n        this._agent_authinfo = req._agent_authinfo;\n\n        this.req = req instanceof AgentRequest ? req?.req : req;\n        this.res = req?.res || null;\n    }\n    header(name: string) {\n        return this.headers[name.toLowerCase()];\n    }\n}\n","import { AgentDataService } from '@sre/AgentManager/AgentData.service';\nimport { CLIService } from '@sre/IO/CLI.service';\nimport { NKVService } from '@sre/IO/NKV.service';\nimport { StorageService } from '@sre/IO/Storage.service';\nimport { VectorDBService } from '@sre/IO/VectorDB.service';\nimport { LLMService } from '@sre/LLMManager/LLM.service';\nimport { CacheService } from '@sre/MemoryManager/Cache.service';\nimport { AccountService } from '@sre/Security/Account.service';\nimport { VaultService } from '@sre/Security/Vault.service';\nimport { RouterService } from '@sre/IO/Router.service';\nimport { ManagedVaultService } from '@sre/Security/ManagedVault.service';\n\nexport type TServiceRegistry = {\n    Storage?: StorageService;\n    VectorDB?: VectorDBService;\n    Cache?: CacheService;\n    LLM?: LLMService;\n    Vault?: VaultService;\n    Account?: AccountService;\n    AgentData?: AgentDataService;\n    CLI?: CLIService;\n    NKV?: NKVService;\n    Router?: RouterService;\n    ManagedVault?: ManagedVaultService;\n};\n\nexport enum TConnectorService {\n    Storage = 'Storage',\n    VectorDB = 'VectorDB',\n    Cache = 'Cache',\n    LLM = 'LLM',\n    Vault = 'Vault',\n    Account = 'Account',\n    AgentData = 'AgentData',\n    CLI = 'CLI',\n    NKV = 'NKV',\n    Router = 'Router',\n    ManagedVault = 'ManagedVault',\n}\n\nexport type SREConnectorConfig = {\n    Connector: string;\n    Id?: string;\n    Default?: boolean;\n    Settings?: {\n        [hashedOwnerKey: string]: any;\n    };\n};\n\nexport type SREConfig = {\n    [key in TConnectorService]?: SREConnectorConfig[] | SREConnectorConfig;\n};\n","import pLimit from 'p-limit';\nexport function uid() {\n    return (Date.now() + Math.random()).toString(36).replace('.', '').toUpperCase();\n}\n\n/**\n * this function is used to check if a class is a subclass of another class\n * @param subClass\n * @param superClass\n * @returns\n */\nexport function isSubclassOf(subClass: any, superClass: any): boolean {\n    if (typeof subClass !== 'function' || typeof superClass !== 'function') {\n        return false;\n    }\n\n    let prototype = Object.getPrototypeOf(subClass.prototype);\n    let depth = 10;\n\n    while (prototype && depth >= 0) {\n        if (prototype === superClass.prototype) {\n            return true;\n        }\n        prototype = Object.getPrototypeOf(prototype);\n        depth++;\n    }\n\n    return false;\n}\n\n/**\n * Processes an array of tasks concurrently with a specified concurrency limit.\n *\n * @template T - The type of the result returned by each task.\n *\n * @param {(() => Promise<T>)[]} tasks - An array of functions that return promises.\n * Each function represents a task to be processed.\n * @param {number} [maxConcurrentTasks=10] - The maximum number of concurrent tasks.\n *\n * @returns {Promise<T[]>} - A promise that resolves to an array of results.\n * Only successfully fulfilled promises are included in the result array.\n *\n * @throws {TypeError} - Throws an error if the tasks parameter is not an array of functions.\n *\n * @example\n * const tasks = [\n *     () => await processFile('file1.txt'),\n *     () => await processFile('file2.txt'),\n *     () => await processFile('file3.txt'),\n * ];\n *\n * const maxConcurrentTasks = 2;\n *\n * processWithConcurrencyLimit(tasks, maxConcurrentTasks)\n *     .then(results => console.log(results)) // Array of results from the fulfilled promises\n *     .catch(error => console.error(error));\n *\n * @note Currently, this function ignores tasks that fail to process.\n *       Only successfully fulfilled promises are included in the result array.\n *       To improve this behavior, we could add an option to control whether to exit the function if a task fails.\n */\nexport async function processWithConcurrencyLimit<T>(tasks: (() => Promise<T>)[], maxConcurrentTasks: number = 10): Promise<T[]> {\n    const limit = pLimit(maxConcurrentTasks);\n\n    const limitedTasks = tasks.map((task) => limit(task));\n\n    const results = await Promise.allSettled(limitedTasks);\n\n    // Filter for successfully fulfilled promises and extract their values\n    const validResults = results.flatMap((result) => (result.status === 'fulfilled' ? [result.value] : [])).filter(Boolean);\n\n    return validResults;\n}\n\nexport const detectURLSourceType = (url: string) => {\n    const urlObj = new URL(url);\n    const ext = urlObj.pathname.split('.').pop();\n\n    switch (ext) {\n        case 'pdf':\n            return 'PDF';\n        case 'xml':\n            return 'SITEMAP';\n        case 'html':\n        case 'htm':\n        case 'txt':\n            return 'WEBPAGE';\n        case 'doc':\n        case 'docx':\n            return 'WORD';\n        default:\n            return 'WEBPAGE';\n    }\n};\n\n/**\n * This function checks if a string is a valid JSON string.\n * @param str\n * @returns\n */\nexport const isJSONString = (str: string): boolean => {\n    try {\n        return typeof str === 'string' && !!JSON.parse(str);\n    } catch {\n        return false;\n    }\n};\n","export function getCurrentFormattedDate() {\n    const date = new Date();\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based\n    const day = String(date.getDate()).padStart(2, '0');\n    const hours = String(date.getHours()).padStart(2, '0');\n    const minutes = String(date.getMinutes()).padStart(2, '0');\n    const seconds = String(date.getSeconds()).padStart(2, '0');\n    return `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;\n}\n\nexport function getDayFormattedDate() {\n    const date = new Date();\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based\n    const day = String(date.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n}\n\nexport function delay(ms) {\n    return new Promise((r) => setTimeout(r, ms));\n}\n","/**\n * perform a replace operation on a string asynchronously\n * @param str\n * @param regex\n * @param asyncFn\n * @returns\n */\nexport async function asyncReplace(str, regex, asyncFn) {\n    const matches = [];\n    let match;\n\n    // Find all matches and store them in an array\n    while ((match = regex.exec(str)) !== null) {\n        matches.push(match);\n    }\n\n    // Process each match asynchronously\n    const replacements = await Promise.all(\n        matches.map(async (match) => {\n            // Call the async function with all match groups\n            return asyncFn(...match);\n        })\n    );\n\n    // Reassemble the string with replacements\n    let result = '';\n    let lastIndex = 0;\n\n    matches.forEach((match, index) => {\n        result += str.slice(lastIndex, match.index) + replacements[index];\n        lastIndex = match.index + match[0].length;\n    });\n\n    // Append the remaining part of the string\n    result += str.slice(lastIndex);\n\n    return result;\n}\n\nexport function isValidString(str: string): boolean {\n    return str && typeof str === 'string';\n}\n\nconst isValidNumber = (str: string): boolean => {\n    const num = parseFloat(str);\n    return !isNaN(num) && num <= Number.MAX_SAFE_INTEGER && num >= Number.MIN_SAFE_INTEGER && num.toString() === str.trim();\n};\n\n/**\n * The function parseJson() won't parse the data for property values.\n * For instance, if you have '{\"a\": \"1\",\"b\": \"true\"}', it will be parsed as {a: '1', b: 'true'}. That's why we parse the appropriate data type for property values\n * so that the data will be parsed as {a: 1, b: true}\n * @param data\n * @returns\n */\nexport function convertStringToRespectiveType(data: any): any {\n    if (data === null || data === undefined) return data;\n\n    if (typeof data !== 'object') {\n        // If it's a string, perform conversions\n        if (typeof data === 'string') {\n            if (data.toLowerCase() === 'true') {\n                return true;\n            } else if (data.toLowerCase() === 'false') {\n                return false;\n            } else if (isValidNumber(data)) {\n                return Number(data);\n            } else if (data.toLowerCase() === 'null') {\n                return null;\n            } else if (data.toLowerCase() === 'undefined') {\n                return undefined;\n            }\n        }\n\n        return data;\n    }\n\n    // If it's an array, map over it and parse each item\n    if (Array.isArray(data)) {\n        return data.map((item) => convertStringToRespectiveType(item));\n    }\n\n    // If it's an object, map over its properties and parse each one\n    return Object.fromEntries(Object.entries(data).map(([key, value]) => [key, convertStringToRespectiveType(value)]));\n}\n\nexport const kebabToCamel = (input) => {\n    if (!input || typeof input !== 'string') return input;\n\n    return input.replace(/-([a-z])/g, function (match, group) {\n        return group.toUpperCase();\n    });\n};\n\nexport const kebabToCapitalize = (input) => {\n    if (!input || typeof input !== 'string') return input;\n\n    return input\n        .split('-')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n        .join(' ');\n};\n","// supported request methods\nexport const REQUEST_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'];\n\nexport const REQUEST_CONTENT_TYPES = {\n    none: 'none',\n    urlEncodedFormData: 'application/x-www-form-urlencoded',\n    multipartFormData: 'multipart/form-data',\n    json: 'application/json',\n    text: 'text/plain',\n    xml: 'application/xml',\n    binary: 'binary',\n};\n\nexport enum EMBODIMENT_TYPES {\n    ChatBot = 'chatBot',\n    ChatGPT = 'chatGPT',\n}\n\nexport const ERR_MSG_INVALID_IMAGE_SOURCE =\n    'Please provide a valid Image Source. Supported image sources are: HTTP(S) URL, Base64 string, Data URL, Output Image from other component(s).';\nexport const ERR_MSG_INVALID_BINARY =\n    'Please provide a valid data that is either a Blob, SmythFileObject (Binary Output from any Component), ArrayBuffer, Buffer, Base64 string, Data URL, or HTTP(s) URL';\nexport const ERR_MSG_MAX_DEPTH = 'The maximum depth has been exceeded for the provided array or object.';\nexport const ERR_MSG_MAX_ARRAY_SIZE = 'The maximum array size has been exceeded for the provided array.';\nexport const ERR_MSG_MAX_OBJECT_SIZE = 'The maximum object size has been exceeded for the provided object.';\n\nexport const MAX_DEPTH = 10;\nexport const MAX_OBJECT_SIZE = 1000;\nexport const MAX_ARRAY_SIZE = 1000;\n\nexport const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\nexport const MAX_FILE_COUNT = 10;\n\n// Default maximum number of tokens allowed for LLM\nexport const DEFAULT_MAX_TOKENS_FOR_LLM = 2048;\n\n// life cycle tag for daily purge of s3 objects\nexport const S3_DAILY_PURGE_LIFECYCLE_TAG = 'ExpirationPolicy=DeleteDaily';\nexport const S3_WEEKLY_PURGE_LIFECYCLE_TAG = 'ExpirationPolicy=DeleteWeekly';\nexport const S3_MONTHLY_PURGE_LIFECYCLE_TAG = 'ExpirationPolicy=DeleteMonthly';\n\nexport const TOOL_USE_DEFAULT_MODEL = 'gpt-4o-mini';\n\nexport const COMP_NAMES = {\n    apiCall: 'APICall',\n    code: 'Code',\n    llmPrompt: 'PromptGenerator',\n    visionLLM: 'VisionLLM',\n};\n\nexport const JSON_RESPONSE_INSTRUCTION = `\nRespond ONLY with a valid, parsable JSON object. Follow these strict guidelines:\n1. The response must begin with '{' and end with '}'.\n2. Use double quotes for all keys and string values.\n3. Do not include any explanations, markdown, or text outside the JSON object.\n4. Do not use newlines or indentation within the JSON structure.\n5. For single-key responses, use the format: {\"result\": \"your content here\"}\n6. For multiple keys, use: {\"key1\": \"value1\", \"key2\": \"value2\", ...}\n\nExample of a valid response:\n{\"result\": \"This is a valid JSON response without any extra text.\"}\n`;\n","import { fileTypeFromBuffer } from 'file-type';\nimport { isValidString } from './string.utils';\nimport { MAX_FILE_SIZE } from '@sre/constants';\n\n/**\n * This function converts a text string to a base64 URL.\n * @param text\n * @returns\n */\nexport function textToBase64Url(text) {\n    // Create a Buffer from the string\n    const buffer = Buffer.from(text, 'utf-8');\n\n    // Convert the Buffer to a base64 string\n    const base64String = buffer.toString('base64');\n\n    // Construct the data URL\n    const base64Url = `data:text/plain;base64,${base64String}`;\n\n    return base64Url;\n}\n\nexport const isBase64FileUrl = (url: string): boolean => {\n    if (typeof url !== 'string') return false;\n\n    const regex = /^data:([\\w+\\-\\.]+\\/[\\w+\\-\\.]+);base64,(.*)$/;\n    const match = url.match(regex);\n    if (!match) return false;\n    const [, , base64Data] = match;\n\n    return isBase64(base64Data);\n};\n\nexport const getMimetypeFromBase64Data = async (data: string) => {\n    try {\n        data = _cleanUpBase64Data(data);\n\n        // Convert the base64 string back to a Buffer\n        const imageBuffer = Buffer.from(data, 'base64');\n\n        const type = await fileTypeFromBuffer(imageBuffer);\n        return type?.mime || '';\n    } catch (error) {\n        console.error('Error getting mimetype from base64 data: ', error);\n        return '';\n    }\n};\n\nexport async function extractBase64DataAndMimeType(data: string): Promise<{ data: string; mimetype: string }> {\n    if (typeof data !== 'string' || data?.length > MAX_FILE_SIZE) {\n        return { data: '', mimetype: '' };\n    }\n\n    if (isBase64FileUrl(data)) {\n        const regex = /^data:([^;]+);base64,(.*)$/;\n        const match = data.match(regex);\n        if (!match) return { data: '', mimetype: '' };\n        const [, mimetype, base64Data] = match;\n\n        return { data: _cleanUpBase64Data(base64Data), mimetype };\n    } else if (isBase64(data)) {\n        return { data: _cleanUpBase64Data(data), mimetype: await getMimetypeFromBase64Data(data) };\n    }\n\n    return { data: '', mimetype: '' };\n}\n\n//=== Legacy code below ===\n//@Forhad the functions below need to be reviewed and refactored\n\n/**\n * Remove all whitespace characters and literal \\n and \\s sequences\n *\n * @note It's common practice to split base64 data into multiple lines for better readability and to avoid issues with systems that can't handle very long lines. So we need to clean up newline characters from the base64 data before processing it.\n * @param {string} str - The input string.\n * @returns {string} The input string with all newline characters and escaped newline strings removed.\n */\nfunction cleanBase64(str: string): string {\n    return str.replace(/\\s|\\\\n|\\\\s/g, '');\n}\n\n/**\n * Checks if the input is a data URL.\n *\n * @param {string} input - The input string.\n * @returns {boolean} True if the input is a data URL, false otherwise.\n */\nexport function isDataUrl(input: string): boolean {\n    // Data URL pattern: data:[<mediatype>][;base64],<data>\n    const dataUrlPattern = /^data:([\\w+\\-\\.]+\\/[\\w+\\-\\.]+);base64,(.*)$/;\n\n    return dataUrlPattern.test(input);\n}\n\n/**\n * Checks if the given string is a valid Base64-encoded string.\n *\n * @param {string} str - The string to check.\n * @returns {boolean} True if the string is a valid Base64-encoded string, false otherwise.\n */\nexport function isRawBase64(str: string): boolean {\n    if (!isValidString(str)) return false;\n\n    const cleanedBase64Data = cleanBase64(str);\n\n    // Sometimes words like 'male' and hashes like md5, sha1, sha256, sha512 are detected as base64\n    if (cleanedBase64Data.length < 128) return false;\n\n    try {\n        const buffer = Buffer.from(cleanedBase64Data, 'base64');\n\n        // ignoring trailing padding ensures that the comparison is based on the actual content, not the padding\n        return buffer.toString('base64').replace(/=+$/, '') === cleanedBase64Data.replace(/=+$/, '');\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Parses a Base64-encoded string or data URL and extracts the MIME type and cleaned data.\n *\n * @param {string} input - The Base64-encoded string or data URL.\n * @returns {Promise<{ mimetype: string; data: string }>} An object containing the MIME type and the cleaned Base64 data.\n * @throws {Error} If the input is invalid.\n */\nexport async function parseBase64(input: string): Promise<{ mimetype: string; data: string }> {\n    try {\n        if (isDataUrl(input)) {\n            return parseDataUrl(input);\n        }\n\n        if (!isRawBase64(input)) {\n            throw new Error('Invalid base64 data!');\n        }\n\n        return await parseRawBase64(input);\n    } catch (error) {\n        throw new Error(`Error parsing base64 data: ${error.message}`);\n    }\n}\n\n/**\n * Parses a Base64-encoded data URL and extracts the MIME type and cleaned data.\n *\n * @param {string} input - The Base64-encoded data URL.\n * @returns {{ mimetype: string; data: string }} An object containing the MIME type and the cleaned Base64 data.\n * @throws {Error} If the input is invalid.\n */\nfunction parseDataUrl(input: string): { mimetype: string; data: string } {\n    const dataUrlPattern = /^data:([\\w+\\-\\.]+\\/[\\w+\\-\\.]+);base64,(.*)$/;\n    const matches = input.match(dataUrlPattern);\n\n    if (!matches) {\n        throw new Error('Invalid data URL!');\n    }\n\n    const [, mimetype, data] = matches;\n\n    if (!isRawBase64(data)) {\n        throw new Error('Invalid base64 data!');\n    }\n\n    return { mimetype, data: cleanBase64(data) };\n}\n\n/**\n * Parses a raw Base64-encoded string and extracts the MIME type and cleaned data.\n *\n * @param {string} input - The raw Base64-encoded string.\n * @returns {Promise<{ mimetype: string; data: string }>} An object containing the MIME type and the cleaned Base64 data.\n */\nasync function parseRawBase64(input: string): Promise<{ mimetype: string; data: string }> {\n    const cleanedData = cleanBase64(input);\n    const mimetype = await identifyMimetypeFromRawBase64(cleanedData);\n\n    return { mimetype, data: cleanedData };\n}\n\n/**\n * Identifies the MIME type from a raw Base64-encoded string.\n *\n * This function cleans the input Base64 string, converts it to a buffer, and then identifies the MIME type\n * using the `fileTypeFromBuffer` function.\n *\n * @param {string} data - The raw Base64-encoded string from which to identify the MIME type.\n * @returns {Promise<string>} A promise that resolves to the MIME type of the data, or an empty string if the MIME type cannot be determined.\n *\n * @throws {Error} If an error occurs during the process, it logs the error and returns an empty string.\n */\nexport async function identifyMimetypeFromRawBase64(data: string): Promise<string> {\n    try {\n        const cleanedData = cleanBase64(data);\n\n        // Convert the base64 string back to a Buffer\n        const buffer = Buffer.from(cleanedData, 'base64');\n\n        const type = await fileTypeFromBuffer(buffer);\n\n        return type?.mime || '';\n    } catch (error) {\n        throw new Error(`Error identifying MIME type from base64 data: ${error?.message}`);\n    }\n}\n\n/**\n * Identifies the MIME type from a raw Base64-encoded string.\n *\n * This function cleans the input Base64 string, converts it to a buffer, and then identifies the MIME type\n * using the `fileTypeFromBuffer` function.\n *\n * @param {string} data - The raw Base64-encoded string from which to identify the MIME type.\n * @returns {Promise<string>} A promise that resolves to the MIME type of the data, or an empty string if the MIME type cannot be determined.\n *\n * @throws {Error} If an error occurs during the process, it logs the error and returns an empty string.\n */\nexport async function identifyMimeTypeFromBase64(input: string): Promise<string> {\n    try {\n        const { data } = await parseBase64(input);\n\n        const buffer = Buffer.from(data, 'base64');\n\n        const type = await fileTypeFromBuffer(buffer);\n\n        return type?.mime || '';\n    } catch (error) {\n        throw new Error(`Error identifying MIME type from base64 data: ${error?.message}`);\n    }\n}\n\n/**\n * Calculates the size of a Base64-encoded string in bytes.\n *\n * This function validates the input string to ensure it is a valid Base64-encoded string,\n * converts it to a buffer, and then returns the byte length of the buffer.\n *\n * @param {string} str - The Base64-encoded string whose size is to be calculated.\n * @returns {number} The size of the Base64-encoded string in bytes.\n *\n * @throws {Error} If the input string is not a valid Base64-encoded string or if an error occurs during conversion.\n */\nexport function getSizeOfBase64(str: string): number {\n    if (!isValidString(str)) {\n        throw new Error('Invalid Base64 data!');\n    }\n\n    try {\n        const buffer = Buffer.from(str, 'base64');\n        return buffer.byteLength;\n    } catch (error) {\n        throw new Error(`Invalid Base64 data! ${error.message}`);\n    }\n}\n\n/**\n * Generates a Base64 Data URL from a raw Base64-encoded string.\n *\n * This function validates the input Base64 string, removes any newline characters,\n * and constructs a Data URL with the specified MIME type.\n *\n * @param {string} data - The raw Base64-encoded string to be converted into a Data URL.\n * @param {string} [mimetype='application/octet-stream'] - The MIME type of the data. Defaults to 'application/octet-stream'.\n * @returns {string} The generated Base64 Data URL.\n *\n * @throws {Error} If the input string is not a valid Base64-encoded string.\n */\nexport function makeBase64Url(data: string, mimetype: string = 'application/octet-stream'): string {\n    if (!isValidString(data)) {\n        throw new Error('Invalid Base64 data!');\n    }\n\n    // Remove any newline characters from the Base64 string\n    const cleanedData = data.replace(/\\n/g, '');\n\n    // Construct and return the Data URL\n    return `data:${mimetype};base64,${cleanedData}`;\n}\n\n/**\n ** It's common practice to split base64 data into multiple lines for better readability and to avoid issues with systems that can't handle very long lines.\n ** So we need to clean up newline characters from the base64 data before processing it.\n * @param {string} str - The input string.\n * @returns {string} The input string with all newline characters and escaped newline strings removed.\n */\nconst _cleanUpBase64Data = (str: string): string => {\n    // Check if the input is a string and is not excessively large\n    if (typeof str !== 'string' || str.length > MAX_FILE_SIZE) {\n        throw new Error('Invalid input');\n    }\n\n    // Remove all whitespace characters and literal \\n and \\s sequences\n    return str.replace(/\\s|\\\\n|\\\\s/g, '');\n};\n\nexport const isBase64 = (str: string): boolean => {\n    if (!str || !(typeof str === 'string')) return false;\n\n    str = _cleanUpBase64Data(str);\n\n    try {\n        // * sometimes word like 'male' and hash like md5, sha1, sha256, sha512 are detected as base64\n        if (str?.length < 128) return false;\n\n        const buffer = Buffer.from(str, 'base64');\n\n        return buffer.toString('base64') === str;\n    } catch {\n        return false;\n    }\n};\n","import { Readable } from 'stream';\nimport { isRawBase64 } from './base64.utils';\nimport { isBinaryFileSync } from 'isbinaryfile';\n\n// Helper function to convert stream to buffer\nexport async function streamToBuffer(stream: Readable): Promise<Buffer> {\n    const chunks: Buffer[] = [];\n    for await (const chunk of stream) {\n        chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk);\n    }\n    return Buffer.concat(chunks);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n// == Helpers from Legacy Smyth implementation ==============================================\n// FIXME : below functions should probably be converted to a validator\n\n//export declare function isBinaryFile(file: string | Buffer, size?: number): Promise<boolean>;\n//export declare function isBinaryFileSync(file: string | Buffer, size?: number): boolean;\nconst binaryMimeTypes = ['image/', 'audio/', 'video/', 'application/pdf', 'application/zip', 'application/octet-stream'];\n\nexport function dataToBuffer(data: any): Buffer | null {\n    let bufferData;\n    switch (true) {\n        case data instanceof ArrayBuffer:\n            bufferData = Buffer.from(new Uint8Array(data));\n            break;\n        case ArrayBuffer.isView(data) && !(data instanceof DataView):\n            bufferData = Buffer.from(new Uint8Array(data.buffer));\n            break;\n        case data instanceof DataView:\n            bufferData = Buffer.from(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\n            break;\n        case Buffer.isBuffer(data):\n            bufferData = data;\n            break;\n        case typeof data === 'string':\n            bufferData = Buffer.from(data, 'utf-8');\n            break;\n        default:\n            return null;\n    }\n\n    return bufferData;\n}\n\nexport const getSizeFromBinary = (data: any) => {\n    const buffer = dataToBuffer(data);\n    if (!buffer) return 0;\n    return buffer.byteLength;\n};\n\nexport const isPlainObject = (data: any): boolean => {\n    return (\n        typeof data === 'object' &&\n        data !== null &&\n        !Array.isArray(data) &&\n        Object.prototype.toString.call(data) === '[object Object]' &&\n        data.constructor === Object\n    );\n};\n\n// isBuffer checks if the provided data is a Buffer object in Node.js.\nexport const isBuffer = (data: any): boolean => {\n    try {\n        return Buffer.isBuffer(data);\n    } catch {\n        // Buffer.isBuffer throws error when non-array Object is passed\n        return false;\n    }\n};\n\n// isBinaryMimeType checks if the provided mimetype indicates binary data.\nexport const isBinaryMimeType = (mimetype): boolean => {\n    if (mimetype) {\n        return binaryMimeTypes.some((type) => mimetype.startsWith(type));\n    }\n    return false;\n};\n\n// isBinaryData checks if the provided data is binary.\n// If the data is a Buffer, ArrayBuffer, TypedArray, or DataView, it checks if it contains binary data.\nexport const isBinaryData = (data): boolean => {\n    // To prevent returning true when we have emojis in the string like \"Hello ðŸ˜€\"\n    if (typeof data === 'string') return false;\n\n    try {\n        const buffer = dataToBuffer(data);\n        if (!buffer) return false;\n        return isBinaryFileSync(buffer, buffer.byteLength);\n    } catch (error) {\n        return false;\n    }\n};\nexport function isUrl(str: string): boolean {\n    if (typeof str !== 'string') return false;\n    // This regex checks for protocol, hostname, domain, port (optional), path (optional), and query string (optional)\n    //const regex = /^(https?:\\/\\/)([^\\s.]+\\.[^\\s]{2,})(:[0-9]{1,5})?(\\/[^\\s]*)?(\\?[^\\s]*)?$/i;\n    const regex = /^([a-zA-Z0-9]+:\\/\\/)([^\\s.]+\\.[^\\s]{2,})(:[0-9]{1,5})?(\\/[^\\s]*)?(\\?[^\\s]*)?$/i;\n\n    return regex.test(str);\n}\n\nexport const isSmythFileObject = (data: any): boolean => {\n    return !!(typeof data === 'object' && data !== null && data?.url && isUrl(data?.url) && 'size' in data && 'mimetype' in data);\n};\n\nexport const isBufferObject = (data: Record<string, any>): boolean => {\n    if (!data) return false;\n\n    return typeof data === 'object' && data !== null && data?.buffer && isBuffer(data.buffer) && 'size' in data && 'mimetype' in data;\n};\n\nexport const isBase64Object = (data: Record<string, any>): boolean => {\n    if (!data) return false;\n\n    return typeof data === 'object' && data !== null && data?.base64 && isRawBase64(data.base64) && 'size' in data && 'mimetype' in data;\n};\n","/**\n * This function parses the command line arguments and returns an object with the parsed values.\n * The expected format is --file ./path/to/file.txt or --settings key1=value1 key2=value2\n * Examples:\n *  --file ./path/to/file.txt : calling parseCLIArgs('file', process.argv) will return {file: './path/to/file.txt'}\n *  --settings key1=value1 key2=value2 : calling parseCLIArgs('settings', process.argv) will return {settings: {key1: 'value1', key2: 'value2'}}\n *  it can also parse multiple arguments at once, for example:\n *      parseCLIArgs(['file', 'settings'], process.argv) will return {file: './path/to/file.txt', settings: {key1: 'value1', key2: 'value2'}}\n *\n * @param argList the argument to parse\n * @param argv the command line arguments, usually process.argv\n * @returns parsed arguments object\n */\n\nexport function parseCLIArgs(argList: string | Array<string>, argv?: Array<string>): Record<string, any> {\n    if (!argv) argv = process.argv;\n    const args = argv;\n    const result = {};\n    const mainArgs = Array.isArray(argList) ? argList : [argList];\n    mainArgs.forEach((mainArg) => {\n        const mainArgIndex = args.indexOf(`--${mainArg}`);\n        if (mainArgIndex !== -1) {\n            const values: any = [];\n            for (let i = mainArgIndex + 1; i < args.length; i++) {\n                if (args[i].startsWith('--')) break;\n                values.push(args[i]);\n            }\n\n            if (values.length === 1 && values[0].includes('=')) {\n                const keyValuePairs = {};\n                const [key, ...valParts] = values[0].split('=');\n                const val = valParts.join('=').replace(/^\"|\"$/g, '');\n                keyValuePairs[key] = val;\n                result[mainArg] = keyValuePairs;\n            } else if (values.length === 1) {\n                result[mainArg] = values[0];\n            } else if (values.length > 1) {\n                const keyValuePairs = {};\n                values.forEach((value) => {\n                    const [key, ...valParts] = value.split('=');\n                    const val = valParts.join('=').replace(/^\"|\"$/g, '');\n                    keyValuePairs[key] = val;\n                });\n                result[mainArg] = keyValuePairs;\n            }\n        }\n    });\n\n    return result;\n}\n\n/**\n * List all cli main arguments\n * example : node index.js --file ./path/to/file.txt --settings key1=value1 key2=value2\n * calling getMainArgs(process.argv) will return ['file', 'settings']\n */\nexport function getMainArgs(argv?: Array<string>): Array<string> {\n    if (!argv) argv = process.argv;\n    const args = argv;\n    const result = [];\n    for (let i = 2; i < args.length; i++) {\n        if (args[i].startsWith('--')) {\n            result.push(args[i].replace(/^--/, ''));\n        }\n    }\n\n    return result;\n}\n","export function isDigits(str: string): boolean {\n    if (typeof str === 'number') return true;\n\n    if (typeof str !== 'string') return false;\n\n    const numRegex = /^-?\\d+(\\.\\d+)?$/;\n    return numRegex.test(str.trim());\n}\n\nexport function isSafeNumber(str: string): boolean {\n    const num = parseFloat(str);\n    return !isNaN(num) && num <= Number.MAX_SAFE_INTEGER && num >= Number.MIN_SAFE_INTEGER && num.toString() === str.trim();\n}\n","interface RangeValidationArgs {\n    min?: number;\n    max?: number;\n}\n\n/**\n * Custom validation function to check if a string contains only specified characters.\n * @param {string} value - The string to validate.\n * @returns {string} - The validated string.\n */\nexport function validateCharacterSet(value: string): boolean {\n    if (value === '') return true;\n    // Check for {{sometext}} structures and split the string\n    const parts = value.split(/(\\{\\{[^}]+\\}\\})/).filter(Boolean);\n\n    for (const part of parts) {\n        if (part.startsWith('{{') && part.endsWith('}}')) {\n            // Check if the content inside {{...}} is not empty\n            const innerContent = part.slice(2, -2).trim();\n            if (innerContent === '') {\n                return false; // Empty content inside {{...}}\n            }\n        } else {\n            // Check for valid characters outside of {{...}}\n            if (!/^[a-zA-Z0-9\\-_.]+$/.test(part)) {\n                return false; // Invalid characters found\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Validates whether a given string value can be converted to an integer that falls within a specified range.\n * This function is designed to be used as a custom validator in Joi schemas.\n *\n * @param {RangeValidationArgs} args - An object containing optional 'min' and 'max' properties to define the range.\n * @returns {Function} A function that takes a string value and a Joi helper object, and performs the validation.\n *\n * The validation function first converts the string value to a number. It then checks if the number is within the\n * specified range (if provided). If the value is not a number or falls outside the range, it throws an error with a\n * descriptive message.\n *\n * The error message includes the field name for clarity, using the label from the Joi schema if available.\n */\nexport const validateInteger = (args: RangeValidationArgs) => {\n    return (value: string, helpers: any) => {\n        const numValue = Number(value);\n        const fieldName = helpers.schema._flags.label || helpers.state.path[helpers.state.path.length - 1];\n\n        // Check if the value is a number\n        if (isNaN(numValue)) {\n            throw new Error(`The value for '${fieldName}' must be a number`);\n        }\n\n        // Range validations\n        if (args.min !== undefined && args.max !== undefined) {\n            if (numValue < args.min || numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be from ${args.min} to ${args.max}`);\n            }\n        } else if (args.min !== undefined) {\n            if (numValue < args.min) {\n                throw new Error(`The value for '${fieldName}' must be greater or equal to ${args.min}`);\n            }\n        } else if (args.max !== undefined) {\n            if (numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be less or equal to ${args.max}`);\n            }\n        }\n\n        return value; // Value is valid\n    };\n};\n","import dotenv from 'dotenv';\ndotenv.config();\n//FIXME : this is a legacy structure from Smyth SaaS we need to convert it to a Service/Connector structure\nconst config = {\n    env: {\n        LOG_LEVEL: process.env.LOG_LEVEL || 'none',\n        LOG_FILTER: process.env.LOG_FILTER || '',\n\n        OPENAI_API_KEY: process.env.OPENAI_API_KEY,\n        ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,\n\n        DATA_PATH: process.env.DATA_PATH,\n\n        NODE_ENV: process.env?.NODE_ENV,\n\n        AGENT_DOMAIN: process.env?.AGENT_DOMAIN,\n\n        PROD_AGENT_DOMAIN: process.env?.PROD_AGENT_DOMAIN,\n\n        AGENT_DOMAIN_PORT: process.env?.AGENT_DOMAIN_PORT,\n        CODE_SANDBOX_URL: process.env?.CODE_SANDBOX_URL,\n        TOGETHER_AI_API_URL: process.env?.TOGETHER_AI_API_URL,\n\n        REDIS_SENTINEL_HOSTS: process.env?.REDIS_SENTINEL_HOSTS || '',\n        REDIS_MASTER_NAME: process.env?.REDIS_MASTER_NAME,\n        REDIS_PASSWORD: process.env?.REDIS_PASSWORD,\n\n        AWS_ACCESS_KEY_ID: process.env.AWS_ACCESS_KEY_ID,\n        AWS_SECRET_ACCESS_KEY: process.env.AWS_SECRET_ACCESS_KEY,\n        AWS_S3_REGION: process.env.AWS_S3_REGION,\n        AWS_S3_BUCKET_NAME: process.env.AWS_S3_BUCKET_NAME,\n\n        PINECONE_API_KEY: process.env.PINECONE_API_KEY,\n        PINECONE_INDEX_NAME: process.env.PINECONE_INDEX_NAME,\n\n        LOGTO_SERVER: process.env.LOGTO_SERVER,\n        SMYTH_VAULT_API_BASE_URL: process.env.SMYTH_VAULT_API_BASE_URL,\n    },\n    agent: {\n        ENDPOINT_PREFIX: '/api',\n    },\n};\n\nexport default config;\n","import 'dotenv/config';\nimport winston from 'winston';\nimport Transport from 'winston-transport';\nimport { parseCLIArgs } from '../utils';\nimport config from '@sre/config';\n\nwinston.addColors({\n    error: 'red',\n    warn: 'yellow',\n    info: 'green',\n    debug: 'blue',\n});\n\nconst logLevelMap = {\n    min: 'info',\n    full: 'debug',\n};\n\nlet logLevel = () => {\n    let val = parseCLIArgs('debug')?.debug || config?.env?.LOG_LEVEL || 'none';\n    if (logLevelMap[val]) val = logLevelMap[val];\n    return !['none', 'error', 'warn', 'info', 'debug'].includes(val) ? 'none' : val;\n};\n\n// Retrieve the DEBUG environment variable and split it into an array of namespaces\nconst namespaces = (config.env.LOG_FILTER || '').split(',');\n\n// Create a Winston format that filters messages based on namespaces\nconst namespaceFilter = winston.format((info) => {\n    // If DEBUG is not set, log everything\n    if (!config.env.LOG_FILTER || namespaces.some((ns) => info.module?.includes(ns))) {\n        return info;\n    }\n    return false; // Filter out messages that do not match the namespace\n})();\n\n// Custom stream for your transport\nclass ArrayTransport extends Transport {\n    private logs: any[];\n    constructor(opts) {\n        super(opts);\n        // Configure your storage array\n        this.logs = opts.logs;\n    }\n\n    log(info, callback) {\n        setImmediate(() => {\n            this.emit('logged', info);\n        });\n\n        // Perform the writing to the array storage\n        this.logs.push(`${info.level}: ${info.message}`);\n\n        // Perform the writing to the remote service\n        callback();\n    }\n}\n\nexport class LogHelper {\n    public startTime = Date.now();\n    public get output() {\n        return Array.isArray(this.data) ? this.data.join('\\n') : undefined;\n    }\n    public get elapsedTime() {\n        return Date.now() - this.startTime;\n    }\n    constructor(private _logger: winston.Logger, public data, private labels: { [key: string]: any }) {}\n\n    public log(...args) {\n        this._logger.log('info', formatLogMessage(...args), this.labels);\n    }\n    public warn(...args) {\n        this._logger.log('warn', formatLogMessage(...args), this.labels);\n    }\n    public debug(...args) {\n        this._logger.log('debug', formatLogMessage(...args), this.labels);\n    }\n    public info(...args) {\n        this._logger.log('info', formatLogMessage(...args), this.labels);\n    }\n    public verbose(...args) {\n        this._logger.log('verbose', formatLogMessage(...args), this.labels);\n    }\n\n    public error(...args) {\n        const stack = new Error().stack;\n\n        this._logger.log('error', formatLogMessage(...args), { ...this.labels, stack });\n    }\n\n    public close() {\n        this._logger.clear();\n        this._logger.close();\n    }\n}\n\nconst colorizedFormat = winston.format.printf((info) => {\n    return `${info.timestamp} ${winston.format.colorize().colorize(info.level, `${info.level}: ${info.message}`)}`;\n});\n\nconst MAX_LOG_MESSAGE_LENGTH = 500;\n\nfunction redactLogMessage(logMessage: string) {\n    if (config.env.NODE_ENV !== 'PROD') return logMessage; //only redact logs in PROD\n    if (logMessage.length > 500) {\n        return logMessage;\n    }\n\n    const sensitiveWords = ['password', 'eyJ', 'token', 'email', 'secret', 'key', 'apikey', 'api_key', 'auth', 'credential'];\n    const obfuscatedString = ' [!! SmythOS::REDACTED_DATA !!] ';\n\n    // Iterate through the sensitive words list and replace sensitive data in the log message\n\n    for (const sensitiveWord of sensitiveWords) {\n        // Create a regular expression to find the sensitive word followed by any character (non-greedy) until a space, newline, or separator is found.\n        const regex = new RegExp(`(${sensitiveWord})((?:[^\\\\n]{0,29}(?=\\\\n))|(?:[^\\\\n]{30}\\\\S*))`, 'gmi');\n\n        // Replace sensitive data with the obfuscated string\n        logMessage = logMessage.replace(regex, `$1${obfuscatedString}`);\n    }\n\n    return logMessage;\n}\n// function redactLogMessage(logMessage: string, beforeChars: number = 15, afterChars: number = 30): string {\n//     const sensitiveWords = ['password', 'eyJ', 'token', 'email', 'secret', 'key', 'apikey', 'api_key', 'auth', 'credential'];\n//     const obfuscatedString = ' [!!!REDACTED!!!] ';\n\n//     // Iterate through the sensitive words list and replace sensitive data in the log message\n//     for (const sensitiveWord of sensitiveWords) {\n//         // Escape special regex characters in the sensitive word\n//         const escapedWord = sensitiveWord.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n//         // Create a regular expression to match characters before and after the sensitive word\n//         const regex = new RegExp(`(.{0,${beforeChars}})(${escapedWord})(.{0,${afterChars}})`, 'gmi');\n\n//         // Replace the entire match with the obfuscated string\n//         logMessage = logMessage.replace(regex, obfuscatedString);\n//     }\n\n//     return logMessage;\n// }\n\nfunction createBaseLogger(memoryStore?: any[]) {\n    const logger = winston.createLogger({\n        //level: 'info', // log level\n\n        format: winston.format.combine(\n            winston.format((info) => {\n                if (config.env.LOG_LEVEL == 'none' || logLevel() == 'none' || logLevel() == '') return false; // skip logging if log level is none\n\n                // Apply redaction to the log message\n                //info.message = redactSecrets(info.message, sensitiveOptions);\n\n                info.message = redactLogMessage(info.message);\n                return info;\n            })(),\n            winston.format.timestamp(),\n            winston.format.errors({\n                stack: true,\n            }),\n            winston.format.splat(),\n            winston.format.json()\n        ),\n\n        transports: [\n            new winston.transports.Console({\n                level: 'error',\n                //handleExceptions: true,\n                format: winston.format.combine(\n                    winston.format.printf((info) => {\n                        let message = info.message;\n                        message = message?.length > MAX_LOG_MESSAGE_LENGTH ? message.substring(0, MAX_LOG_MESSAGE_LENGTH) + '...' : message;\n                        return `${info.level}:${info.module || ''} ${message} ${info.stack || ''}`;\n                    })\n                ),\n                stderrLevels: ['error'], // Define levels that should be logged to stderr\n            }),\n            new winston.transports.Console({\n                level: logLevel(),\n                format: winston.format.combine(\n                    namespaceFilter,\n                    winston.format.printf((info) => {\n                        const module = info.module ? winston.format.colorize().colorize(info.level, ` [${info.module}]`) : '';\n                        const ns = winston.format.colorize().colorize(info.level, `${info.level}${module}`);\n\n                        let message = info.message;\n                        message = message?.length > MAX_LOG_MESSAGE_LENGTH ? message.substring(0, MAX_LOG_MESSAGE_LENGTH) + '...' : message;\n\n                        return `${ns} - ${message}`;\n                    })\n                ),\n\n                //handleExceptions: true,\n            }),\n        ],\n    });\n\n    if (Array.isArray(memoryStore)) {\n        logger.add(\n            new ArrayTransport({\n                level: 'debug',\n                logs: memoryStore,\n            })\n        );\n    }\n\n    return logger;\n}\n\nfunction formatLogMessage(...args) {\n    return args\n        .map((arg) => {\n            // If the argument is an object (and not null), serialize it to JSON\n            if (typeof arg === 'object' && arg !== null && !(arg instanceof Error)) {\n                return JSON.stringify(arg, null, 2); // set the space to 2 for better readability\n            }\n            // Otherwise, just convert it to a string in case it's not\n            return String(arg);\n        })\n        .join(' '); // Concatenate all arguments with a space\n}\n\nfunction createLabeledLogger(labels: { [key: string]: any }, memoryStore?: any[]) {\n    const _logger = createBaseLogger(memoryStore);\n\n    _logger.defaultMeta = labels;\n\n    const logger = new LogHelper(_logger, memoryStore, labels);\n\n    return logger;\n}\n\nexport function Logger(module: string, withMemoryStore = false) {\n    return createLabeledLogger({ module }, withMemoryStore ? [] : undefined);\n}\n","import { Logger } from '../helpers/Log.helper';\nconst logger = Logger('DummyConnector');\n/**\n * DummyConnector is a placeholder for unimplemented connectors, it logs a warning when a method is called in order to help developers identify missing connectors\n */\nexport const DummyConnector: any = new Proxy(\n    {},\n    {\n        get: function (target, prop, receiver) {\n            // Check if the property being accessed is a function\n            if (typeof target[prop] === 'function') {\n                return target[prop];\n            } else {\n                // Return a function that logs \"unavailable\"\n                return function (...args: any[]) {\n                    logger.warn(`[!!] Unimplemented Connector tried to call : ${prop.toString()} with arguments:`, args);\n                };\n            }\n        },\n    }\n);\n","import { LocalCache } from '@sre/helpers/LocalCache.helper';\nimport { Logger } from '../helpers/Log.helper';\nimport { createHash } from 'crypto';\n\nconst console = Logger('Connector');\nconst lCache = new LocalCache();\n\nexport class Connector {\n    public name: string;\n    public started = false;\n    private _readyPromise: Promise<boolean>;\n\n    constructor(config: any = {}) {}\n\n    /**\n     * Creates a new instance of the current class using the provided settings.\n     * This method can be called on both Connector instances and its subclasses.\n     *\n     * @param config - Configuration settings for the new instance.\n     * @returns A new instance of the current class.\n     */\n    public instance(config: any): this {\n\n        const configHash = createHash('sha256').update(JSON.stringify(config)).digest('hex');\n        const key = `${this.name}-${configHash}`;\n\n        if (lCache.has(key)) {\n            return lCache.get(key) as this;\n        }\n\n        // if not in cache, create a new instance from the concrete class\n        const constructor = this.constructor as { new (config: any): any };\n        const instance = new constructor(config);\n        lCache.set(key, instance, 60 * 60 * 1000); // cache for 1 hour\n\n        return instance;\n    }\n\n\n    public async start() {\n        console.info(`Starting ${this.name} connector ...`);\n        this.started = true;\n    }\n\n    public async stop() {\n        console.info(`Stopping ${this.name} connector ...`);\n    }\n\n    public ready() {\n        if (!this._readyPromise) {\n            this._readyPromise = new Promise((resolve) => {\n                let maxWait = 10000;\n                const tick = 100;\n                if (this.started) {\n                    resolve(true);\n                } else {\n                    const interval = setInterval(() => {\n                        if (this.started) {\n                            clearInterval(interval);\n                            resolve(true);\n                        }\n\n                        maxWait -= tick;\n                        if (maxWait <= 0) {\n                            clearInterval(interval);\n                            resolve(false);\n                        }\n                    }, tick);\n                }\n            });\n        }\n        return this._readyPromise;\n    }\n}\n","interface CacheItem<T> {\n    value: T;\n    expiry: number;\n}\n\nexport class LocalCache<K, V> {\n    private cache: Map<K, V>;\n    private expiryMap: Map<K, number>;\n    private timeouts: Map<K, NodeJS.Timeout>;\n    private defaultTTL: number = 60 * 60 * 1000;\n\n    constructor(defaultTTL: number = 60 * 60 * 1000) {\n        this.defaultTTL = defaultTTL;\n        this.cache = new Map<K, V>();\n        this.expiryMap = new Map<K, number>();\n        this.timeouts = new Map<K, NodeJS.Timeout>();\n    }\n\n    set(key: K, value: V, ttlMs: number = this.defaultTTL): void {\n        this.cache.set(key, value);\n        const expiry = Date.now() + ttlMs;\n        this.expiryMap.set(key, expiry);\n\n        // Clear any existing timeout for this key\n        this.clearTimeout(key);\n\n        // Set a new timeout to remove the item when it expires\n        const timeout = setTimeout(() => {\n            this.delete(key);\n        }, ttlMs);\n        this.timeouts.set(key, timeout);\n    }\n\n    get(key: K): V | undefined {\n        if (!this.has(key)) {\n            return undefined;\n        }\n        return this.cache.get(key);\n    }\n\n    has(key: K): boolean {\n        if (!this.cache.has(key)) {\n            return false;\n        }\n        const expiry = this.expiryMap.get(key);\n        if (expiry && Date.now() > expiry) {\n            this.delete(key);\n            return false;\n        }\n        return true;\n    }\n\n    delete(key: K): boolean {\n        this.clearTimeout(key);\n        this.expiryMap.delete(key);\n        return this.cache.delete(key);\n    }\n\n    clear(): void {\n        for (const key of this.cache.keys()) {\n            this.clearTimeout(key);\n        }\n        this.cache.clear();\n        this.expiryMap.clear();\n        this.timeouts.clear();\n    }\n\n    private clearTimeout(key: K): void {\n        const timeout = this.timeouts.get(key);\n        if (timeout) {\n            clearTimeout(timeout);\n            this.timeouts.delete(key);\n        }\n    }\n}\n","import { EventEmitter } from 'events';\n\nconst SystemEvents = new EventEmitter();\n\nexport default SystemEvents;\n","import { SREConnectorConfig, TConnectorService, TServiceRegistry } from '@sre/types/SRE.types';\nimport { DummyConnector } from './DummyConnector';\nimport { Logger } from '../helpers/Log.helper';\nimport { Connector } from './Connector.class';\nimport { isSubclassOf } from '@sre/utils';\nimport SystemEvents from './SystemEvents';\nimport { StorageConnector } from '@sre/IO/Storage.service/StorageConnector';\nimport { CacheConnector } from '@sre/MemoryManager/Cache.service';\nimport { LLMConnector } from '@sre/LLMManager/LLM.service/LLMConnector';\nimport { VaultConnector } from '@sre/Security/Vault.service/VaultConnector';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport { AgentDataConnector } from '@sre/AgentManager/AgentData.service/AgentDataConnector';\nimport { VectorDBConnector } from '@sre/IO/VectorDB.service/VectorDBConnector';\nimport { CLIConnector } from '@sre/IO/CLI.service/CLIConnector';\nimport { NKVConnector } from '@sre/IO/NKV.service/NKVConnector';\nimport { RouterConnector } from '@sre/IO/Router.service/RouterConnector';\nimport { ManagedVaultConnector } from '@sre/Security/ManagedVault.service/ManagedVaultConnector';\nconst console = Logger('ConnectorService');\n\nconst Connectors = {};\n\nconst ConnectorInstances: any = {};\nlet ServiceRegistry: TServiceRegistry = {};\nlet _ready = false;\nSystemEvents.on('SRE:Booted', (services) => {\n    ServiceRegistry = services;\n    _ready = true;\n});\nexport class ConnectorService {\n    //Singleton\n    // private constructor() {\n    //     SystemEvents.on('SRE:Booted', (services) => {\n    //         ServiceRegistry = services;\n    //     });\n    // }\n    // private static instance: ConnectorService;\n    // public static get Instance(): ConnectorService {\n    //     if (!ConnectorService.instance) {\n    //         ConnectorService.instance = new ConnectorService();\n    //     }\n    //     return ConnectorService.instance;\n    // }\n    public static get ready() {\n        return _ready;\n    }\n\n    public static get service(): TServiceRegistry {\n        return ServiceRegistry;\n    }\n    /**\n     * Allows SRE services to register their connectors, a registered conector can then be initialized and used by SRE or its services\n     * @param connectorType\n     * @param connectorName\n     * @param connectorConstructor\n     * @returns\n     */\n    static register(connectorType: TConnectorService, connectorName: string, connectorConstructor: any) {\n        if (typeof connectorConstructor !== 'function' || !isSubclassOf(connectorConstructor, Connector)) {\n            console.error(`Invalid Connector ${connectorType}:${connectorName}`);\n            return;\n        }\n        if (!Connectors[connectorType]) {\n            Connectors[connectorType] = {};\n        }\n        Connectors[connectorType][connectorName] = connectorConstructor;\n    }\n\n    /**\n     * The init method instantiates a connector and starts it, a connector cannot be used before it is initialized\n     * Usually the initialization phase happens during the SRE startup, but some connectors can be initialized later if they are not mandatory for the SRE to start\n     *\n     *\n     * @param connectorType\n     * @param connectorName\n     * @param settings\n     * @param isDefault\n     * @returns\n     */\n    static init(connectorType: TConnectorService, connectorName: string, connectorId?: string, settings: any = {}, isDefault = false) {\n        if (ConnectorInstances[connectorType]?.[connectorName]) {\n            throw new Error(`Connector ${connectorType}:${connectorName} already initialized`);\n        }\n\n        const entry = Connectors[connectorType];\n        if (!entry) return;\n        const connectorConstructor = entry[connectorName];\n\n        if (connectorConstructor) {\n            const connector: Connector = new connectorConstructor(settings);\n\n            connector.start();\n            if (!ConnectorInstances[connectorType]) ConnectorInstances[connectorType] = {};\n            const id = connectorId || connectorName;\n            ConnectorInstances[connectorType][id] = connector;\n\n            if (!ConnectorInstances[connectorType].default && isDefault) {\n                ConnectorInstances[connectorType].default = connector;\n            }\n        }\n    }\n    static async _stop() {\n        for (let connectorName in ConnectorInstances) {\n            let allConnectors: Connector[] = Object.values(ConnectorInstances[connectorName]);\n            //deduplicate\n            allConnectors = allConnectors.filter((value, index, self) => self.indexOf(value) === index);\n            for (let connector of allConnectors) {\n                connector.stop();\n            }\n        }\n    }\n    static getInstance<T>(connectorType: TConnectorService, connectorName: string = 'default'): T {\n        const instance = ConnectorInstances[connectorType]?.[connectorName] as T;\n        if (!instance) {\n            if (ConnectorInstances[connectorType] && Object.keys(ConnectorInstances[connectorType]).length > 0) {\n                //return the first instance\n                return ConnectorInstances[connectorType][Object.keys(ConnectorInstances[connectorType])[0]] as T;\n            }\n            console.warn(`Connector ${connectorType} not initialized returning DummyConnector`);\n            //print stack trace\n            console.debug(new Error().stack);\n            return DummyConnector as T;\n        }\n        return instance;\n    }\n\n    // Storage?: StorageService;\n    // Cache?: CacheService;\n    // LLM?: LLMService;\n    // Vault?: VaultService;\n    // Account?: AccountService;\n\n    static getStorageConnector(name?: string): StorageConnector {\n        return ConnectorService.getInstance<StorageConnector>(TConnectorService.Storage, name);\n    }\n\n    static getCacheConnector(name?: string): CacheConnector {\n        return ConnectorService.getInstance<any>(TConnectorService.Cache, name);\n    }\n\n    static getVectorDBConnector(name?: string): VectorDBConnector {\n        return ConnectorService.getInstance<VectorDBConnector>(TConnectorService.VectorDB, name);\n    }\n\n    static getNKVConnector(name?: string): NKVConnector {\n        return ConnectorService.getInstance<NKVConnector>(TConnectorService.NKV, name);\n    }\n\n    static getLLMConnector(name?: string): LLMConnector {\n        return ConnectorService.getInstance<LLMConnector>(TConnectorService.LLM, name);\n    }\n\n    static getVaultConnector(name?: string): VaultConnector {\n        return ConnectorService.getInstance<VaultConnector>(TConnectorService.Vault, name);\n    }\n\n    static getManagedVaultConnector(name?: string): ManagedVaultConnector {\n        return ConnectorService.getInstance<ManagedVaultConnector>(TConnectorService.ManagedVault, name);\n    }\n\n    static getAccountConnector(name?: string): AccountConnector {\n        return ConnectorService.getInstance<AccountConnector>(TConnectorService.Account, name);\n    }\n\n    static getAgentDataConnector(name?: string): AgentDataConnector {\n        return ConnectorService.getInstance<AgentDataConnector>(TConnectorService.AgentData, name);\n    }\n\n    static getCLIConnector(name?: string): CLIConnector {\n        return ConnectorService.getInstance<CLIConnector>(TConnectorService.CLI, name);\n    }\n\n    //TODO: add missing get<Connector> functions : e.g getAgentData(), getCache() etc ...\n\n    static hasInstance(connectorType: TConnectorService, connectorName: string = 'default') {\n        const instance = ConnectorInstances[connectorType]?.[connectorName];\n        return instance && instance !== DummyConnector;\n    }\n\n    static getRouterConnector(name?: string): RouterConnector {\n        return ConnectorService.getInstance<RouterConnector>(TConnectorService.Router, name);\n    }\n}\n\nexport abstract class ConnectorServiceProvider {\n    public abstract register();\n    public init() {}\n    public constructor() {\n        this.register();\n    }\n}\n","import { Logger } from '@sre/helpers/Log.helper';\nconst console = Logger('EmbodimentSettings');\n\nexport default class EmbodimentSettings {\n    private _embodiments: any;\n    private _ready = false;\n\n    constructor(agentId) {\n        this.init(agentId);\n    }\n\n    async init(data) {\n        this._embodiments = data;\n        this._ready = true;\n    }\n    public ready(maxWait = 10000) {\n        return new Promise((resolve, reject) => {\n            const interval = setInterval(() => {\n                if (this._ready) {\n                    clearInterval(interval);\n                    resolve(true);\n                }\n                maxWait -= 100;\n            }, 100);\n\n            setTimeout(() => {\n                clearInterval(interval);\n                reject(false);\n            }, maxWait);\n        });\n    }\n\n    public get(embodimentType: string, key?: string) {\n        if (!this._embodiments) return undefined;\n        const _embodiment = this._embodiments.find((embodiment: any) => embodiment.type?.toLowerCase() === embodimentType.toLowerCase());\n\n        if (!_embodiment) {\n            //console.error(`Error: No ${embodimentType} embodiment found for agent`);\n        }\n        if (key) {\n            return _embodiment?.properties?.[key];\n        }\n        return _embodiment?.properties;\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport EmbodimentSettings from './EmbodimentSettings.class';\n\nimport { Logger } from '@sre/helpers/Log.helper';\nconst console = Logger('AgentSettings');\n\nexport default class AgentSettings {\n    private _settings: any;\n    public embodiments?: EmbodimentSettings;\n    private _ready = false;\n\n    constructor(agentId?) {\n        if (agentId) {\n            this.init(agentId);\n        }\n    }\n\n    async init(agentId) {\n        const agentDataConnector = ConnectorService.getAgentDataConnector();\n        this._settings = (await agentDataConnector.getAgentSettings(agentId).catch((e) => {})) || {};\n        this.embodiments = new EmbodimentSettings(this._settings.embodiments);\n        this._ready = true;\n    }\n\n    public ready(maxWait = 10000) {\n        return new Promise((resolve, reject) => {\n            const interval = setInterval(() => {\n                if (this._ready) {\n                    clearInterval(interval);\n                    resolve(true);\n                }\n                maxWait -= 100;\n            }, 100);\n\n            setTimeout(() => {\n                clearInterval(interval);\n                reject(false);\n            }, maxWait);\n        });\n    }\n    public get(key: string) {\n        return this._settings?.find((s) => s.key === key)?.value;\n    }\n    public set(key: string, value: any) {\n        this._settings[key] = value;\n    }\n    public has(key: string) {\n        return this._settings[key];\n    }\n}\n","//==[ SRE: ACL Types ]======================\n\nexport enum TAccessLevel {\n    None = 'none',\n    Owner = 'owner',\n    Read = 'read',\n    Write = 'write',\n}\n\nexport enum TAccessRole {\n    Agent = 'agent',\n    User = 'user',\n    Team = 'team',\n    Public = 'public',\n}\n\n// role and level mappings are used for ACL serialization / deserialization\nexport const RoleMap = {\n    user: 'u',\n    agent: 'a',\n    team: 't',\n    public: 'p',\n};\n\nexport const LevelMap = {\n    none: 'n',\n    owner: 'o',\n    read: 'r',\n    write: 'w',\n};\n\n// Reverse mappings\nexport const ReverseRoleMap = Object.fromEntries(Object.entries(RoleMap).map(([k, v]) => [v, k]));\nexport const ReverseLevelMap = Object.fromEntries(Object.entries(LevelMap).map(([k, v]) => [v, k]));\n\n/**\n * an ACLEntry is a list of access levels for a given owner.\n * an owner can be an agent, a user, a team or the public.\n */\nexport type TACLEntry = {\n    [hashedOwnerKey: string]: TAccessLevel[] | undefined;\n};\n/**\n * The Access Control List (ACL) is a list of access rights for a given resource.\n * Each entry in this ACL represents a role\n * Role entries define a list of owners of the resource and the access levels they have.\n * e.g.\n *  The following ACL defines that agentA and teamA has read and write access, while agentB and teamC has read access.\n *   {\n *      agent: {\n *         'agentA': ['read', 'write'],\n *         'agentB': ['read'],\n *     },\n *    team: {\n *       'teamA': ['read', 'write'],\n *       'teamC': ['read'],\n *     }\n * }\n */\n// prettier-ignore\nexport interface IACL {    \n    hashAlgorithm?: string | undefined;\n    entries?: {\n        [key in TAccessRole]?: TACLEntry | undefined;\n    };\n    migrated?: boolean | undefined;\n}\n\n// export type TACLMetadata = {\n//     acl?: TACL | undefined;\n// };\n\nexport interface IAccessCandidate {\n    role: TAccessRole;\n    id: string;\n}\n\nexport interface IAccessRequest {\n    id: string;\n    resourceId: string;\n    candidate: IAccessCandidate;\n    level: TAccessLevel | TAccessLevel[];\n}\n\nexport enum TAccessResult {\n    Granted = 'granted',\n    Denied = 'denied',\n}\n\nexport type TAccessTicket = {\n    request: IAccessRequest;\n    access: TAccessResult;\n};\n\n//custom errors\n\n//access denied error\nexport class ACLAccessDeniedError extends Error {\n    constructor(message?: string) {\n        super(message);\n        this.name = 'ACLAccessDeniedError';\n    }\n}\n","import { IAccessCandidate, IAccessRequest, TAccessLevel } from '@sre/types/ACL.types';\nimport { uid } from '@sre/utils/index';\n\nexport class AccessRequest implements IAccessRequest {\n    public id: string;\n    public resourceId: string;\n\n    public level: TAccessLevel[] = [];\n    public candidate: IAccessCandidate;\n\n    constructor(object?: IAccessRequest | IAccessCandidate) {\n        if (!object) {\n            this.id = 'aclR:' + uid();\n        }\n        if (['role', 'id'].every((k) => k in object)) {\n            //this is a candidate\n            this.id = 'aclR:' + uid();\n            this.candidate = object as IAccessCandidate;\n        } else {\n            const acReq: AccessRequest = object as AccessRequest;\n            this.id = acReq.id;\n            //this.resourceId = acReq.resourceId;\n            this.level = acReq.level;\n            this.candidate = acReq.candidate;\n        }\n\n        this.resourceId = undefined;\n    }\n\n    public static clone(request: IAccessRequest): AccessRequest {\n        return new AccessRequest(request);\n    }\n\n    public setLevel(level: TAccessLevel | TAccessLevel[]): AccessRequest {\n        this.level = Array.isArray(level) ? level : [level];\n        return this;\n    }\n    public addLevel(level: TAccessLevel | TAccessLevel[]): AccessRequest {\n        this.level = [...this.level, ...(Array.isArray(level) ? level : [level])];\n        return this;\n    }\n    public resource(resourceId: string): AccessRequest {\n        this.resourceId = resourceId;\n\n        return this;\n    }\n    public setCandidate(candidate: IAccessCandidate): AccessRequest {\n        this.candidate = candidate;\n\n        return this;\n    }\n}\n","import { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { AccessRequest } from './AccessRequest.class';\n\nexport class AccessCandidate implements IAccessCandidate {\n    public role: TAccessRole;\n    public id: string;\n    //public _candidate: TAccessCandidate;\n    constructor(candidate?: IAccessCandidate) {\n        //this._candidate = candidate || { role: TAccessRole.Public, id: '' };\n\n        this.role = candidate ? candidate.role : TAccessRole.Public;\n        this.id = candidate ? candidate.id : '';\n    }\n\n    public get request(): AccessRequest {\n        return new AccessRequest(this);\n    }\n\n    public get readRequest(): AccessRequest {\n        return new AccessRequest(this).setLevel(TAccessLevel.Read);\n    }\n    public get writeRequest(): AccessRequest {\n        return new AccessRequest(this).setLevel(TAccessLevel.Write);\n    }\n    public get ownerRequest(): AccessRequest {\n        return new AccessRequest(this).setLevel(TAccessLevel.Owner);\n    }\n\n    public static clone(candidate: IAccessCandidate): AccessCandidate {\n        return new AccessCandidate(candidate);\n    }\n\n    public team(teamId: string): AccessCandidate {\n        this.role = TAccessRole.Team;\n        this.id = teamId;\n\n        return this;\n    }\n    static team(teamId: string): AccessCandidate {\n        return new AccessCandidate({ role: TAccessRole.Team, id: teamId });\n    }\n\n    public agent(agentId: string): AccessCandidate {\n        this.role = TAccessRole.Agent;\n        this.id = agentId;\n        return this;\n    }\n    static agent(agentId: string): AccessCandidate {\n        return new AccessCandidate({ role: TAccessRole.Agent, id: agentId });\n    }\n\n    public user(userId: string): AccessCandidate {\n        this.role = TAccessRole.User;\n        this.id = userId;\n        return this;\n    }\n    static user(userId: string): AccessCandidate {\n        return new AccessCandidate({ role: TAccessRole.User, id: userId });\n    }\n\n    public public(): AccessCandidate {\n        this.role = TAccessRole.Public;\n\n        //public is a special case we use the role as the owner id because public access does not have specific candidate IDs\n        this.id = TAccessRole.Public;\n\n        return this;\n    }\n    static public(): AccessCandidate {\n        return new AccessCandidate({ role: TAccessRole.Public, id: '' });\n    }\n}\n","//import { xxh3 } from '@node-rs/xxhash';\nimport xxhash from 'xxhashjs';\nimport { IACL, IAccessRequest, LevelMap, ReverseLevelMap, ReverseRoleMap, RoleMap, TACLEntry, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\n\nconst ACLHashAlgo = {\n    none: (source) => source,\n    //xxh3: (source) => xxh3.xxh64(source.toString()).toString(16),\n    xxh3: (source) => {\n        const h64 = xxhash.h64(); // Use xxhashjs's h64 function\n        return h64.update(source.toString()).digest().toString(16);\n    },\n};\n\nexport class ACL implements IACL {\n    public hashAlgorithm?: string | undefined;\n    public entries?: {\n        [key in TAccessRole]?: TACLEntry | undefined;\n    };\n    public migrated?: boolean | undefined;\n    //private acl: TACL;\n    public get ACL(): IACL {\n        return {\n            hashAlgorithm: this.hashAlgorithm,\n            entries: JSON.parse(JSON.stringify(this.entries)),\n            migrated: this.migrated,\n        };\n    }\n    public get serializedACL(): string {\n        return this.serializeACL(this);\n    }\n\n    constructor(acl?: IACL | string) {\n        if (typeof acl === 'string') {\n            this.deserializeACL(acl);\n        } else {\n            this.hashAlgorithm = acl?.hashAlgorithm;\n            this.entries = acl?.entries ? JSON.parse(JSON.stringify(acl?.entries)) : {};\n            this.migrated = acl?.migrated;\n        }\n        if (!this.hashAlgorithm) this.hashAlgorithm = 'xxh3';\n        if (!this.entries) this.entries = {};\n    }\n\n    static from(acl?: IACL | string): ACL {\n        return new ACL(acl);\n    }\n\n    /**\n     * This function checks if the candidate has access to the requested level\n     * it only checks the exact access level, not the higher levels\n     * Examples :\n     * - if the candidate has read access, it will return true only if the requested level is read\n     * - if the current ACL has team access but the candidate is an agent, it will not match the team access\n     * @param acRequest\n     * @returns\n     */\n    public checkExactAccess(acRequest: IAccessRequest): boolean {\n        if (!this?.entries) return false; // cannot determine the access rights, prefer to deny access\n\n        const role = this?.entries[acRequest.candidate.role];\n        if (!role) return false;\n        let entryId = acRequest.candidate.id;\n\n        if (!ACLHashAlgo[this.hashAlgorithm]) {\n            throw new Error(`Hash algorithm ${this.hashAlgorithm} not supported`);\n        }\n\n        entryId = ACLHashAlgo[this.hashAlgorithm](entryId);\n\n        const access = role[entryId];\n        if (!access) return false;\n\n        const levels = Array.isArray(acRequest.level) ? acRequest.level : [acRequest.level];\n\n        return levels.every((level) => access.includes(level));\n        //return access.includes(req.level);\n    }\n\n    public addPublicAccess(level: TAccessLevel | TAccessLevel[]): ACL {\n        if (!this?.entries[TAccessRole.Public]) this.entries[TAccessRole.Public] = {};\n        if (!ACLHashAlgo[this.hashAlgorithm]) {\n            throw new Error(`Hash algorithm ${this.hashAlgorithm} not supported`);\n        }\n        const ownerId = TAccessRole.Public; //public is a special case we use the role as the owner id because public access does not have specific candidate IDs\n        const hashedOwner = ACLHashAlgo[this.hashAlgorithm](ownerId);\n\n        if (!this?.entries[TAccessRole.Public]![hashedOwner]) this.entries[TAccessRole.Public]![hashedOwner] = [];\n        //acl[TAccessRole.Public]![hashedOwner]!.push(level);\n        //concatenate the levels\n        const curLevel: any = this.entries[TAccessRole.Public]![hashedOwner]!;\n        this.entries[TAccessRole.Public]![hashedOwner] = [...curLevel, ...level];\n\n        return this;\n    }\n    public removePublicAccess(level: TAccessLevel | TAccessLevel[]): ACL {\n        if (!this?.entries[TAccessRole.Public]) return this;\n        const ownerId = TAccessRole.Public; //public is a special case we use the role as the owner id because public access does not have specific candidate IDs\n        const hashedOwner = ACLHashAlgo[this.hashAlgorithm](ownerId);\n\n        //remove the levels\n        const curLevel = this[TAccessRole.Public]![hashedOwner]!;\n        this[TAccessRole.Public]![hashedOwner] = curLevel.filter((l) => !level.includes(l));\n\n        return this;\n    }\n    public addAccess(role: TAccessRole, ownerId: string, level: TAccessLevel | TAccessLevel[]): ACL {\n        if (role === TAccessRole.Public) {\n            throw new Error('Adding public access using addAccess method is not allowed. Use addPublicAccess method instead.');\n        }\n        const _level = Array.isArray(level) ? level : [level];\n        if (!this?.entries[role]) this.entries[role] = {};\n        if (!ACLHashAlgo[this.hashAlgorithm]) {\n            throw new Error(`Hash algorithm ${this.hashAlgorithm} not supported`);\n        }\n        const hashedOwner = ACLHashAlgo[this.hashAlgorithm](ownerId);\n\n        if (!this?.entries[role]![hashedOwner]) this.entries[role]![hashedOwner] = [];\n        //acl[role]![ownerId]!.push(level);\n        //concatenate the levels\n        const curLevel = this.entries[role]![hashedOwner]!;\n        this.entries[role]![hashedOwner] = [...curLevel, ..._level];\n\n        return this;\n    }\n    public static addAccess(role: TAccessRole, ownerId: string, level: TAccessLevel | TAccessLevel[]): ACL {\n        return ACL.from().addAccess(role, ownerId, level);\n    }\n\n    public removeAccess(role: TAccessRole, ownerId: string, level: TAccessLevel | TAccessLevel[]): ACL {\n        const _level = Array.isArray(level) ? level : [level];\n        if (!this[role]) return this;\n        if (!this[role]![ownerId]) return this;\n        //acl[role]![ownerId] = acl[role]![ownerId]!.filter((l) => l !== level);\n        //remove the levels\n        const curLevel = this[role]![ownerId]!;\n        this[role]![ownerId] = curLevel.filter((l) => !_level.includes(l));\n\n        return this;\n    }\n\n    private serializeACL(tacl: IACL): string {\n        let compressed = '';\n\n        if (tacl.hashAlgorithm) {\n            compressed += `h:${tacl.hashAlgorithm}|`;\n        }\n\n        if (tacl.entries) {\n            for (const [role, entries] of Object.entries(tacl.entries)) {\n                const roleShort = RoleMap[role]; // Use the mapping for role\n                const entriesArray: any[] = [];\n\n                for (const [hashedOwnerKey, accessLevels] of Object.entries(entries || {})) {\n                    if (accessLevels) {\n                        const accessLevelsShort = accessLevels.map((level) => LevelMap[level]).join('');\n                        entriesArray.push(`${hashedOwnerKey}/${accessLevelsShort}`);\n                    }\n                }\n\n                if (entriesArray.length > 0) {\n                    compressed += `${roleShort}:${entriesArray.join(',')}|`;\n                }\n            }\n        }\n\n        // Remove the trailing '|'\n        if (compressed.endsWith('|')) {\n            compressed = compressed.slice(0, -1);\n        }\n\n        return compressed;\n    }\n\n    private deserializeACL(compressed: string) {\n        const parts = compressed.split('|');\n        this.hashAlgorithm = '';\n        this.entries = {};\n\n        for (const part of parts) {\n            if (part.startsWith('h:')) {\n                this.hashAlgorithm = part.substring(2);\n            } else {\n                const [roleShort, entries] = part.split(':');\n                const role = ReverseRoleMap[roleShort]; // Use the reverse mapping for role\n\n                if (role) {\n                    const entriesObj = {};\n                    const entriesArray = entries.split(',');\n\n                    for (const entry of entriesArray) {\n                        const [hashedOwnerKey, accessLevelsShort] = entry.split('/');\n                        const accessLevels = accessLevelsShort.split('').map((short) => ReverseLevelMap[short]);\n\n                        entriesObj[hashedOwnerKey] = accessLevels;\n                    }\n\n                    this.entries[role] = entriesObj;\n                }\n            }\n        }\n\n        //return tacl;\n    }\n}\n","import { jsonrepair } from 'jsonrepair';\nimport { isDigits, isSafeNumber, isValidString } from '@sre/utils';\n\nexport class JSONContentHelper {\n    private _current: string;\n\n    public get result() {\n        return this._current;\n    }\n    private constructor(private dataString: string) {\n        this._current = dataString;\n    }\n\n    public static create(dataString: string) {\n        return new JSONContentHelper(dataString);\n    }\n\n    /**\n     * This a permissive json parsing function : It tries to extract and parse a JSON object from a string. If it fails, it returns the original string.\n     * if the string is not a JSON representation, but contains a JSON object, it will extract and parse it.\n     * @returns\n     */\n    public tryParse() {\n        const strInput = this._current;\n        if (!isValidString(strInput)) return strInput;\n        let str = (this.extractJsonFromString(strInput) || strInput).trim();\n\n        if ((isDigits(str) && !isSafeNumber(str)) || (!str.startsWith('{') && !str.startsWith('['))) return str;\n\n        try {\n            return JSON.parse(str);\n        } catch (e) {\n            try {\n                return JSON.parse(jsonrepair(str));\n            } catch (e: any) {\n                //console.warn('Error on parseJson: ', e.toString());\n                //console.warn('   Tried to parse: ', str);\n                return strInput;\n            }\n        }\n    }\n\n    // Same as tryParse but it does not extract JSON from string\n    public tryFullParse() {\n        const str = this._current;\n        if (!str) return str;\n\n        if ((isDigits(str) && !isSafeNumber(str)) || (!str.startsWith('{') && !str.startsWith('['))) return str;\n\n        try {\n            return JSON.parse(str);\n        } catch (e) {\n            try {\n                return JSON.parse(jsonrepair(str));\n            } catch (e: any) {\n                console.warn('Error on parseJson: ', e.toString());\n                console.warn('   Tried to parse: ', str);\n                return { result: str, error: e.toString() };\n            }\n        }\n    }\n\n    private extractJsonFromString(str) {\n        try {\n            const regex = /(\\{.*\\})/s; // LLMs in smythOS are expected to generate json between curly brackets only\n\n            const match = str.match(regex);\n\n            return match?.[1];\n        } catch {\n            return null;\n        }\n    }\n}\n\nexport function JSONContent(dataString: string) {\n    return JSONContentHelper.create(dataString);\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\nimport { isBuffer } from '@sre/utils';\nimport * as FileType from 'file-type';\nimport mime from 'mime';\nimport { Readable } from 'stream';\nimport { StorageConnector } from './StorageConnector';\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { CacheConnector } from '@sre/MemoryManager/Cache.service';\nimport crypto from 'crypto';\nimport { JSONContentHelper } from '@sre/helpers/JsonContent.helper';\nimport SystemEvents from '@sre/Core/SystemEvents';\nimport { RouterConnector } from '../Router.service/RouterConnector';\nexport type TSmythFSURI = {\n    hash: string;\n    team: string;\n    path: string;\n};\n\nSystemEvents.on('SRE:Booted', () => {\n    const router = ConnectorService.getRouterConnector();\n    if (router && router?.get instanceof Function) {\n        router.get('/_temp/:uid', SmythFS.Instance.serveTempContent.bind(SmythFS.Instance));\n    }\n});\n\nexport class SmythFS {\n    private storage: StorageConnector;\n    private cache: CacheConnector;\n\n    //singleton\n    private static instance: SmythFS;\n    public static get Instance() {\n        if (!this.instance) {\n            this.instance = new SmythFS();\n        }\n        return this.instance;\n    }\n\n    private constructor() {\n        //SmythFS cannot be used without SRE\n        if (!ConnectorService.ready) {\n            throw new Error('SRE not available');\n        }\n        this.storage = ConnectorService.getStorageConnector();\n        this.cache = ConnectorService.getCacheConnector();\n    }\n\n    private URIParser(uri: string) {\n        const parts = uri.split('://');\n        if (parts.length !== 2) return undefined;\n        if (parts[0].toLowerCase() !== 'smythfs') return undefined;\n        const parsed = new URL(`http://${parts[1]}`);\n        const tld = parsed.hostname.split('.').pop();\n        if (tld !== 'team') throw new Error('Invalid Resource URI');\n        const team = parsed.hostname.replace(`.${tld}`, '');\n        //TODO: check if team exists\n\n        return {\n            hash: parsed.hash,\n            team,\n            path: parsed.pathname,\n        };\n    }\n    public getStoragePath(uri: string) {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n        return `teams/${smythURI.team}${smythURI.path}`;\n    }\n    public async read(uri: string, candidate: IAccessCandidate): Promise<Buffer> {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n\n        const resourceId = `teams/${smythURI.team}${smythURI.path}`;\n\n        const _candidate = candidate instanceof AccessCandidate ? candidate : new AccessCandidate(candidate);\n\n        const data = await this.storage.user(_candidate).read(resourceId);\n\n        return this.toBuffer(data);\n    }\n\n    private async toBuffer(data: StorageData): Promise<Buffer> {\n        if (Buffer.isBuffer(data)) {\n            return data;\n        } else if (typeof data === 'string') {\n            return Buffer.from(data, 'utf-8');\n        } else if (data instanceof Uint8Array) {\n            return Buffer.from(data);\n        } else if (data instanceof Readable) {\n            return new Promise<Buffer>((resolve, reject) => {\n                const chunks: Buffer[] = [];\n                data.on('data', (chunk) => {\n                    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n                });\n                data.on('end', () => {\n                    resolve(Buffer.concat(chunks));\n                });\n                data.on('error', (err) => {\n                    reject(err);\n                });\n            });\n        } else {\n            throw new Error('Unsupported data type');\n        }\n    }\n\n    public async write(uri: string, data: any, candidate: IAccessCandidate, metadata?: StorageMetadata) {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n        const accountConnector = ConnectorService.getAccountConnector();\n        const isMember = await accountConnector.isTeamMember(smythURI.team, candidate);\n        if (!isMember) throw new Error('Access Denied');\n\n        const resourceId = `teams/${smythURI.team}${smythURI.path}`;\n        //when we write a file, it does not exist we need to explicitly provide a resource team in order to have access rights set properly\n\n        const _candidate = candidate instanceof AccessCandidate ? candidate : new AccessCandidate(candidate);\n\n        const acl = new ACL()\n            //.addAccess(candidate.role, candidate.id, TAccessLevel.Owner) // creator is owner\n            .addAccess(TAccessRole.Team, smythURI.team, TAccessLevel.Read).ACL; // team has read access\n\n        if (!metadata) metadata = {};\n        if (!metadata?.ContentType) {\n            metadata.ContentType = await this.getMimeType(data);\n            if (!metadata.ContentType) {\n                const ext: any = uri.split('.').pop();\n                if (ext) {\n                    metadata.ContentType = mime.getType(ext) || 'application/octet-stream';\n                }\n            }\n        }\n        await this.storage.user(_candidate).write(resourceId, data, acl, metadata);\n    }\n    private async getMimeType(data: any) {\n        let size = 0;\n        if (data instanceof Blob) return data.type;\n        if (isBuffer(data)) {\n            try {\n                const fileType = await FileType.fileTypeFromBuffer(data);\n                return fileType.mime;\n            } catch {\n                return '';\n            }\n        }\n\n        if (typeof data === 'string') {\n            return 'text/plain';\n        }\n    }\n\n    public async delete(uri: string, candidate: IAccessCandidate) {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n\n        const resourceId = `teams/${smythURI.team}${smythURI.path}`;\n\n        const _candidate = candidate instanceof AccessCandidate ? candidate : new AccessCandidate(candidate);\n\n        await this.storage.user(_candidate).delete(resourceId);\n    }\n\n    //TODO: should we require access token here ?\n    public async exists(uri: string, candidate: IAccessCandidate) {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n\n        const resourceId = `teams/${smythURI.team}${smythURI.path}`;\n\n        //in order to get a consistent access check in case of inexisting resource, we need to explicitly set a default resource team\n        const _candidate = candidate instanceof AccessCandidate ? candidate : new AccessCandidate(candidate);\n\n        return await this.storage.user(_candidate).exists(resourceId);\n    }\n\n    public async genTempUrl(uri: string, candidate: IAccessCandidate, ttlSeconds: number = 3600) {\n        const smythURI = this.URIParser(uri);\n        if (!smythURI) throw new Error('Invalid Resource URI');\n\n        const exists = await this.exists(uri, candidate);\n        if (!exists) throw new Error('Resource does not exist');\n\n        const _candidate = candidate instanceof AccessCandidate ? candidate : new AccessCandidate(candidate);\n\n        const resourceId = `teams/${smythURI.team}${smythURI.path}`;\n        const resourceMetadata = await this.storage.user(_candidate).getMetadata(resourceId);\n\n        const uid = crypto.randomUUID();\n        const tempUserCandidate = AccessCandidate.user(`system:${uid}`);\n\n        await this.cache.user(tempUserCandidate).set(\n            `pub_url:${uid}`,\n            JSON.stringify({\n                accessCandidate: _candidate,\n                uri,\n                contentType: resourceMetadata?.ContentType,\n            }),\n            undefined,\n            undefined,\n            ttlSeconds\n        ); // 1 hour\n\n        const baseUrl = ConnectorService.getRouterConnector().baseUrl;\n        return `${baseUrl}/_temp/${uid}`;\n    }\n\n    public async destroyTempUrl(url: string, { delResource }: { delResource: boolean } = { delResource: false }) {\n        const uid = url.split('/_temp/')[1].split('?')[0]; // remove any query params\n        let cacheVal = await this.cache.user(AccessCandidate.user(`system:${uid}`)).get(`pub_url:${uid}`);\n        if (!cacheVal) throw new Error('Invalid Temp URL');\n        cacheVal = JSONContentHelper.create(cacheVal).tryParse();\n        await this.cache.user(AccessCandidate.user(`system:${uid}`)).delete(`pub_url:${uid}`);\n        if (delResource) {\n            await this.delete(cacheVal.uri, AccessCandidate.clone(cacheVal.accessCandidate));\n        }\n    }\n\n    public async serveTempContent(req: any, res: any) {\n        try {\n            const { uid } = req.params;\n            let cacheVal = await this.cache.user(AccessCandidate.user(`system:${uid}`)).get(`pub_url:${uid}`);\n            if (!cacheVal) {\n                res.writeHead(404, { 'Content-Type': 'text/plain' });\n                res.end('Invalid Temp URL');\n                return;\n            }\n            cacheVal = JSONContentHelper.create(cacheVal).tryParse();\n            const content = await this.read(cacheVal.uri, AccessCandidate.clone(cacheVal.accessCandidate));\n\n            res.writeHead(200, {\n                'Content-Type': cacheVal.contentType,\n                'Content-Disposition': 'inline',\n            });\n            res.end(content);\n        } catch (error) {\n            console.error('Error serving temp content:', error);\n            res.writeHead(500, { 'Content-Type': 'text/plain' });\n            res.end('Internal Server Error');\n        }\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { SmythFS } from '@sre/IO/Storage.service/SmythFS.class';\nimport { IAccessCandidate } from '@sre/types/ACL.types';\nimport axios from 'axios';\nimport * as FileType from 'file-type';\nimport mime from 'mime';\nimport { getSizeFromBinary, isUrl, uid } from '../utils';\nexport class BinaryInput {\n    private size: number;\n    private url: string;\n    private _ready;\n    private _readyPromise;\n    private _source: Buffer;\n    private _uploading: boolean = false;\n\n    constructor(\n        data: BinaryInput | Buffer | ArrayBuffer | Blob | string | Record<string, any>,\n        private _name?: string,\n        public mimetype?: string,\n        private candidate?: IAccessCandidate\n    ) {\n        if (!_name) _name = uid();\n        this._name = _name;\n        //this._source = data;\n\n        this.load(data, _name, mimetype, candidate);\n    }\n\n    public async ready() {\n        if (this._ready) return true;\n\n        if (!this._readyPromise) {\n            this._readyPromise = new Promise((resolve) => {\n                const maxWait = 10000;\n                const interval = setInterval(() => {\n                    if (this._ready) {\n                        clearInterval(interval);\n                        resolve(true);\n                    }\n                    if (maxWait <= 0) {\n                        clearInterval(interval);\n                        resolve(false);\n                    }\n                }, 100);\n            });\n        }\n\n        return this._readyPromise;\n    }\n\n    private async load(data, name: string, mimetype?: string, candidate?: IAccessCandidate) {\n        //assume the mimetype from the provided name\n        const ext: any = name.split('.').pop();\n        this.mimetype = mimetype || mime.getType(ext) || 'application/octet-stream';\n        this.url = ``;\n\n        if (typeof data === 'object' && data.url && data.mimetype && data.size) {\n            this.mimetype = data.mimetype;\n            this.size = data.size;\n            this.url = data.url;\n            this._ready = true;\n            if (candidate) {\n                this._source = await SmythFS.Instance.read(this.url, candidate);\n            }\n            return;\n        }\n\n        if (isUrl(data)) {\n            const info: any = await this.getUrlInfo(data);\n            this.mimetype = info.contentType;\n            this.size = info.contentLength;\n            //this.url = data;\n\n            try {\n                const response = await axios({\n                    method: 'get',\n                    url: data,\n                    responseType: 'arraybuffer', // Important for handling binary data\n                });\n\n                this._source = Buffer.from(response.data, 'binary');\n                this.size = response.data.byteLength;\n\n                const ext = mime.getExtension(this.mimetype);\n                if (!this._name.endsWith(`.${ext}`)) this._name += `.${ext}`;\n            } catch (error) {\n                console.error('Error loading binary data from url:', data.url);\n            }\n\n            //this._source = data.url;\n\n            this._ready = true;\n            return;\n        }\n\n        // console.log('>>>>>>>>>>>>>>>>>>> is base64 file ?', isDataUrl(data));\n        const base64FileInfo = await this.getBase64FileInfo(data);\n        if (base64FileInfo) {\n            this.mimetype = base64FileInfo.mimetype;\n            this.size = base64FileInfo.size;\n            this._source = base64FileInfo.data;\n            const ext = mime.getExtension(this.mimetype);\n            if (!this._name.endsWith(`.${ext}`)) this._name += `.${ext}`;\n\n            this._ready = true;\n            return;\n        }\n\n        if (typeof data === 'string') {\n            this._source = Buffer.from(data);\n            this.size = data.length;\n            this.mimetype = 'text/plain';\n            if (!this._name.endsWith(`.txt`)) this._name += `.txt`;\n\n            this._ready = true;\n            return;\n        }\n\n        //this.size = getSizeFromBinary(data);\n        // //try to enforce the mimetype from the provided data\n        // if (Buffer.isBuffer(data)) {\n        //     const fileType = await FileType.fileTypeFromBuffer(data);\n        //     this.mimetype = fileType.mime;\n        //     const ext = mime.getExtension(this.mimetype);\n        //     if (!this._name.endsWith(`.${ext}`)) this._name += `.${ext}`;\n\n        //     this._ready = true;\n        //     return;\n        // }\n        //try to enforce the mimetype from the provided data\n        if (Buffer.isBuffer(data)) {\n            this._source = data;\n            this.size = getSizeFromBinary(data);\n            const fileType = await FileType.fileTypeFromBuffer(data);\n            this.mimetype = fileType.mime;\n            const ext = mime.getExtension(this.mimetype);\n            if (!this._name.endsWith(`.${ext}`)) this._name += `.${ext}`;\n        }\n\n        this._ready = true;\n    }\n\n    private async getUrlInfo(url) {\n        try {\n            const response = await axios.head(url);\n            const contentType = response.headers['content-type'];\n            const contentLength = response.headers['content-length'];\n            return { contentType, contentLength };\n        } catch (error) {\n            return { contentType: '', contentLength: 0 };\n        }\n    }\n    private async getBase64FileInfo(data: string) {\n        //first check if it's a base64 url format\n        const validUrlFormatRegex = /data:[^;]+;base64,[A-Za-z0-9+\\/]*(={0,2})?$/gm;\n        if (!validUrlFormatRegex.test(data)) {\n            return null;\n        }\n\n        const base64Data = data.split(',')[1];\n        const buffer = Buffer.from(base64Data, 'base64');\n        const size = buffer.byteLength;\n        const filetype = await FileType.fileTypeFromBuffer(buffer);\n\n        return { size, data: buffer, mimetype: filetype?.mime || '' };\n    }\n    public static from(data, name?: string, mimetype?: string, candidate?: IAccessCandidate) {\n        if (data instanceof BinaryInput) return data;\n        return new BinaryInput(data, name, mimetype, candidate);\n    }\n\n    public async upload(candidate: IAccessCandidate) {\n        await this.ready();\n        if (this._uploading) return;\n\n        try {\n            this._uploading = true;\n            if (!this.url) {\n                const accountConnector = ConnectorService.getAccountConnector();\n                const teamId = await accountConnector.getCandidateTeam(candidate);\n\n                this.url = `smythfs://${teamId}.team/${candidate.id}/_temp/${this._name}`;\n                //TODO : set a TTL for temporary files\n                //we probably need a write with TTL method in SmythFS\n                await SmythFS.Instance.write(this.url, this._source, candidate);\n                this._uploading = false;\n            }\n        } catch (error) {\n            console.error('Error uploading binary data:', error);\n            this._uploading = false;\n        }\n    }\n\n    public async getJsonData(candidate: IAccessCandidate) {\n        await this.upload(candidate);\n        return {\n            mimetype: this.mimetype,\n            size: this.size,\n            url: this.url,\n            name: this._name,\n        };\n    }\n\n    public async readData(candidate: IAccessCandidate) {\n        await this.ready();\n        if (!this.url) {\n            throw new Error('Binary data not ready');\n        }\n        const data = await SmythFS.Instance.read(this.url, candidate);\n        return data;\n    }\n\n    public async getName() {\n        await this.ready();\n        return this._name;\n    }\n\n    public async getBuffer() {\n        await this.ready();\n\n        return this._source;\n    }\n}\n","import { isRawBase64, isDataUrl } from '@sre/utils/base64.utils';\nimport dayjs from 'dayjs';\nimport { isBinaryData, isBuffer, isPlainObject, isSmythFileObject, isUrl, uid } from '../utils';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { TAccessRole } from '@sre/types/ACL.types';\nimport { BinaryInput } from './BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { JSONContent } from './JsonContent.helper';\n\nexport const inputErrMsg = (type, name) => `Invalid ${type} value for Input: ${name}`;\n\nconst InferenceStrategies = {\n    any: inferAnyType,\n    string: inferStringType,\n    number: inferNumberType,\n    integer: inferIntegerType,\n    boolean: inferBooleanType,\n    array: inferArrayType,\n    object: inferObjectType,\n    binary: inferBinaryType,\n    date: inferDateType,\n};\n\n/**\n * Performs type inference on the inputs based on the input config\n * @param inputs - The inputs to perform type inference on\n * @param inputConfig - The input config to perform type inference on\n * @param agent - The agent to perform type inference on\n * @returns The inputs with the inferred types\n */\nexport async function performTypeInference(\n    inputs: Record<string, any>,\n    inputConfig: Record<string, any>[],\n    agent: Agent\n): Promise<Record<string, any>> {\n    try {\n        if (!inputConfig || Object.keys(inputConfig)?.length === 0) return inputs;\n\n        // Clone the input object to avoid modifying the original object\n        const _inputs = { ...inputs };\n        const _inputConfig = {};\n\n        for (const input of inputConfig) {\n            if (input?.name) {\n                _inputConfig[input.name] = { ...input };\n            }\n        }\n\n        for (const [key, config] of Object.entries(_inputConfig)) {\n            let value = inputs?.[key] || '';\n\n            if (!value) continue;\n\n            const type = (config as any)?.type?.toLowerCase() || 'any';\n\n            if (!InferenceStrategies[type]) {\n                throw new Error(`Invalid type: ${type} for Input: ${key}`);\n            }\n\n            _inputs[key] = await InferenceStrategies[type](value, key, agent);\n        }\n\n        return _inputs;\n    } catch (error) {\n        throw error;\n    }\n}\n\nasync function inferStringType(value: any, key?: string, agent?: Agent) {\n    if (value === null || value === undefined || value === 'null' || value === 'undefined') {\n        return '';\n    } else if (isRawBase64(value) || isDataUrl(value)) {\n        // If the value is a base64 string then return the value as it is\n        return value;\n    } /*else if (isSmythFileObject(value) || isBuffer(value) || isBinaryData(value)) {\n        const file = new SmythFile(value);\n        const base64Obj = await file.toBase64Object();\n        return `data:${base64Obj.mimetype};base64,${base64Obj.base64}`;\n    }*/ else if (typeof value === 'object' || Array.isArray(value)) {\n        return JSON.stringify(value);\n    } else {\n        return String(value);\n    }\n}\n\nasync function inferNumberType(value: any, key?: string, agent?: Agent) {\n    const floatVal = parseFloat(value);\n\n    if (isNaN(floatVal)) {\n        throw new Error('Invalid Number value');\n    }\n\n    return floatVal;\n}\n\nasync function inferIntegerType(value: any, key?: string, agent?: Agent) {\n    const intVal = parseInt(value);\n\n    if (isNaN(intVal)) throw new Error('Invalid Integer value');\n\n    return intVal;\n}\n\nasync function inferBooleanType(value: any, key?: string, agent?: Agent) {\n    if (typeof value === 'boolean') {\n        return value;\n    } else if (typeof value === 'string' || typeof value === 'number') {\n        const lowerCaseValue = String(value).toLowerCase();\n        if (['true', '1'].includes(lowerCaseValue)) {\n            return true;\n        } else if (['false', '0'].includes(lowerCaseValue)) {\n            return false;\n        } else {\n            throw new Error('Invalid Boolean value');\n        }\n    } else {\n        throw new Error('Invalid Boolean value');\n    }\n}\n\nasync function inferArrayType(value: any, key?: string, agent?: Agent) {\n    try {\n        if (Array.isArray(value)) return value;\n\n        if (typeof value !== 'string') throw new Error('Invalid Array value');\n\n        try {\n            // We need to consider array with comma separated values like \"item1, item2, item3\", as it's provided by Swagger UI\n            return value.trim().startsWith('[') ? JSONContent(value).tryParse() : value.split(',');\n        } catch {\n            throw new Error('Invalid Array value');\n        }\n    } catch (error) {\n        throw new Error('Invalid Array value');\n    }\n}\n\nasync function inferObjectType(value: any, key?: string, agent?: Agent) {\n    try {\n        // use parseJson instead of JSON.parse because the data may come from LLM responses\n        const obj = isPlainObject(value) ? value : JSONContent(value).tryParse();\n        if (!isPlainObject(obj)) throw new Error('Invalid Object value');\n        return obj;\n    } catch (error) {\n        throw new Error('Invalid Object value');\n    }\n}\n\nasync function inferBinaryType(value: any, key?: string, agent?: Agent) {\n    if (value && typeof value === 'object' && value?.url) {\n        const binaryInput = await BinaryInput.from(value.url, uid() + '-' + key, value?.mimetype);\n        await binaryInput.ready();\n        return binaryInput;\n    }\n\n    const binaryInput = BinaryInput.from(value, uid() + '-' + key);\n    await binaryInput.ready();\n    return binaryInput;\n}\n\nasync function inferDateType(value: any, key?: string, agent?: Agent) {\n    const errMsg = `Invalid Date value\\nThe date string is expected to be in a format commonly used in English-speaking countries.`;\n\n    // Make sure we only accept string or number to parse as date\n    if (typeof value !== 'string' && typeof value !== 'number') throw new Error(errMsg);\n\n    let date;\n    if (typeof value === 'string' && isNaN(Number(value))) {\n        date = dayjs(value).locale('en'); // parse as date string\n    } else {\n        // parse as Unix timestamp\n        const timestamp = typeof value === 'number' ? value : Number(value);\n        date = dayjs.unix(timestamp / 1000);\n    }\n\n    if (!date.isValid()) throw new Error(errMsg);\n\n    return date.toISOString();\n}\n\nasync function inferAnyType(value: any) {\n    return value;\n}\n","import Joi from 'joi';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { performTypeInference } from '@sre/helpers/TypeChecker.helper';\n\nexport default class Component {\n    public hasReadOutput = false;\n    public hasPostProcess = true;\n    public alwaysActive = false; //for components like readable memories\n    public exclusive = false; //for components like writable memories : when exclusive components are active, they are processed in a run cycle bofore other components\n    protected configSchema;\n    constructor() {}\n    init() {}\n\n    createComponentLogger(agent: Agent, name: string) {\n        const logger = Logger(name || this.constructor.name, agent?.agentRuntime?.debug);\n\n        return logger;\n    }\n\n    async validateConfig(config) {\n        if (!this.configSchema) return {};\n        if (config.data._templateVars) {\n            //Accept dynamically added template data\n            for (let tplVar in config.data._templateVars) {\n                this.configSchema = this.configSchema.append({ [tplVar]: Joi.any() });\n            }\n        }\n        const valid = await this.configSchema.validate(config.data);\n        if (valid.error) {\n            return {\n                id: config.id,\n                name: config.name,\n                _error: `Schema Validation error: ${valid?.error?.message} on component ${config.displayName}:${config.title}`,\n                _debug: `Schema Validation error: ${valid?.error?.message} on component ${config.displayName}:${config.title}`,\n            };\n        }\n\n        return {};\n    }\n\n    async process(input, config, agent: Agent): Promise<any> {\n        // console.log(\n        //     `Called component ${this.constructor.name}\\n ID=${config.id} \\ninput ${JSON.stringify(input, null, 2)} \\nand config ${JSON.stringify(\n        //         config,\n        //         null,\n        //         2,\n        //     )}`,\n        // );\n        const _input = await performTypeInference(input, config?.inputs, agent);\n\n        // modify the input object for component's process method\n        for (const [key, value] of Object.entries(_input)) {\n            input[key] = value;\n        }\n    }\n    async postProcess(output, config, agent: Agent): Promise<any> {\n        if (output?.result) {\n            delete output?.result?._debug;\n            if (!output?.result?._error) delete output?.result?._error;\n        }\n        return output;\n    }\n    async enable(config, agent: Agent): Promise<any> {}\n    async disable(config, agent: Agent): Promise<any> {}\n    readOutput(id, config, agent: Agent): any {\n        return null;\n    }\n    hasOutput(id, config, agent: Agent): any {\n        return false;\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccessCandidate } from '../AccessControl/AccessCandidate.class';\nimport axios from 'axios';\nimport config from '@sre/config';\nimport qs from 'qs';\n\nexport class VaultHelper {\n    static async getTeamKey(key: string, teamId: string): Promise<string> {\n        const vaultConnector = ConnectorService.getVaultConnector();\n        return await vaultConnector.user(AccessCandidate.team(teamId)).get(key);\n    }\n\n    static async getUserKey(key: string, userId: string): Promise<string> {\n        const vaultConnector = ConnectorService.getVaultConnector();\n        const accountConnector = ConnectorService.getAccountConnector();\n\n        const teamId = await accountConnector.getCandidateTeam(AccessCandidate.user(userId));\n\n        return await vaultConnector.user(AccessCandidate.team(teamId)).get(key);\n    }\n\n    static async getAgentKey(key: string, agentId: string): Promise<string> {\n        const vaultConnector = ConnectorService.getVaultConnector();\n        const accountConnector = ConnectorService.getAccountConnector();\n\n        const teamId = await accountConnector.getCandidateTeam(AccessCandidate.agent(agentId));\n\n        return await vaultConnector.user(AccessCandidate.team(teamId)).get(key);\n    }\n\n}\n","import { VaultHelper } from '@sre/Security/Vault.service/Vault.helper';\n\nexport type TemplateStringMatch = RegExp;\n\nexport const Match = {\n    default: /{{(.*?)}}/g,\n    //matches all placeholders\n    doubleCurly: /{{(.*?)}}/g,\n    singleCurly: /{(.*?)}/g,\n    doubleCurlyForSingleMatch: /{{(.*?)}}/,\n\n    //matches component template variables\n    //example of matching strings\n    // {{VAULTINPUT:Input label:[APIKEY]}}\n    // {{VARINPUT:Variable label:{ \"key\":\"value\" }}}\n    templateVariables: /{{([A-Z]+):([\\w\\s]+):[\\[{](.*?)[\\]}]}}/gm,\n\n    //matches only the placeholders that have a specific prefix\n    prefix(prefix: string) {\n        return new RegExp(`{{${prefix}(.*?)}}`, 'g');\n    },\n\n    //matches only the placeholders that have a specific suffix\n    suffix(suffix: string) {\n        return new RegExp(`{{(.*?)${suffix}}}`, 'g');\n    },\n    //matches only the placeholders that have a specific prefix and suffix\n    prefSuf(prefix: string, suffix: string) {\n        return new RegExp(`{{${prefix}(.*?)${suffix}}}`, 'g');\n    },\n\n    //matches a function annotation with a given name, just like prefix but with wrapping parenthesis\n    fn(name: string) {\n        return new RegExp(`{{${name}\\\\((.*?)\\\\)}}`, 'g');\n    },\n};\n\nexport const TPLProcessor = {\n    vaultTeam(teamId: string): (token) => Promise<string> {\n        //the token here represents the vault key name\n        return async (token) => {\n            try {\n                return await VaultHelper.getTeamKey(token, teamId);\n            } catch (error) {\n                return token;\n            }\n        };\n    },\n    componentTemplateVar(templateSettings: Record<string, any>): (token, matches) => Promise<string> {\n        return async (token, matches) => {\n            try {\n                const label = matches[2]; //template variables are identified by their label inside the component config\n                if (!label) return token;\n\n                const entry: any = Object.values(templateSettings).find((o: any) => o.label == label);\n                if (!entry) return token;\n                return `{{${entry.id}}}`;\n            } catch (error) {\n                return token;\n            }\n        };\n    },\n};\n\n/**\n * Provides a chainable to manipulate template strings\n *\n * Template strings are strings that can contain placeholders, which are expressions that get evaluated to produce a resulting string.\n * The placeholders are defined by double curly braces `{{` and `}}`.\n */\n\n//FIXME: async parsing breaks the chainability of the TemplateStringHelper\nexport class TemplateStringHelper {\n    private _current: string;\n\n    //this queue is used to wait for asyncronous results when async processors are used\n    //if all processors are synchronous, this queue will be empty and .result getter can be used\n    //if any processor is async, the .result getter will throw an error and you should use .asyncResult instead\n    private _promiseQueue: Promise<any>[] = [];\n\n    public get result(): string {\n        if (this._promiseQueue.length <= 0) return this._current;\n        throw new Error('This template object has async results, you should use .asyncResult with await instead of .result');\n    }\n\n    public get asyncResult(): Promise<string> {\n        return new Promise(async (resolve, reject) => {\n            await Promise.all(this._promiseQueue);\n            resolve(this._current);\n        });\n    }\n\n    private constructor(private templateString: string) {\n        this._current = templateString;\n    }\n\n    public static create(templateString: string) {\n        return new TemplateStringHelper(templateString);\n    }\n\n    /**\n     * Parses a template string by replacing the placeholders with the values from the provided data object\n     * unmatched placeholders will be left as is\n     */\n    public parse(data: Record<string, string>, regex: TemplateStringMatch = Match.default) {\n        if (typeof this._current !== 'string' || typeof data !== 'object') return this;\n        this._current = this._current.replace(regex, (match, token) => {\n            return data[token] || match;\n        });\n\n        return this;\n    }\n\n    /**\n     * Parses a template string by replacing the placeholders with the values from the provided data object and keep the raw value instead of returning a string like .parse does\n     * unmatched placeholders will be left as is\n     */\n    // Note: right now this method only match the first occurrence of the regex\n    public parseRaw(data: Record<string, string>, regex: TemplateStringMatch = Match.doubleCurlyForSingleMatch) {\n        if (typeof this._current !== 'string' || typeof data !== 'object') return this;\n\n        const match = this._current.match(regex);\n        const key = match ? match[1] : '';\n\n        if (key) {\n            const value = data?.[key];\n            this._current = value;\n        }\n\n        return this;\n    }\n\n    /**\n     * This is a shortcut function that parses vault key values and replace them with corresponding values from team vault\n     * @param teamId\n     * @returns\n     */\n    public parseTeamKeysAsync(teamId: string) {\n        return this.process(TPLProcessor.vaultTeam(teamId), Match.fn('KEY'));\n    }\n\n    /**\n     * This is a shortcut function that parses component template variables and replace them with their corresponding values\n     * @param templateSettings the component template settings to be used for parsing\n     * @returns\n     */\n    public parseComponentTemplateVarsAsync(templateSettings: Record<string, any>) {\n        return this.process(TPLProcessor.componentTemplateVar(templateSettings), Match.templateVariables);\n    }\n\n    /**\n     * Processes a template string by replacing the placeholders with the result of the provided processor function\n     * The processor function receives the token as an argument and should return the value to replace the token with\n     * If the processor function returns undefined, the token will be left as is\n     */\n    public process(processor: (token, matches?) => Promise<string> | string, regex: TemplateStringMatch = Match.default) {\n        if (typeof this._current !== 'string') return this;\n        //first build a json object with all matching tokens\n        let tokens = {};\n        let match;\n\n        const prosessorPromises = [];\n        while ((match = regex.exec(this._current)) !== null) {\n            const token = match[1];\n            tokens[token] = match[0];\n\n            const _processor = processor(token, match);\n\n            //if an async processor is used, the TemplateStringHelper switches to async mode\n            if (_processor instanceof Promise) {\n                _processor.then((result) => {\n                    if (result === undefined) {\n                        return match[0];\n                    }\n                    tokens[token] = result;\n                });\n                prosessorPromises.push(_processor);\n            } else {\n                tokens[token] = _processor;\n            }\n        }\n\n        if (prosessorPromises.length > 0) {\n            const promise = new Promise(async (resolve, reject) => {\n                await Promise.all(prosessorPromises);\n                this.parse(tokens, regex);\n                resolve(true);\n            });\n            this._promiseQueue.push(Promise.all(prosessorPromises));\n        } else {\n            this.parse(tokens, regex);\n        }\n\n        // this._current = await asyncReplace(this._current, regex, async (match, token) => {\n        //     let result = await processor(token);\n        //     if (result === undefined) {\n        //         return match;\n        //     }\n        //     return result;\n        // });\n\n        return this;\n    }\n\n    /**\n     * Removes all placeholders from the template string, leaving only the plain text\n     * This is useful when you want to clean up a template string that has placeholders that were not parsed\n     */\n    public clean(regex: TemplateStringMatch = Match.default) {\n        if (typeof this._current !== 'string') return this;\n        this._current = this._current.replace(regex, '');\n        return this;\n    }\n\n    // public toString() {\n    //     if (this._promiseQueue.length <= 0) return this._current;\n    //     return new Promise(async (resolve, reject) => {\n    //         await Promise.all(this._promiseQueue);\n    //         resolve(this._current);\n    //     });\n    // }\n}\n\n/**\n * a helper function that takes a string and escape it\n * This is useful when you have a stringified json and want to replace one of its values while making sure it won't break the json structure (e.g new lines, double quotes ...etc)\n */\nexport function escapeString(str?: string) {\n    if (!str) return str;\n    return str.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\t/g, '\\\\t');\n}\n\nexport function TemplateString(templateString: string) {\n    return TemplateStringHelper.create(templateString);\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nimport { jsonrepair } from 'jsonrepair';\nimport AgentRequest from '@sre/AgentManager/AgentRequest.class';\nimport { performTypeInference } from '@sre/helpers/TypeChecker.helper';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { uid } from '../utils';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\n// Utility function to check for empty values\nfunction isEmpty(value: any): boolean {\n    return (\n        value === undefined ||\n        value === null ||\n        (typeof value === 'string' && value.trim() === '') ||\n        (Array.isArray(value) && value.length === 0) ||\n        (typeof value === 'object' && value !== null && Object.keys(value).length === 0)\n    );\n}\nfunction isTemplateVar(str: string = ''): boolean {\n    if (!str || typeof str !== 'string') return false;\n    return (str?.match(/{{(.*?)}}/g) ?? []).length > 0;\n}\nfunction isKeyTemplateVar(str: string = ''): boolean {\n    if (!str || typeof str !== 'string') return false;\n    return (str?.match(/{{KEY\\((.*?)\\)}}/g) ?? []).length > 0;\n}\n\nfunction parseKey(str: string = '', teamId: string): string {\n    return str.replace(/{{KEY\\((.*?)\\)}}/g, (match, key) => {\n        return key === 'teamid' ? teamId : '';\n    });\n}\n\nexport default class APIEndpoint extends Component {\n    protected configSchema = Joi.object({\n        endpoint: Joi.string()\n            .pattern(/^[a-zA-Z0-9]+([-_][a-zA-Z0-9]+)*$/)\n            .max(50)\n            .required(),\n        method: Joi.string().valid('POST', 'GET').allow(''), //we're accepting empty value because we consider it POST by default.\n        description: Joi.string().max(5000).allow(''),\n        summary: Joi.string().max(1000).allow(''),\n        doc: Joi.string().max(1000).allow(''),\n        ai_exposed: Joi.boolean().default(true),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const req: AgentRequest = agent.agentRequest;\n        const logger = this.createComponentLogger(agent, config.name);\n\n        const headers = req ? req.headers : {};\n        let body = req ? req.body : input; //handle debugger injection\n        const params = req ? req.params : {};\n        let query = req ? req.query : {};\n        const _authInfo = req ? req._agent_authinfo : undefined;\n\n        // parse template variables\n        for (const [key, value] of Object.entries(body)) {\n            if (isKeyTemplateVar(value as string)) {\n                body[key] = await parseKey(value as string, agent?.teamId);\n            } else if (isTemplateVar(value as string)) {\n                //body[key] = parseTemplate(value as string, input, { escapeString: false });\n                body[key] = TemplateString(value as string).parse(input).result;\n            }\n        }\n\n        for (const [key, value] of Object.entries(query)) {\n            if (isKeyTemplateVar(value as string)) {\n                query[key] = await parseKey(value as string, agent?.teamId);\n            } else if (isTemplateVar(value as string)) {\n                //query[key] = parseTemplate(value as string, input, { escapeString: false });\n                query[key] = TemplateString(value as string).parse(input).result;\n            }\n        }\n\n        // set default value and agent variables\n        const inputsWithDefaultValue = config.inputs.filter(\n            (input) => input.defaultVal !== undefined && input.defaultVal !== '' && input.defaultVal !== null\n        );\n\n        const bodyInputNames: string[] = [];\n        const queryInputNames: string[] = [];\n\n        for (const output of config.outputs) {\n            const outputName = output?.expression || output?.name;\n            const inputName = outputName?.split('.')[1];\n\n            if (inputName) {\n                if (outputName?.includes('body')) {\n                    bodyInputNames.push(inputName);\n                }\n\n                if (outputName?.includes('query')) {\n                    queryInputNames.push(inputName);\n                }\n            }\n        }\n\n        for (const _inputWithDefaultValue of inputsWithDefaultValue) {\n            const inputName = _inputWithDefaultValue?.name;\n\n            let inputValue = input[inputName];\n\n            // We provide a default value for the OpenAPI Schema, which can detected by AnthropicAI. So we need to check if the default value is an Agent Variable. This is necessary for interactions with the Chatbot.\n\n            if (bodyInputNames.includes(inputName) && isEmpty(body[inputName])) {\n                body[inputName] = inputValue;\n            }\n\n            if (queryInputNames.includes(inputName) && isEmpty(query[inputName])) {\n                query[inputName] = inputValue;\n            }\n        }\n\n        //override debugger injection\n        // if (agent.agentRuntime.debug && body?.[0]?.dbg) { // ! 'dbg' is DEPRECATED\n        const isDbgInjection = req.header('X-Debug-Inj') !== undefined;\n        if (isDbgInjection && agent.agentRuntime.debug && Object.values(input).length > 0) {\n            switch (config.data.method) {\n                case 'GET':\n                    for (const [key, value] of Object.entries(input)) {\n                        if (value instanceof BinaryInput) {\n                            logger.debug('[WARNING] Binary files are not supported for GET requests. Key:', key);\n                        } else {\n                            query[key] = value as string;\n                        }\n                    }\n                    break;\n                case 'POST':\n                default:\n                    body = input;\n                    break;\n            }\n            //body = input;\n        }\n\n        // ensure strong data type\n        body = await performTypeInference(body, config.inputs, agent);\n        query = await performTypeInference(query, config.inputs, agent);\n\n        logger.debug('Parsing inputs');\n        logger.debug(' Headers', headers);\n        logger.debug(' Body', body);\n        logger.debug(' Params', params);\n        logger.debug(' Query', query);\n\n        //Handle JSON Data\n        //FIXME : this is a workaround that parses any json string in the body, we should only parse the json string in the body if the data type is explicitely set to JSON\n        //TODO : Add data types to APIEndpoint inputs\n        logger.debug('Parsing body json input');\n        for (let key in body) {\n            const value = body[key];\n            if (typeof value === 'string' && value.trim().startsWith('{') && value.trim().endsWith('}')) {\n                try {\n                    const obj = JSON.parse(jsonrepair(body[key]));\n                    body[key] = obj;\n                } catch {\n                    //skip it if it's not a valid json\n                }\n            }\n        }\n        logger.debug('Parsed body json input', body);\n\n        logger.debug('Parsing query json input');\n        for (let key in query) {\n            const value = query[key];\n            if (typeof value === 'string' && value.trim().startsWith('{') && value.trim().endsWith('}')) {\n                try {\n                    const obj = JSON.parse(jsonrepair(query[key] as string));\n                    query[key] = obj;\n                } catch {\n                    //skip it if it's not a valid json\n                }\n            }\n        }\n        logger.debug('Parsed query json input', query);\n\n        //Handle binary data\n        for (let input of config.inputs) {\n            if (!input.isFile && input?.type?.toLowerCase() !== 'binary') continue;\n\n            const fieldname = input.name;\n\n            logger.debug('Parsing file input ', fieldname);\n\n            let binaryInput = body[fieldname];\n\n            if (!(binaryInput instanceof BinaryInput)) {\n                // * when data sent with 'multipart/form-data' content type, we expect the files to be in req.files\n                if (req.files?.length > 0) {\n                    const file = req.files.find((file) => file.fieldname === fieldname);\n                    if (!file) continue;\n                    binaryInput = new BinaryInput(file.buffer, uid() + '-' + file.originalname, file.mimetype);\n                }\n            }\n\n            if (binaryInput instanceof BinaryInput) {\n                body[fieldname] = await binaryInput.getJsonData(AccessCandidate.agent(agent.id));\n            }\n            //console.log('file', fieldname, body[fieldname]);\n        }\n\n        return { headers, body, query, params, _authInfo, _debug: logger.output };\n    }\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Joi from 'joi';\n\nexport default class APIOutput extends Component {\n    protected configSchema = Joi.object({\n        format: Joi.string().valid('full', 'minimal').required().label('Output Format'),\n    });\n    public hasPostProcess = true;\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        const _error = undefined;\n        let Output = {};\n        logger.debug(` Processing outputs `);\n        for (let key in input) {\n            if (!config.inputs.find((i) => i.name == key)) continue; //exclude global variables\n            Output[key] = input[key];\n        }\n\n        if (config.data.format === 'raw') {\n            let rawOutput = '';\n            for (let key in input) {\n                if (!config.inputs.find((i) => i.name == key)) continue; //exclude global variables\n                rawOutput += input[key];\n            }\n            Output = rawOutput;\n        }\n        return { Output, _error, _debug: logger.output };\n    }\n    async postProcess(output, config, agent: Agent): Promise<any> {\n        for (let agentVar in agent.agentVariables) {\n            delete output?.result?.Output?.[agentVar]; //clean up agent variables from output\n        }\n        if (config?.data?.format == 'minimal') {\n            if (output?.result?.Output) {\n                return output?.result?.Output;\n            }\n\n            if (output?.result?._error) {\n                return output?.result?._error;\n            }\n\n            delete output.id;\n            delete output.name;\n        }\n        return output;\n    }\n}\n","import OpenAI from 'openai';\nimport Anthropic from '@anthropic-ai/sdk';\nimport { FunctionCallingMode } from '@google/generative-ai';\n\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\n\nexport type TLLMParams = {\n    model: string;\n    credentials:\n        | Record<string, string> // for VertexAI\n        | {\n              apiKey?: string; // for standard models\n              keyId?: string; // for Bedrock\n              secretKey?: string; // for Bedrock\n              sessionKey?: string; // for Bedrock\n          };\n\n    messages?: any[]; // TODO [Forhad]: apply proper typing\n    temperature?: number;\n    maxTokens?: number;\n    stopSequences?: string[];\n    topP?: number;\n    topK?: number;\n    frequencyPenalty?: number;\n    presencePenalty?: number;\n    responseFormat?: any; // TODO [Forhad]: apply proper typing\n    modelInfo?: TVertexAIModel | TBedrockModel;\n    fileSources?: BinaryInput[];\n    toolsConfig?: ToolsConfig;\n    baseURL?: string;\n\n    size?: '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792'; // for image generation\n    quality?: 'standard' | 'hd'; // for image generation\n    n?: number; // for image generation\n    style?: 'vivid' | 'natural'; // for image generation\n};\n\nexport type TLLMModelEntry = {\n    llm: string;\n    tokens?: number;\n    completionTokens?: number;\n    enabled?: boolean;\n    components?: string[];\n    alias?: string;\n    tags?: string[];\n    keyOptions?: {\n        tokens: number;\n        completionTokens: number;\n    };\n};\n\nexport type TLLMModel = {\n    llmName: string;\n    modelId: string;\n    tokens: number;\n    completionTokens: number;\n    components: string[];\n    tags: string[];\n};\n\n//#region === LLM Tools ===========================\nexport type ToolData = {\n    index: number;\n    id: string;\n    type: string;\n    name: string;\n    arguments: string | Record<string, any>;\n    role: 'user' | 'tool' | 'assistant';\n    result?: string; // result string from the used tool\n    function?: any;\n    error?: string; // for Bedrock\n};\n\nexport interface AnthropicToolDefinition {\n    name: string;\n    description: string;\n    input_schema: {\n        type: 'object';\n        properties: Record<string, unknown>;\n        required: string[];\n    };\n}\nexport type ToolDefinition = OpenAI.ChatCompletionTool | AnthropicToolDefinition;\nexport type ToolChoice = OpenAI.ChatCompletionToolChoiceOption | FunctionCallingMode;\n\nexport interface ToolsConfig {\n    tools?: ToolDefinition[];\n    tool_choice?: ToolChoice;\n}\n\n//#endregion\n\nexport enum TLLMMessageRole {\n    User = 'user',\n    Assistant = 'assistant',\n    System = 'system',\n    Model = 'model',\n    Tool = 'tool',\n    Function = 'function',\n}\n\nexport type TLLMMessageBlock = {\n    role: TLLMMessageRole;\n    content?:\n        | string\n        | { text: string }[]\n        | Array<Anthropic.TextBlockParam | Anthropic.ImageBlockParam | Anthropic.ToolUseBlockParam | Anthropic.ToolResultBlockParam>;\n    parts?: {\n        text?: string;\n        functionCall?: { name: string; args: string };\n        functionResponse?: { name: string; response: { name: string; content: string } };\n    }[]; // for Google Vertex AI\n    tool_calls?: ToolData[];\n};\n\nexport type TLLMToolResultMessageBlock = TLLMMessageBlock & {\n    tool_call_id?: string; // for tool result message block of OpenAI\n    name?: string; // for tool result message block of OpenAI\n};\n\nexport type GenerateImageConfig = {\n    size?: '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792';\n    quality?: 'standard' | 'hd';\n    model: string;\n    style?: 'vivid' | 'natural';\n    n?: number;\n    response_format?: 'url' | 'b64_json';\n};\n\ntype TCustomModel = {\n    name: string;\n    provider: 'Bedrock';\n    components: string[];\n    tags: string[];\n    features: string[];\n    tokens: number;\n    completionTokens: number;\n    settings: {\n        foundationModel: string;\n        customModel: string;\n        region: string;\n    };\n};\n\nexport type TBedrockModel = TCustomModel & {\n    settings: {\n        keyIDName: string;\n        secretKeyName: string;\n        sessionKeyName: string;\n    };\n};\n\nexport type TVertexAIModel = TCustomModel & {\n    settings: {\n        projectId: string;\n        credentialsName: string;\n        jsonCredentialsName: string;\n    };\n};\n\n// ! Deprecated\nexport type TLLMInputMessage = {\n    role: string;\n    content?: string | { text: string }[];\n    parts?: { text: string }[]; // * 'part' is for Google Vertex AI\n};\n\nexport enum TLLMProvider {\n    OpenAI = 'OpenAI',\n    AnthropicAI = 'AnthropicAI',\n    GoogleAI = 'GoogleAI',\n    Groq = 'Groq',\n    TogetherAI = 'TogetherAI',\n    Bedrock = 'Bedrock',\n    VertexAI = 'VertexAI',\n}\n\nexport interface ILLMContextStore {\n    save(messages: any[]): Promise<void>;\n    load(count?: number): Promise<any[]>;\n    getMessage(message_id: string): Promise<any[]>;\n}\n","export const models = {\n    echo: {\n        llm: 'Echo',\n        alias: 'Echo',\n    },\n    Echo: {\n        llm: 'Echo',\n        tokens: 128000,\n        completionTokens: 128000,\n        enabled: true,\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n    },\n    'deepseek-v2.5': {\n        llm: 'DeepSeek',\n        baseURL: 'https://api.deepseek.com/beta',\n        alias: 'deepseek-chat',\n    },\n    'deepseek-chat': {\n        llm: 'DeepSeek',\n        baseURL: 'https://api.deepseek.com/beta',\n        tokens: 128000,\n        completionTokens: 8192,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 8192 },\n    },\n\n    // GPT-4o\n    'gpt-4o-mini': {\n        llm: 'OpenAI',\n        alias: 'gpt-4o-mini-2024-07-18',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot', 'GPTPlugin'],\n    },\n    'gpt-4o-mini-2024-07-18': {\n        llm: 'OpenAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 16383 },\n    },\n    'gpt-4o': {\n        llm: 'OpenAI',\n        alias: 'gpt-4o-2024-08-06',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot', 'GPTPlugin'],\n    },\n    'gpt-4o-2024-08-06': {\n        llm: 'OpenAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 16384 },\n    },\n    'gpt-4o-2024-05-13': {\n        llm: 'OpenAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 8192 },\n    },\n\n    // GPT-4-turbo\n    'gpt-4-turbo-latest': {\n        llm: 'OpenAI',\n        alias: 'gpt-4-turbo-2024-04-09',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n        tags: ['legacy'],\n    },\n    'gpt-4-turbo': {\n        llm: 'OpenAI',\n        alias: 'gpt-4-turbo-2024-04-09',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'AgentPlugin', 'Chatbot', 'GPTPlugin'],\n        tags: ['legacy'],\n    },\n    'gpt-4-turbo-2024-04-09': {\n        llm: 'OpenAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: true,\n        keyOptions: { tokens: 128000, completionTokens: 4096 },\n    },\n\n    // GPT-4\n    'gpt-4-latest': {\n        llm: 'OpenAI',\n        alias: 'gpt-4-0613',\n        enabled: true,\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'gpt-4': {\n        llm: 'OpenAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: true,\n        keyOptions: { tokens: 8192, completionTokens: 8192 },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'AgentPlugin', 'Chatbot', 'GPTPlugin'],\n        tags: ['legacy'],\n    },\n    'gpt-4-0613': {\n        llm: 'OpenAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: true,\n        hidden: true,\n        keyOptions: { tokens: 8192, completionTokens: 8192 },\n    },\n    // GPT-3.5\n    'gpt-3.5-turbo-latest': {\n        llm: 'OpenAI',\n        alias: 'gpt-3.5-turbo-0125',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'AgentPlugin', 'Chatbot', 'GPTPlugin'],\n        tags: ['legacy'],\n    },\n    'gpt-3.5-turbo': {\n        llm: 'OpenAI',\n        alias: 'gpt-3.5-turbo-0125',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'AgentPlugin', 'Chatbot', 'GPTPlugin'],\n        tags: ['legacy'],\n    },\n    'gpt-3.5-turbo-0125': {\n        llm: 'OpenAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: true,\n        keyOptions: { tokens: 16385, completionTokens: 4096 },\n    },\n    'gpt-3.5-turbo-1106': {\n        llm: 'OpenAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: true,\n        keyOptions: { tokens: 16384, completionTokens: 4096 },\n        //components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n\n    'gpt-3.5-turbo-16k': {\n        llm: 'OpenAI',\n        alias: 'gpt-3.5-turbo-0125',\n        //components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    // legacy model to continue support for Agent Plugins\n    'gpt-3.5-turbo-0613': {\n        llm: 'OpenAI',\n        alias: 'gpt-3.5-turbo-0125',\n        //components: ['GPTPlugin', 'AgentPlugin'],\n        tags: ['deprecated'],\n    },\n\n    // AnthropicAI\n    'claude-3.5-haiku': {\n        llm: 'AnthropicAI',\n        alias: 'claude-3-5-haiku-latest',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'AgentPlugin', 'Chatbot'],\n        tags: ['new'],\n    },\n    'claude-3-5-haiku-latest': {\n        llm: 'AnthropicAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 8192, enabled: true },\n    },\n    'claude-3.5-sonnet': {\n        llm: 'AnthropicAI',\n        alias: 'claude-3-5-sonnet-latest',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n    },\n    'claude-3-5-sonnet-latest': {\n        llm: 'AnthropicAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 8192, enabled: true },\n    },\n    'claude-3-opus': {\n        llm: 'AnthropicAI',\n        alias: 'claude-3-opus-20240229',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n    },\n    'claude-3-opus-20240229': {\n        llm: 'AnthropicAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 4096, enabled: true },\n    },\n    'claude-3-sonnet': {\n        llm: 'AnthropicAI',\n        alias: 'claude-3-sonnet-20240229',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n        tags: ['legacy'],\n    },\n    'claude-3-sonnet-20240229': {\n        llm: 'AnthropicAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 4096, enabled: true },\n    },\n    'claude-3-haiku': {\n        llm: 'AnthropicAI',\n        alias: 'claude-3-haiku-20240307',\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier', 'VisionLLM', 'AgentPlugin', 'Chatbot'],\n    },\n    'claude-3-haiku-20240307': {\n        llm: 'AnthropicAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 4096, enabled: true },\n    },\n    'claude-2.1': {\n        llm: 'AnthropicAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 200000, completionTokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n        tags: ['legacy'],\n    },\n    'claude-instant-1.2': {\n        llm: 'AnthropicAI',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 100000, completionTokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n        tags: ['legacy'],\n    },\n\n    /*** Models from Google AI ***/\n\n    // Gemini 1.5 pro\n    'gemini-1.5-pro-latest': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 2097152, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n        tags: ['legacy'],\n    },\n    'gemini-1.5-pro-exp-0801': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 2097152, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n    },\n    'gemini-1.5-pro-latest-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.5-pro',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n    },\n    'gemini-1.5-pro-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.5-pro-001',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n    },\n    'gemini-1.5-pro': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 2097152, completionTokens: 8192, enabled: true },\n    },\n    'gemini-1.5-pro-001': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 2097152, completionTokens: 8192, enabled: true },\n    },\n\n    // Gemini 1.5 flash\n    'gemini-1.5-flash-latest': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 1048576, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n        tags: ['legacy'],\n    },\n    'gemini-1.5-flash-latest-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.5-flash',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n        tags: ['legacy'],\n    },\n    'gemini-1.5-flash-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.5-flash-001',\n        components: ['PromptGenerator', 'LLMAssistant', 'VisionLLM', 'MultimodalLLM'],\n    },\n    'gemini-1.5-flash': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 1048576, completionTokens: 8192, enabled: true },\n    },\n    'gemini-1.5-flash-001': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 1048576, completionTokens: 8192, enabled: true },\n    },\n\n    // Gemini 1.0 pro\n    'gemini-1.0-pro-latest': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 30720, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'gemini-1.0-pro-latest-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.0-pro',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'gemini-1.0-pro-stable': {\n        llm: 'GoogleAI',\n        alias: 'gemini-1.0-pro-001',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['legacy'],\n    },\n    'gemini-1.0-pro': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 30720, completionTokens: 8192, enabled: true },\n    },\n    'gemini-1.0-pro-001': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 30720, completionTokens: 8192, enabled: true },\n    },\n    'gemini-pro-vision': {\n        llm: 'GoogleAI',\n        tokens: 2048,\n        completionTokens: 2048,\n        enabled: false,\n        keyOptions: { tokens: 12288, completionTokens: 4096, enabled: true },\n        components: ['VisionLLM'],\n        tags: ['legacy'],\n    },\n\n    /* Groq */\n    'groq-llama-3.1-405b-reasoning': {\n        llm: 'Groq',\n        alias: 'llama-3.1-405b-reasoning',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama-3.1-405b-reasoning': {\n        llm: 'Groq',\n        tokens: 16000,\n        completionTokens: 16000,\n        enabled: false,\n        keyOptions: { tokens: 131072, completionTokens: 131072, enabled: true },\n    },\n    'groq-llama-3.1-70b-versatile': {\n        llm: 'Groq',\n        alias: 'llama-3.1-70b-versatile',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama-3.1-70b-versatile': {\n        llm: 'Groq',\n        tokens: 8000,\n        completionTokens: 8000,\n        enabled: false,\n        keyOptions: { tokens: 131072, completionTokens: 131072, enabled: true },\n    },\n    'groq-llama-3.1-8b-instant': {\n        llm: 'Groq',\n        alias: 'llama-3.1-8b-instant',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama-3.1-8b-instant': {\n        llm: 'Groq',\n        tokens: 8000,\n        completionTokens: 8000,\n        enabled: false,\n        keyOptions: { tokens: 131072, completionTokens: 131072, enabled: true },\n    },\n    'llama3-groq-70b-8192-tool-use-preview': {\n        llm: 'Groq',\n        tokens: 8192,\n        completionTokens: 8192,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama3-groq-8b-8192-tool-use-preview': {\n        llm: 'Groq',\n        tokens: 8192,\n        completionTokens: 8192,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'groq-llama3-8b': {\n        llm: 'Groq',\n        alias: 'llama3-8b-8192',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama3-8b-8192': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n    },\n    'groq-llama3-70b': {\n        llm: 'Groq',\n        alias: 'llama3-70b-8192',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama3-70b-8192': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n    },\n    'groq-llama2-70b': {\n        llm: 'Groq',\n        alias: 'llama2-70b-4096',\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n    },\n    'llama2-70b-4096': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, completionTokens: 4096, enabled: true },\n    },\n    'groq-mixtral-8x7b': {\n        llm: 'Groq',\n        alias: 'mixtral-8x7b-32768',\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'mixtral-8x7b-32768': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, completionTokens: 32768, enabled: true },\n    },\n    'groq-gemma-7b': {\n        llm: 'Groq',\n        alias: 'gemma-7b-it',\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'gemma-7b-it': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n    },\n    'groq-gemma2-9b': {\n        llm: 'Groq',\n        alias: 'gemma2-9b-it',\n        components: ['PromptGenerator', 'LLMAssistant'],\n    },\n    'gemma2-9b-it': {\n        llm: 'Groq',\n        tokens: 1024,\n        completionTokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, completionTokens: 8192, enabled: true },\n    },\n\n    /* Together AI */\n    'zero-one-ai/Yi-34B-Chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has \"```json...```\" with JSON response)\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Austism/chronos-hermes-13b': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // Meta\n    'meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo': {\n        llm: 'TogetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 128000, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo': {\n        llm: 'TogetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 128000, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo': {\n        llm: 'TogetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Meta-Llama-3-8B-Instruct-Turbo': {\n        llm: 'TogetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Meta-Llama-3-70B-Instruct-Turbo': {\n        llm: 'TogetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Meta-Llama-3-8B-Instruct-Lite': {\n        llm: 'TogetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Meta-Llama-3-70B-Instruct-Lite': {\n        llm: 'TogetherAI',\n        tokens: 4096,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['LLMAssistant', 'PromptGenerator'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'togethercomputer/CodeLlama-13b-Instruct': {\n        // ! DEPRECATED: will be removed (replace with codellama/CodeLlama-13b-Instruct-hf)\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'codellama/CodeLlama-13b-Instruct-hf': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'togethercomputer/CodeLlama-34b-Instruct': {\n        // ! DEPRECATED: will be removed (replaced with codellama/CodeLlama-34b-Instruct-hf)\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'codellama/CodeLlama-34b-Instruct-hf': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'codellama/CodeLlama-70b-Instruct-hf': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'togethercomputer/CodeLlama-7b-Instruct': {\n        // ! DEPRECATED: will be removed (replaced with codellama/CodeLlama-7b-Instruct-hf)\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'codellama/CodeLlama-7b-Instruct-hf': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 16384, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Llama-2-70b-chat-hf': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Llama-2-13b-chat-hf': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has introductory text with JSON response)\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Llama-2-7b-chat-hf': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has introductory text with JSON response)\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Llama-3-8b-chat-hf': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'meta-llama/Llama-3-70b-chat-hf': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'togethercomputer/falcon-7b-instruct': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    // mistralai\n    'mistralai/Mistral-7B-Instruct-v0.1': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'mistralai/Mistral-7B-Instruct-v0.2': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'mistralai/Mistral-7B-Instruct-v0.3': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'mistralai/Mixtral-8x7B-Instruct-v0.1': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant', 'Classifier'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'mistralai/Mixtral-8x22B-Instruct-v0.1': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 65536, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    'Gryphe/MythoMax-L2-13b': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // NousResearch\n    'NousResearch/Nous-Hermes-Llama2-70b': {\n        // ! DEPRECATED: will be removed (404 - not found)\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'NousResearch/Nous-Capybara-7B-V1p9': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'NousResearch/Nous-Hermes-2-Mistral-7B-DPO': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'NousResearch/Nous-Hermes-2-Mixtral-8x7B-DPO': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'NousResearch/Nous-Hermes-2-Mixtral-8x7B-SFT': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'NousResearch/Nous-Hermes-2-Yi-34B': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'NousResearch/Nous-Hermes-llama-2-7b': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'NousResearch/Nous-Hermes-Llama2-13b': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // OpenChat\n    'openchat/openchat-3.5-1210': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // Teknium\n    'teknium/OpenHermes-2-Mistral-7B': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'teknium/OpenHermes-2p5-Mistral-7B': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    'garage-bAInd/Platypus2-70B-instruct': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'microsoft/WizardLM-2-8x22B': {\n        llm: 'TogetherAI',\n        tokens: 65536,\n        completionTokens: 8192,\n        enabled: false,\n        keyOptions: { tokens: 65536, completionTokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'upstage/SOLAR-10.7B-Instruct-v1.0': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'togethercomputer/StripedHyena-Nous-7B': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'lmsys/vicuna-7b-v1.5': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'lmsys/vicuna-13b-v1.5': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // Allen AI\n    'allenai/OLMo-7B-Twin-2T': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'allenai/OLMo-7B': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // Qwen\n    'Qwen/Qwen1.5-0.5B-Chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has introductory text with JSON response)\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Qwen/Qwen1.5-1.8B-Chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Qwen/Qwen1.5-4B-Chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Qwen/Qwen1.5-7B-Chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Qwen/Qwen1.5-14B-Chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Qwen/Qwen1.5-32B-Chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Qwen/Qwen1.5-72B-Chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Qwen/Qwen1.5-110B-Chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // DeepSeek\n    'deepseek-ai/deepseek-coder-33b-instruct': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 16384, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'deepseek-ai/deepseek-llm-67b-chat': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // Google\n    'google/gemma-2b-it': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'google/gemma-7b-it': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'google/gemma-2-9b-it': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'google/gemma-2-27b-it': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // Undi95\n    'Undi95/Toppy-M-7B': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // Others\n    'cognitivecomputations/dolphin-2.5-mixtral-8x7b': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'databricks/dbrx-instruct': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Open-Orca/Mistral-7B-OpenOrca': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 8192, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'snorkelai/Snorkel-Mistral-PairRM-DPO': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 32768, enabled: true },\n        components: ['LLMAssistant'], // * Excluded from 'PromptGenerator' (has some other text)\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'Snowflake/snowflake-arctic-instruct': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        tags: ['new'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'togethercomputer/alpaca-7b': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 2048, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n    'WizardLM/WizardLM-13B-V1.2': {\n        llm: 'TogetherAI',\n        tokens: 1024,\n        enabled: false,\n        keyOptions: { tokens: 4096, enabled: true },\n        components: ['PromptGenerator', 'LLMAssistant'],\n        baseURL: 'https://api.together.xyz/v1',\n    },\n\n    // We do not get the exact token information for Dalle models, so use the maximum possible values\n    'dall-e-3': {\n        llm: 'OpenAI',\n        alias: 'dall-e-3',\n        enabled: true,\n        components: ['ImageGenerator'],\n        tokens: 2048,\n        completionTokens: 2048,\n        keyOptions: { tokens: 128000, completionTokens: 16383 },\n    },\n    'dall-e-2': {\n        llm: 'OpenAI',\n        alias: 'dall-e-2',\n        enabled: true,\n        components: ['ImageGenerator'],\n        tokens: 2048,\n        completionTokens: 2048,\n        keyOptions: { tokens: 128000, completionTokens: 16383 },\n    },\n};\n","import { models } from './models';\n\nexport class LLMRegistry {\n    private static instance: LLMRegistry = null;\n\n    private constructor(private model: string) {\n        this.model = model;\n    }\n\n    public static getInstance(model: string) {\n        if (!this.instance) {\n            this.instance = new LLMRegistry(model);\n        }\n\n        return this.instance;\n    }\n\n    public static isStandardLLM(model: string): boolean {\n        return this.modelExists(model);\n    }\n\n    public static getModelId(model: string): string {\n        return models?.[model]?.alias || model;\n    }\n\n    public static getBaseURL(model: string): string {\n        const modelId = this.getModelId(model);\n        return models?.[modelId]?.baseURL || undefined;\n    }\n\n    public static getModelKeyOptions(model: string): Record<string, any> {\n        const modelId = this.getModelId(model);\n        return models?.[modelId]?.keyOptions || {};\n    }\n\n    public static getProvider(model: string): string {\n        const modelId = this.getModelId(model);\n        return models?.[modelId]?.llm;\n    }\n\n    public static getModelInfo(model: string, hasAPIKey: boolean = false): Record<string, any> {\n        const modelId = this.getModelId(model);\n        const modelInfo = models?.[modelId] || {};\n\n        if (hasAPIKey) {\n            const keyOptions = LLMRegistry.getModelKeyOptions(modelId);\n            return { ...modelInfo, ...keyOptions };\n        }\n\n        return modelInfo;\n    }\n\n    public static modelExists(model: string): boolean {\n        if (model.toLowerCase() === 'echo') return true;\n        const modelId = this.getModelId(model);\n        return !!models?.[modelId];\n    }\n\n    //#region tokens related methods\n    public static getMaxContextTokens(model: string, hasAPIKey: boolean = false): number {\n        const modelInfo = this.getModelInfo(model, hasAPIKey);\n        return modelInfo?.tokens;\n    }\n\n    public static getMaxCompletionTokens(model: string, hasAPIKey: boolean = false): number {\n        const modelInfo = this.getModelInfo(model, hasAPIKey);\n        return modelInfo?.completionTokens || modelInfo?.tokens;\n    }\n\n    public static adjustMaxCompletionTokens(model: string, maxTokens: number, hasAPIKey: boolean = false): number {\n        const modelInfo = this.getModelInfo(model, hasAPIKey);\n        return Math.min(maxTokens, modelInfo?.completionTokens || modelInfo?.tokens);\n    }\n\n    public static async validateTokensLimit({\n        model,\n        promptTokens,\n        completionTokens,\n        hasAPIKey = false,\n    }: {\n        model: string;\n        promptTokens: number;\n        completionTokens: number;\n        hasAPIKey?: boolean;\n    }): Promise<void> {\n        const allowedContextTokens = this.getMaxContextTokens(model, hasAPIKey);\n        const totalTokens = promptTokens + completionTokens;\n\n        const teamAPIKeyExceededMessage = `This models' maximum content length is ${allowedContextTokens} tokens. (This is the sum of your prompt with all variables and the maximum output tokens you've set in Advanced Settings) However, you requested approx ${totalTokens} tokens (${promptTokens} in the prompt, ${completionTokens} in the output). Please reduce the length of either the input prompt or the Maximum output tokens.`;\n        const noAPIKeyExceededMessage = `Input exceeds max tokens limit of ${allowedContextTokens}. Please add your API key to unlock full length.`;\n\n        if (totalTokens > allowedContextTokens) {\n            throw new Error(hasAPIKey ? teamAPIKeyExceededMessage : noAPIKeyExceededMessage);\n        }\n    }\n    //#endregion tokens related methods\n}\n","//! ***IMPORTANT***\n// * WE HAVE SAME FILE IN THREE PLACE, SO ANY CHANGES SHOULD BE SYNCED\n// * - /smyth-builder-ui/src/shared/custom-models.ts\n// * - /smyth-builder-server/src/services/LLMHelper/custom-models.ts\n// * - /smyth-runtime/src/subsystems/LLMManager/custom-models.ts\n//! ***IMPORTANT***\n/**\n * Custom model configurations for various AI providers.\n * This template is useful for maintaining up-to-date model aliases and token information,\n * even though we store custom model data in the database.\n */\n\nexport const customModels = {\n  /**************************************************\n   * AWS Bedrock Models\n   **************************************************/\n\n  /*\n  Context token information sourced from the AWS Bedrock Console:\n  https://us-east-1.console.aws.amazon.com/bedrock/home?region=us-east-1#/overview\n  \n  Completion token information sourced from the AWS Bedrock Text Playground:\n  https://us-east-1.console.aws.amazon.com/bedrock/home?region=us-east-1#/text-playground\n\n  Supported model features information sourced from - https://docs.aws.amazon.com/bedrock/latest/userguide/conversation-inference-supported-models-features.html\n  */\n\n  //#region AI21 Labs Models\n  'ai21.jamba-1-5-mini-v1:0': {\n    llm: 'Bedrock',\n    label: 'AI21 Labs - Jamba 1.5 Mini',\n    tokens: 256000,\n    completionTokens: 4096,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n    tags: ['new'],\n  },\n  'ai21.jamba-1-5-large-v1:0': {\n    llm: 'Bedrock',\n    label: 'AI21 Labs - Jamba 1.5 Large',\n    tokens: 256000,\n    completionTokens: 4096,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n    tags: ['new'],\n  },\n  'ai21.jamba-instruct-v1:0': {\n    llm: 'Bedrock',\n    label: 'AI21 Labs - Jamba-Instruct',\n    tokens: 256000,\n    completionTokens: 4096,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'ai21.j2-ultra-v1': {\n    llm: 'Bedrock',\n    label: 'AI21 Labs - Jurassic-2 Ultra',\n    tokens: 8191,\n    completionTokens: 8191,\n    supportsSystemPrompt: false,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator'],\n  },\n  'ai21.j2-mid-v1': {\n    llm: 'Bedrock',\n    label: 'AI21 Labs - Jurassic-2 Mid',\n    tokens: 8191,\n    completionTokens: 8191,\n    supportsSystemPrompt: false,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator'],\n  },\n  //#endregion AI21 Labs Models\n\n  //#region Amazon Models\n  'amazon.titan-text-premier-v1:0': {\n    llm: 'Bedrock',\n    label: 'Amazon - Titan Text Premier',\n    tokens: 32000,\n    completionTokens: 3000,\n    supportsSystemPrompt: false,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator'],\n  },\n  'amazon.titan-text-express-v1': {\n    llm: 'Bedrock',\n    label: 'Amazon - Titan Text G1 - Express',\n    tokens: 8192,\n    completionTokens: 4096,\n    supportsSystemPrompt: false,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator'],\n  },\n  'amazon.titan-text-lite-v1': {\n    llm: 'Bedrock',\n    label: 'Amazon - Titan Text G1 - Lite',\n    tokens: 4096,\n    completionTokens: 4096,\n    supportsSystemPrompt: false,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator'],\n  },\n  // 'Amazon - Titan Embeddings G1 - Text': { alias: 'amazon.titan-embed-text-v1' }, // Converse API doesn't support\n  // 'Amazon - Titan Embedding Text v2': { alias: 'amazon.titan-embed-text-v2:0' }, // Converse API doesn't support\n  // 'Amazon - Titan Multimodal Embeddings G1': { alias: 'amazon.titan-embed-image-v1' }, // Converse API doesn't support\n  // 'Amazon - Titan Image Generator G1 V1': { alias: 'amazon.titan-image-generator-v1' }, // Converse API doesn't support\n  // 'Amazon - Titan Image Generator G1 V2': { alias: 'amazon.titan-image-generator-v2:0' }, // Converse API doesn't support\n\n  //#endregion Amazon Models\n\n  //#region Anthropic Models\n  // * NOTE: It's required to submit business info to get access for Anthropic models\n  // * @Ref of Anthropic tokens and completionTokens - https://docs.anthropic.com/en/docs/about-claude/models\n  'us.anthropic.claude-3-5-haiku-20241022-v1:0': {\n    llm: 'Bedrock',\n    label: 'Anthropic - Claude 3.5 Haiku',\n    tokens: 200000,\n    completionTokens: 8192,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n    tags: ['v1:0', 'new'],\n  },\n  'us.anthropic.claude-3-5-sonnet-20241022-v2:0': {\n    llm: 'Bedrock',\n    label: 'Anthropic - Claude 3.5 Sonnet',\n    tokens: 200000,\n    completionTokens: 8192,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n    tags: ['v2:0', 'new'],\n  },\n  'anthropic.claude-3-5-sonnet-20240620-v1:0': {\n    llm: 'Bedrock',\n    label: 'Anthropic - Claude 3.5 Sonnet',\n    tokens: 200000,\n    completionTokens: 8192,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n    tags: ['v1:0'],\n  },\n  'anthropic.claude-3-sonnet-20240229-v1:0': {\n    llm: 'Bedrock',\n    label: 'Anthropic - Claude 3 Sonnet',\n    tokens: 200000,\n    completionTokens: 4096,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n    tags: ['v1:0'],\n  },\n  'anthropic.claude-3-haiku-20240307-v1:0': {\n    llm: 'Bedrock',\n    label: 'Anthropic - Claude 3 Haiku',\n    tokens: 200000,\n    completionTokens: 4096,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n    tags: ['v1:0'],\n  },\n  'anthropic.claude-3-opus-20240229-v1:0': {\n    llm: 'Bedrock',\n    label: 'Anthropic - Claude 3 Opus',\n    tokens: 200000,\n    completionTokens: 4096,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n    tags: ['v1:0'],\n  },\n  'anthropic.claude-v2:1': {\n    llm: 'Bedrock',\n    label: 'Anthropic - Claude 2.1',\n    tokens: 200000,\n    completionTokens: 4096,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n    tags: ['v2:1'],\n  },\n  'anthropic.claude-v2': {\n    llm: 'Bedrock',\n    label: 'Anthropic - Claude 2.0',\n    tokens: 100000,\n    completionTokens: 4096,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'anthropic.claude-instant-v1': {\n    llm: 'Bedrock',\n    label: 'Anthropic - Claude Instant',\n    tokens: 100000,\n    completionTokens: 4096,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  //#endregion Anthropic Models\n\n  //#region Cohere Models\n  'cohere.command-r-plus-v1:0': {\n    llm: 'Bedrock',\n    label: 'Cohere - Command R+',\n    tokens: 128000,\n    completionTokens: 4000, // Found 4000 Max tokens in the Playground\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n  },\n  'cohere.command-r-v1:0': {\n    llm: 'Bedrock',\n    label: 'Cohere - Command R',\n    tokens: 128000,\n    completionTokens: 4000, // Found 4000 Max tokens in the Playground\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: true,\n    components: ['PromptGenerator', 'LLMAssistant', 'AgentPlugin', 'Chatbot'],\n  },\n  'cohere.command-text-v14': {\n    llm: 'Bedrock',\n    label: 'Cohere - Command',\n    tokens: 4000, // Found 4k\n    completionTokens: 4000, // Found 4000 Max tokens in the Playground\n    supportsSystemPrompt: false,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator'],\n  },\n  'cohere.command-light-text-v14': {\n    llm: 'Bedrock',\n    label: 'Cohere - Command Light',\n    tokens: 4000, // 4k tokens\n    completionTokens: 4000, // Found 4000 Max tokens in the Playground\n    supportsSystemPrompt: false,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator'],\n  },\n  // 'Cohere - Embed English': { alias: 'cohere.embed-english-v3' }, // Converse API doesn't support\n  // 'Cohere - Embed Multilingual': { alias: 'cohere.embed-multilingual-v3' }, // Converse API doesn't support\n  //#endregion Cohere Models\n\n  //#region Meta Models\n\n  // 'Meta - Llama 2 Chat 13B' : { alias: 'meta.llama2-13b-chat-v1' } // Don't have access to the model\n  // 'Meta - Llama 2 Chat 70B' : { alias: 'meta.llama2-70b-chat-v1' } // Don't have access to the model\n  'us.meta.llama3-2-1b-instruct-v1:0': {\n    llm: 'Bedrock',\n    label: 'Meta - Llama 3.2 1B Instruct',\n    tokens: 200000,\n    completionTokens: 2048,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n    tags: ['new'],\n  },\n  'us.meta.llama3-2-3b-instruct-v1:0': {\n    llm: 'Bedrock',\n    label: 'Meta - Llama 3.2 3B Instruct',\n    tokens: 200000,\n    completionTokens: 2048,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n    tags: ['new'],\n  },\n  'meta.llama3-8b-instruct-v1:0': {\n    llm: 'Bedrock',\n    label: 'Meta - Llama 3 8B Instruct',\n    tokens: 8192,\n    completionTokens: 2048,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'meta.llama3-70b-instruct-v1:0': {\n    llm: 'Bedrock',\n    label: 'Meta - Llama 3 70B Instruct',\n    tokens: 8192,\n    completionTokens: 2048,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  // 'Meta - Llama 3.1 8B Instruct': { alias: 'meta.llama3-1-8b-instruct-v1:0' }, // The provided model identifier is invalid.\n  // 'Meta - Llama 3.1 70B Instruct': { alias: 'meta.llama3-1-70b-instruct-v1:0' }, // The provided model identifier is invalid.\n  // 'Meta - Llama 3.1 405B Instruct': { alias: 'meta.llama3-1-405b-instruct-v1:0' }, // The provided model identifier is invalid.\n\n  //#endregion Meta Models\n\n  //#region Mistral Models\n  'mistral.mistral-7b-instruct-v0:2': {\n    llm: 'Bedrock',\n    label: 'Mistral AI - Mistral 7B Instruct',\n    tokens: 32000,\n    completionTokens: 8192,\n    supportsSystemPrompt: false,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator'],\n  },\n  'mistral.mixtral-8x7b-instruct-v0:1': {\n    llm: 'Bedrock',\n    label: 'Mistral AI - Mixtral 8X7B Instruct',\n    tokens: 32000,\n    completionTokens: 4096,\n    supportsSystemPrompt: false,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator'],\n  },\n  'mistral.mistral-large-2402-v1:0': {\n    llm: 'Bedrock',\n    label: 'Mistral AI - Mistral Large',\n    tokens: 32000,\n    completionTokens: 8192,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  // 'Mistral AI - Mistral Large 2 (24.07)' : { alias: 'mistral.mistral-large-2407-v1:0' } // The provided model identifier is invalid.\n  'mistral.mistral-small-2402-v1:0': {\n    llm: 'Bedrock',\n    label: 'Mistral AI - Mistral Small',\n    tokens: 32000,\n    completionTokens: 8192,\n    supportsSystemPrompt: true,\n    supportsStreamingToolUse: false,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  //#endregion Mistral Models\n\n  //#region Stability Models\n  // 'Stability AI - Stable Diffusion XL 0.x' : { alias: 'stability.stable-diffusion-xl-v0' } // Converse API doesn't support\n  // 'Stability AI - Stable Diffusion XL 1.x' : { alias: 'stability.stable-diffusion-xl-v1' } // Converse API doesn't support\n  //#endregion Stability Models\n\n  /**************************************************\n   * Vertex AI Models\n   **************************************************/\n\n  /*\n  Context token information sourced from :\n  Vertex AI documentation - https://cloud.google.com/vertex-ai/generative-ai/docs/learn/models\n  Anthropic - https://docs.anthropic.com/en/docs/about-claude/models\n  \n  Completion token information sourced from:\n  Vertex AI Text Playground - https://console.cloud.google.com/vertex-ai/generative/language/create/text?model=text-bison@001&authuser=1&project=opt-smythos-vertexia-432522\n  */\n\n  'gemini-1.5-flash': {\n    llm: 'VertexAI',\n    label: 'Gemini 1.5 Flash',\n    supportsSystemPrompt: true,\n    tokens: 1048576,\n    completionTokens: 8192,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'gemini-1.5-pro': {\n    llm: 'VertexAI',\n    label: 'Gemini 1.5 Pro',\n    supportsSystemPrompt: true,\n    tokens: 2097152,\n    completionTokens: 8192,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'gemini-1.0-pro': {\n    llm: 'VertexAI',\n    label: 'Gemini 1.0 Pro',\n    supportsSystemPrompt: true,\n    tokens: 32760,\n    completionTokens: 8192,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'claude-3-5-haiku': {\n    llm: 'VertexAI',\n    label: 'Claude 3.5 Haiku',\n    supportsSystemPrompt: true,\n    tokens: 200000,\n    completionTokens: 8192,\n    tags: ['new'],\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'claude-3-5-sonnet-v2': {\n    llm: 'VertexAI',\n    label: 'Claude 3.5 Sonnet',\n    supportsSystemPrompt: true,\n    tokens: 200000,\n    completionTokens: 8192,\n    tags: ['v2', 'new'],\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'claude-3-5-sonnet': {\n    llm: 'VertexAI',\n    label: 'Claude 3.5 Sonnet',\n    supportsSystemPrompt: true,\n    tokens: 200000,\n    completionTokens: 8192,\n    tags: ['v1'],\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'claude-3-sonnet': {\n    llm: 'VertexAI',\n    label: 'Claude 3 Sonnet',\n    supportsSystemPrompt: true,\n    tokens: 200000,\n    completionTokens: 4096,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'claude-3-opus': {\n    llm: 'VertexAI',\n    label: 'Claude 3 Opus',\n    supportsSystemPrompt: true,\n    tokens: 200000,\n    completionTokens: 4096,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'claude-3-haiku': {\n    llm: 'VertexAI',\n    label: 'Claude 3 Haiku',\n    supportsSystemPrompt: true,\n    tokens: 200000,\n    completionTokens: 4096,\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  gemma2: {\n    llm: 'VertexAI',\n    label: 'Gemma 2',\n    supportsSystemPrompt: true,\n    tokens: 8192, // @Ref https://huggingface.co/blog/gemma2\n    completionTokens: 4096, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/google/model-garden/gemma2?authuser=1&project=opt-smythos-vertexia-432522\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  gemma: {\n    llm: 'VertexAI',\n    label: 'Gemma',\n    supportsSystemPrompt: true,\n    tokens: 8192, // @Ref https://huggingface.co/blog/gemma2\n    completionTokens: 4096, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/google/model-garden/gemma?authuser=1&project=opt-smythos-vertexia-432522\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  codegemma: {\n    llm: 'VertexAI',\n    label: 'CodeGemma',\n    supportsSystemPrompt: true,\n    tokens: 8192, // @Ref - https://huggingface.co/google/gemma-7b-it/discussions/73\n    completionTokens: 4096, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/google/model-garden/codegemma?authuser=1&project=opt-smythos-vertexia-432522\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'llama3-405b-instruct-maas': {\n    llm: 'VertexAI',\n    label: 'Llama 3.1 API Service',\n    supportsSystemPrompt: true,\n    tokens: 4096, // @Ref - https://docs.together.ai/docs/chat-models\n    completionTokens: 4096, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/meta/model-garden/llama3-405b-instruct-maas?authuser=1&project=opt-smythos-vertexia-432522\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  llama3_1: {\n    llm: 'VertexAI',\n    label: 'Llama 3.1',\n    supportsSystemPrompt: true,\n    tokens: 4096, // by querying with Gemini - https://gemini.google.com/\n    completionTokens: 4096, // by querying with Gemini - https://gemini.google.com/\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'llama-guard': {\n    llm: 'VertexAI',\n    label: 'Llama Guard',\n    supportsSystemPrompt: true,\n    tokens: 8192, // @Ref - by querying with Gemini - https://gemini.google.com/\n    completionTokens: 4096, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/meta/model-garden/llama-guard?authuser=1&project=opt-smythos-vertexia-432522\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  llama3: {\n    llm: 'VertexAI',\n    label: 'Llama 3',\n    supportsSystemPrompt: true,\n    tokens: 8192, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/meta/model-garden/llama3?_ga=2.79473366.358158393.1724662649-247251619.1697981116&authuser=1&project=opt-smythos-vertexia-432522\n    completionTokens: 4096, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/meta/model-garden/llama3?_ga=2.79473366.358158393.1724662649-247251619.1697981116&authuser=1&project=opt-smythos-vertexia-432522\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  llama2: {\n    llm: 'VertexAI',\n    label: 'Llama 2',\n    value: 'llama2',\n    supportsSystemPrompt: true,\n    tokens: 4096, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/meta/model-garden/llama2?authuser=1&project=opt-smythos-vertexia-432522\n    completionTokens: 4096, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/meta/model-garden/llama2?authuser=1&project=opt-smythos-vertexia-432522\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'mistral-large': {\n    llm: 'VertexAI',\n    label: 'Mistral Large (2407)',\n    supportsSystemPrompt: true,\n    tokens: 128000, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/mistralai/model-garden/mistral-large?authuser=1&project=opt-smythos-vertexia-432522\n    completionTokens: 8192, // Guessing from the context window (tokens)\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'mistral-nemo': {\n    llm: 'VertexAI',\n    label: 'Mistral Nemo',\n    supportsSystemPrompt: true,\n    tokens: 128000, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/mistralai/model-garden/mistral-nemo?authuser=1&project=opt-smythos-vertexia-432522\n    completionTokens: 8192, // Guessing from the context window (tokens)\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  codestral: {\n    llm: 'VertexAI',\n    label: 'Codestral',\n    supportsSystemPrompt: true,\n    tokens: 32000, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/mistralai/model-garden/codestral?authuser=1&project=opt-smythos-vertexia-432522\n    completionTokens: 4096, // Guessing from the context window (tokens)\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  mixtral: {\n    llm: 'VertexAI',\n    label: 'Mixtral',\n    supportsSystemPrompt: true,\n    tokens: 32000, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/mistral-ai/model-garden/mixtral?authuser=1&project=opt-smythos-vertexia-432522\n    completionTokens: 4096, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/mistral-ai/model-garden/mixtral?authuser=1&project=opt-smythos-vertexia-432522\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'chat-bison': {\n    llm: 'VertexAI',\n    label: 'PaLM 2 Chat Bison',\n    supportsSystemPrompt: true,\n    tokens: 4096, // @Ref - by querying with Gemini - https://gemini.google.com/\n    completionTokens: 2048, // @Ref - https://console.cloud.google.com/vertex-ai/generative/language/create/chat?model=chat-bison@002&authuser=1&project=opt-smythos-vertexia-432522 [Playground]\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'text-bison': {\n    llm: 'VertexAI',\n    label: 'PaLM 2 Text Bison',\n    supportsSystemPrompt: true,\n    tokens: 32768, // by querying with Gemini - https://gemini.google.com/\n    completionTokens: 2048, // @Ref - https://console.cloud.google.com/vertex-ai/generative/language/create/text?model=text-bison@001&authuser=1&project=opt-smythos-vertexia-432522 [Playground]\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  phi3: {\n    llm: 'VertexAI',\n    label: 'Phi-3',\n    supportsSystemPrompt: true,\n    tokens: 128000, // @Ref - https://console.cloud.google.com/vertex-ai/publishers/microsoft/model-garden/phi3?authuser=1&project=opt-smythos-vertexia-432522\n    completionTokens: 8192, // Guessing from the context window (tokens)\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  qwen2: {\n    llm: 'VertexAI',\n    label: 'Qwen2',\n    supportsSystemPrompt: true,\n    tokens: 131072, // @Ref - https://huggingface.co/Qwen/Qwen2-72B-Instruct\n    completionTokens: 8192, // Guessing from the context window (tokens)\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  mammut: {\n    llm: 'VertexAI',\n    label: 'MaMMUT',\n    supportsSystemPrompt: true,\n    tokens: 4096, // @Ref - by querying with Gemini - https://gemini.google.com/\n    completionTokens: 2048, // @Ref - by querying with Gemini - https://gemini.google.com/\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'lmsys-vicuna-7b': {\n    llm: 'VertexAI',\n    label: 'Vicuna',\n    supportsSystemPrompt: true,\n    tokens: 4096, // @Ref - https://docs.together.ai/docs/chat-models\n    completionTokens: 2048, // @Ref - Guessing from the context window (tokens)\n    components: ['PromptGenerator', 'LLMAssistant'],\n  },\n  'bio-gpt': {\n    llm: 'VertexAI',\n    label: 'BioGPT',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'microsoft-biomedclip': {\n    llm: 'VertexAI',\n    label: 'BiomedCLIP',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  mistral: {\n    llm: 'VertexAI',\n    label: 'Mistral Self-host (7B & Nemo)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  nllb: {\n    llm: 'VertexAI',\n    label: 'NLLB',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'codellama-7b-hf': {\n    llm: 'VertexAI',\n    label: 'Code Llama',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'palmyra-med': {\n    llm: 'VertexAI',\n    label: 'Palmyra Med (Writer)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'llama-2-quantized': {\n    llm: 'VertexAI',\n    label: 'Llama 2 (Quantized)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'bert-base-uncased': {\n    llm: 'VertexAI',\n    label: 'BERT (PEFT)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'falcon-instruct-7b-peft': {\n    llm: 'VertexAI',\n    label: 'Falcon-instruct (PEFT)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  openllama: {\n    llm: 'VertexAI',\n    label: 'OpenLLaMA (PEFT)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'roberta-large': {\n    llm: 'VertexAI',\n    label: 'RoBERTa-large (PEFT)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'xlm-roberta-large': {\n    llm: 'VertexAI',\n    label: 'XLM-RoBERTa-large (PEFT)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'bart-large-cnn': {\n    llm: 'VertexAI',\n    label: 'Bart-large-cnn',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'dolly-v2': {\n    llm: 'VertexAI',\n    label: 'Dolly-v2',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  imagetext: {\n    llm: 'VertexAI',\n    label: 'Imagen for Captioning & VQA',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'codechat-bison': {\n    llm: 'VertexAI',\n    label: 'Codey for Code Chat',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'code-bison': {\n    llm: 'VertexAI',\n    label: 'Codey for Code Generation',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'code-gecko': {\n    llm: 'VertexAI',\n    label: 'Codey for Code Completion',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'text-unicorn': {\n    llm: 'VertexAI',\n    label: 'PaLM 2 Text Unicorn',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'textembedding-gecko': {\n    llm: 'VertexAI',\n    label: 'Embeddings for Text',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  't5-flan': {\n    llm: 'VertexAI',\n    label: 'T5-FLAN',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  't5-1.1': {\n    llm: 'VertexAI',\n    label: 'T5-1.1',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'blip2-opt-2.7-b': {\n    llm: 'VertexAI',\n    label: 'BLIP2',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'instruct-pix2pix': {\n    llm: 'VertexAI',\n    label: 'InstructPix2Pix',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'bert-base': {\n    llm: 'VertexAI',\n    label: 'BERT',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'mediapipe-mobile-bert-classifier': {\n    llm: 'VertexAI',\n    label: 'MobileBERT Classifier (MediaPipe)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'mediapipe-average-word-embedding-classifier': {\n    llm: 'VertexAI',\n    label: 'Average Word Embedding Classifier (MediaPipe)',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  pic2word: {\n    llm: 'VertexAI',\n    label: 'Pic2Word Composed Image Retrieval',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'text-translation': {\n    llm: 'VertexAI',\n    label: 'Text Translation',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'language-v1-moderate-text': {\n    llm: 'VertexAI',\n    label: 'Text Moderation',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'language-v1-analyze-syntax': {\n    llm: 'VertexAI',\n    label: 'Syntax analysis',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'language-v1-analyze-entity-sentiment': {\n    llm: 'VertexAI',\n    label: 'Entity sentiment analysis',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'language-v1-analyze-sentiment': {\n    llm: 'VertexAI',\n    label: 'Sentiment analysis',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'language-v1-classify-text-v1': {\n    llm: 'VertexAI',\n    label: 'Content classification',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n  'pt-test': {\n    llm: 'VertexAI',\n    label: 'Entity analysis',\n    supportsSystemPrompt: false,\n    tokens: 4096, // Guessed value, no reference\n    completionTokens: 4096, // Guessed value, no reference\n    components: ['PromptGenerator'],\n  },\n};\n","import { ConnectorService } from '@sre/index';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { customModels } from './custom-models';\n\nexport class CustomLLMRegistry {\n    private models: Record<string, any> = {}; // TODO [Forhad]: apply proper typing\n\n    public static async getInstance(teamId: string) {\n        if (!teamId) throw new Error('Please provide a valid team ID.');\n\n        const registry = new CustomLLMRegistry();\n\n        await registry.loadCustomModels(teamId);\n\n        return registry;\n    }\n\n    public getProvider(model: string): string {\n        const modelId = this.getModelId(model);\n        return this.models?.[modelId]?.llm;\n    }\n\n    public getModelInfo(model: string): Record<string, any> {\n        const modelId = this.getModelId(model);\n        const modelInfo = this.models?.[modelId] || {};\n\n        return modelInfo;\n    }\n\n    public getMaxContextTokens(model: string): number {\n        const modelInfo = this.getModelInfo(model);\n        return modelInfo?.tokens;\n    }\n\n    public async getMaxCompletionTokens(model: string) {\n        const modelInfo = this.getModelInfo(model);\n\n        return modelInfo?.completionTokens || modelInfo?.tokens;\n    }\n\n    public adjustMaxCompletionTokens(model: string, maxTokens: number): number {\n        const modelInfo = this.getModelInfo(model);\n        return Math.min(maxTokens, modelInfo?.completionTokens || modelInfo?.tokens);\n    }\n\n    private async loadCustomModels(teamId?: string) {\n        const savedCustomModels = await this.getCustomModels(teamId);\n\n        this.models = { ...this.models, ...savedCustomModels };\n    }\n\n    public getModelId(model: string): string {\n        for (const [id, modelInfo] of Object.entries(this.models)) {\n            if (modelInfo.name === model) return id;\n        }\n\n        return model;\n    }\n\n    private async getCustomModels(teamId: string): Promise<Record<string, any>> {\n        const models = {};\n        const settingsKey = 'custom-llm';\n\n        try {\n            const accountConnector = ConnectorService.getAccountConnector();\n\n            const teamSettings = await accountConnector.user(AccessCandidate.team(teamId)).getTeamSetting(settingsKey);\n            const savedCustomModelsData = JSON.parse(teamSettings || '{}') as Record<string, any>;\n\n            for (const [entryId, entry] of Object.entries(savedCustomModelsData)) {\n                const foundationModel = entry.settings.foundationModel;\n                const supportsSystemPrompt = customModels[foundationModel]?.supportsSystemPrompt || entry.settings.supportsSystemPrompt;\n                const customModelData = customModels[foundationModel] || {};\n\n                models[entryId] = {\n                    id: entryId,\n                    name: entry.name,\n                    alias: foundationModel,\n                    llm: entry.provider,\n                    enabled: true,\n                    tags: entry.tags,\n\n                    components: customModelData?.components ?? [],\n                    tokens: customModelData?.tokens ?? 100000,\n                    completionTokens: customModelData?.completionTokens ?? 4096,\n\n                    supportsSystemPrompt,\n                    provider: entry.provider,\n                    features: entry.features,\n                    settings: entry.settings,\n                };\n            }\n\n            return models;\n        } catch (error) {\n            return {};\n        }\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { LLMChatResponse, LLMConnector } from './LLM.service/LLMConnector';\nimport { EventEmitter } from 'events';\nimport { GenerateImageConfig, TLLMMessageBlock, TLLMMessageRole } from '@sre/types/LLM.types';\nimport { LLMRegistry } from './LLMRegistry.class';\nimport { CustomLLMRegistry } from './CustomLLMRegistry.class';\n\nexport class LLMInference {\n    private model: string;\n    private llmConnector: LLMConnector;\n\n    public static async getInstance(model: string, teamId?: string) {\n        const llmInference = new LLMInference();\n\n        const isStandardLLM = LLMRegistry.isStandardLLM(model);\n\n        if (isStandardLLM) {\n            const llmProvider = LLMRegistry.getProvider(model);\n\n            llmInference.llmConnector = ConnectorService.getLLMConnector(llmProvider);\n        } else {\n            const customLLMRegistry = await CustomLLMRegistry.getInstance(teamId);\n            const llmProvider = customLLMRegistry.getProvider(model);\n\n            llmInference.llmConnector = ConnectorService.getLLMConnector(llmProvider);\n        }\n\n        llmInference.model = model;\n\n        return llmInference;\n    }\n\n    public get connector(): LLMConnector {\n        return this.llmConnector;\n    }\n\n    public async promptRequest(prompt, config: any = {}, agent: string | Agent, customParams: any = {}) {\n        const messages = customParams?.messages || [];\n\n        if (prompt) {\n            const _prompt = this.llmConnector.enhancePrompt(prompt, config);\n            messages.push({ role: TLLMMessageRole.User, content: _prompt });\n        }\n\n        if (!messages?.length) {\n            throw new Error('Input prompt is required!');\n        }\n\n        // override params with customParams\n        let params: any = Object.assign(config.data, { ...customParams, messages });\n\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        params = this.prepareParams(params) || {};\n\n        if (!this.llmConnector) {\n            throw new Error(`Model ${params.model} not supported`);\n        }\n\n        try {\n            let response: LLMChatResponse = await this.llmConnector.user(AccessCandidate.agent(agentId)).chatRequest(params);\n\n            const result = this.llmConnector.postProcess(response?.content);\n            if (result.error) {\n                // If the model stopped before completing the response, this is usually due to output token limit reached.\n                if (response.finishReason !== 'stop') {\n                    throw new Error('The model stopped before completing the response, this is usually due to output token limit reached.');\n                }\n\n                // If the model stopped due to other reasons, throw the error\n                throw new Error(result.error);\n            }\n            return result;\n        } catch (error: any) {\n            console.error('Error in chatRequest: ', error);\n\n            throw error;\n        }\n    }\n\n    public async visionRequest(prompt, fileSources: string[], config: any = {}, agent: string | Agent) {\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        const params: any = this.prepareParams(config) || {};\n\n        const promises = [];\n        const _fileSources = [];\n\n        for (let image of fileSources) {\n            const binaryInput = BinaryInput.from(image);\n            _fileSources.push(binaryInput);\n            promises.push(binaryInput.upload(AccessCandidate.agent(agentId)));\n        }\n\n        await Promise.all(promises);\n\n        params.fileSources = _fileSources;\n\n        try {\n            prompt = this.llmConnector.enhancePrompt(prompt, config);\n            let response: LLMChatResponse = await this.llmConnector.user(AccessCandidate.agent(agentId)).visionRequest(prompt, params);\n\n            const result = this.llmConnector.postProcess(response?.content);\n\n            if (result.error) {\n                if (response.finishReason !== 'stop') {\n                    throw new Error('The model stopped before completing the response, this is usually due to output token limit reached.');\n                }\n\n                // If the model stopped due to other reasons, throw the error\n                throw new Error(result.error);\n            }\n\n            return result;\n        } catch (error: any) {\n            console.error('Error in visionRequest: ', error);\n\n            throw error;\n        }\n    }\n\n    // multimodalRequest is the same as visionRequest. visionRequest will be deprecated in the future.\n    public async multimodalRequest(prompt, fileSources: string[], config: any = {}, agent: string | Agent) {\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        const params: any = this.prepareParams(config) || {}; // TODO [Forhad]: apply proper typing\n\n        const promises = [];\n        const _fileSources = [];\n\n        for (let image of fileSources) {\n            const binaryInput = BinaryInput.from(image);\n            _fileSources.push(binaryInput);\n            promises.push(binaryInput.upload(AccessCandidate.agent(agentId)));\n        }\n\n        await Promise.all(promises);\n\n        params.fileSources = _fileSources;\n\n        try {\n            prompt = this.llmConnector.enhancePrompt(prompt, config);\n            let response: LLMChatResponse = await this.llmConnector.user(AccessCandidate.agent(agentId)).multimodalRequest(prompt, params);\n\n            const result = this.llmConnector.postProcess(response?.content);\n\n            if (result.error) {\n                if (response.finishReason !== 'stop') {\n                    throw new Error('The model stopped before completing the response, this is usually due to output token limit reached.');\n                }\n\n                // If the model stopped due to other reasons, throw the error\n                throw new Error(result.error);\n            }\n\n            return result;\n        } catch (error: any) {\n            console.error('Error in multimodalRequest: ', error);\n\n            throw error;\n        }\n    }\n\n    public async imageGenRequest(prompt: string, params: GenerateImageConfig, agent: string | Agent) {\n        const agentId = agent instanceof Agent ? agent.id : agent;\n\n        return this.llmConnector.user(AccessCandidate.agent(agentId)).imageGenRequest(prompt, params);\n    }\n\n    public async toolRequest(params: any, agent: string | Agent) {\n        if (!params.messages || !params.messages?.length) {\n            throw new Error('Input messages are required.');\n        }\n\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params object\n\n        if (!_params.model) {\n            _params.model = this.model;\n        }\n\n        try {\n            const agentId = agent instanceof Agent ? agent.id : agent;\n            return this.llmConnector.user(AccessCandidate.agent(agentId)).toolRequest(_params);\n        } catch (error: any) {\n            console.error('Error in toolRequest: ', error);\n\n            throw error;\n        }\n    }\n\n    public async streamToolRequest(params: any, agent: string | Agent) {\n        const agentId = agent instanceof Agent ? agent.id : agent;\n\n        return this.llmConnector.user(AccessCandidate.agent(agentId)).streamToolRequest(params);\n    }\n\n    public async streamRequest(params: any, agent: string | Agent) {\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        try {\n            if (!params.messages || !params.messages?.length) {\n                throw new Error('Input messages are required.');\n            }\n\n            const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params object\n\n            if (!_params.model) {\n                _params.model = this.model;\n            }\n\n            return await this.llmConnector.user(AccessCandidate.agent(agentId)).streamRequest(_params);\n        } catch (error) {\n            console.error('Error in streamRequest:', error);\n\n            const dummyEmitter = new EventEmitter();\n            process.nextTick(() => {\n                dummyEmitter.emit('error', error);\n                dummyEmitter.emit('end');\n            });\n            return dummyEmitter;\n        }\n    }\n\n    public getConsistentMessages(messages: TLLMMessageBlock[]) {\n        if (!messages?.length) {\n            throw new Error('Input messages are required.');\n        }\n\n        try {\n            return this.llmConnector.getConsistentMessages(messages);\n        } catch (error) {\n            console.error('Error in getConsistentMessages: ', error);\n\n            return messages; // if something goes wrong then we return the original messages\n        }\n    }\n\n    private prepareParams(params: any) {\n        const clonedConfigData = JSON.parse(JSON.stringify(params || {})); // We need to keep the params unchanged to avoid any side effects, especially when run components with loop\n\n        const preparedParams: {\n            model?: string;\n        } = {};\n\n        for (const [key, value] of Object.entries(clonedConfigData)) {\n            let _value: any = value; // TODO [Forhad]: apply proper typing\n\n            // When we have stopSequences, we need to split it into an array\n            if (key === 'stopSequences') {\n                _value = _value ? _value?.split(',') : null;\n            }\n\n            // When we have a string that is a number, we need to convert it to a number\n            if (typeof _value === 'string' && !isNaN(Number(_value))) {\n                _value = +_value;\n            }\n\n            if (key === 'messages') {\n                _value = this.getConsistentMessages(_value);\n            }\n\n            preparedParams[key] = _value;\n        }\n\n        if (!preparedParams?.model) {\n            preparedParams.model = this.model;\n        }\n\n        return preparedParams;\n    }\n}\n","import Joi from 'joi';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { LLMInference } from '@sre/LLMManager/LLM.inference';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\n\nimport Component from './Component.class';\n\n//TODO : better handling of context window exceeding max length\n\nexport default class PromptGenerator extends Component {\n    protected configSchema = Joi.object({\n        model: Joi.string().max(200).required(),\n        prompt: Joi.string().required().max(4000000).label('Prompt'), // 1M tokens is around 4M characters\n        temperature: Joi.number().min(0).max(5).label('Temperature'), // max temperature is 2 for OpenAI and togetherAI but 5 for cohere\n        maxTokens: Joi.number().min(1).label('Maximum Tokens'),\n        stopSequences: Joi.string().allow('').max(400).label('Stop Sequences'),\n        topP: Joi.number().min(0).max(1).label('Top P'),\n        topK: Joi.number().min(0).max(500).label('Top K'), // max top_k is 100 for togetherAI but 500 for cohere\n        frequencyPenalty: Joi.number().min(0).max(2).label('Frequency Penalty'),\n        presencePenalty: Joi.number().min(0).max(2).label('Presence Penalty'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        //let debugLog = agent.agentRuntime?.debug ? [] : undefined;\n        const logger = this.createComponentLogger(agent, config.name);\n\n        try {\n            logger.debug(`=== LLM Prompt Log ===`);\n            let teamId = agent?.teamId;\n\n            const model: string = config.data.model || 'echo';\n            const llmInference: LLMInference = await LLMInference.getInstance(model, teamId);\n\n            // if the llm is undefined, then it means we removed the model from our system\n            if (!llmInference.connector) {\n                return {\n                    _error: `The model '${model}' is not available. Please try a different one.`,\n                    _debug: logger.output,\n                };\n            }\n\n            logger.debug(` Model : ${model}`);\n\n            let prompt: any = TemplateString(config.data.prompt).parse(input).result;\n\n            // with 'Echo' model we may have object as input\n            if (prompt === '[object Object]') {\n                prompt = TemplateString(config.data.prompt).parseRaw(input).result;\n            }\n\n            logger.debug(` Parsed prompt\\n`, prompt, '\\n');\n\n            // default to json response format\n            config.data.responseFormat = config.data?.responseFormat || 'json';\n\n            // request to LLM\n            const response: any = await llmInference.promptRequest(prompt, config, agent).catch((error) => ({ error: error }));\n\n            logger.debug(` Enhanced prompt \\n`, prompt, '\\n');\n            // in case we have the response but it's empty string, undefined or null\n            if (!response) {\n                return { _error: ' LLM Error = Empty Response!', _debug: logger.output };\n            }\n\n            if (response?.error) {\n                logger.error(` LLM Error=${JSON.stringify(response.error)}`);\n\n                return { Reply: response?.data, _error: response?.error + ' ' + (response?.details || ''), _debug: logger.output };\n            }\n\n            const result = { Reply: response };\n\n            result['_debug'] = logger.output;\n\n            return result;\n        } catch (error) {\n            return { _error: error.message, _debug: logger.output };\n        }\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { REQUEST_CONTENT_TYPES } from '@sre/constants';\nimport { JSONContent } from '@sre/helpers/JsonContent.helper';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport FormData from 'form-data';\nimport { Readable } from 'stream';\n\nexport async function parseData(input: any, config, agent: Agent): Promise<{ data: any; headers: any }> {\n    const teamId = agent ? agent.teamId : null;\n    const templateSettings = config?.template?.settings || {};\n    const contentType = config?.data?.contentType || REQUEST_CONTENT_TYPES.none;\n\n    let body = typeof config?.data?.body === 'string' ? config?.data?.body?.trim() : config?.data?.body;\n    if (!body) {\n        return { data: null, headers: {} };\n    }\n\n    // Parse component template variables\n    if (config.data._templateVars && templateSettings) {\n        //prettier-ignore\n        body = await TemplateString(body) \n            .parseComponentTemplateVarsAsync(templateSettings) // replace component template vars with their IDs (this turns the string parses into an async parser)            \n            .asyncResult; //returns parser promise\n    }\n\n    // Parse vault keys\n    body = await TemplateString(body).parseTeamKeysAsync(teamId).asyncResult;\n\n    // Handle different content types\n    const handlers: Record<string, (parsedBody: any, input: any, config, agent: Agent) => any> = {\n        [REQUEST_CONTENT_TYPES.json]: handleJson,\n        [REQUEST_CONTENT_TYPES.urlEncodedFormData]: handleUrlEncoded,\n        [REQUEST_CONTENT_TYPES.multipartFormData]: handleMultipartFormData,\n        [REQUEST_CONTENT_TYPES.binary]: handleBinary,\n        [REQUEST_CONTENT_TYPES.text]: handleText,\n        [REQUEST_CONTENT_TYPES.none]: handleNone,\n    };\n\n    const handler = handlers[contentType] || handleNone;\n    const { data = null, headers = {} } = await handler(body, input, config, agent);\n\n    //const jsonBody: any = JSONContent(data).tryParse();\n    return { data, headers };\n}\n\nasync function handleJson(body: any, input: any, config, agent: Agent) {\n    // Parse template and input variables\n    //prettier-ignore\n    const data = TemplateString(body)\n        .parse(config.data._templateVars) //parse Template variables first (if any)\n        .parse(input) //parse inputs\n        .clean().result; //clean up the remaining unparsed values\n\n    const jsonBody: any = JSONContent(data).tryParse();\n    return { data: jsonBody };\n}\n\nasync function handleUrlEncoded(body: any, input: any, config, agent: Agent) {\n    if (typeof body === 'object') {\n        const params = new URLSearchParams();\n        for (const key in body) {\n            params.append(key, String(body[key]));\n        }\n        return params.toString();\n    }\n    return { data: body };\n}\n\nasync function handleMultipartFormData(body: any, input: any, config, agent: Agent) {\n    const formData = new FormData();\n\n    const _body = typeof body === 'string' ? JSON.parse(body) : body;\n\n    for (const key in _body) {\n        let value = _body[key];\n        value = typeof value === 'boolean' ? String(value) : value;\n\n        value = TemplateString(value).parseRaw(input).result;\n\n        if (value && typeof value === 'object' && value?.url) {\n            const binaryInput = await BinaryInput.from(value.url, '', value?.mimetype);\n            const buffer = await binaryInput.getBuffer();\n\n            const bufferStream = new Readable();\n            bufferStream.push(buffer || null);\n            bufferStream.push(null);\n\n            const filename = (await binaryInput.getName()) || key;\n\n            formData.append(key, bufferStream, { filename });\n        } else if (value instanceof BinaryInput) {\n            const buffer = await value.getBuffer();\n            const bufferStream = new Readable();\n            bufferStream.push(buffer || null);\n            bufferStream.push(null);\n\n            const filename = (await value.getName()) || key;\n            formData.append(key, bufferStream, { filename });\n        } else {\n            value = TemplateString(value)\n                .parse(config.data._templateVars) //parse Template variables first (if any)\n                .parse(input)\n                .clean().result;\n\n            formData.append(key, value);\n\n            //formData.append(key, typeof value === 'boolean' ? String(value) : value);\n        }\n    }\n    return { data: formData, headers: formData.getHeaders() };\n}\n\nasync function handleBinary(body: any, input: any, config, agent: Agent) {\n    const value: any = TemplateString(body).parseRaw(input).result;\n\n    if (value && typeof value === 'object' && value?.url) {\n        const binaryInput = await BinaryInput.from(value.url, '', value?.mimetype);\n        const buffer = await binaryInput.getBuffer();\n\n        return { data: buffer, headers: { 'Content-Type': binaryInput.mimetype } };\n    } else if (value && value instanceof BinaryInput) {\n        const buffer = await value.getBuffer();\n        return { data: buffer, headers: { 'Content-Type': value.mimetype } };\n    }\n\n    return { data: Buffer.from([]), headers: {} };\n}\n\nasync function handleNone(body: any, input: any, config, agent: Agent) {\n    //FIXME: try to guess the content type from headers content-type and data\n\n    return { data: typeof body === 'string' ? body : JSON.stringify(body), headers: {} };\n}\nfunction handleText(body: any, input: any, config: any, agent: Agent) {\n    // Parse template and input variables\n    //prettier-ignore\n    const data = TemplateString(body)\n        .parse(config.data._templateVars) //parse Template variables first (if any)\n        .parse(input) //parse inputs\n        .clean().result; //clean up the remaining unparsed values\n\n    return { data };\n}\n","const mimeTypeCategories = {\n    binary: [\n        'image/',\n        'multipart/form-data',\n        'video/',\n        'application/msword',\n        'application/octet-stream',\n        'application/pdf',\n        'application/vnd.ms-excel',\n        'application/vnd.ms-powerpoint',\n        'application/vnd.oasis.opendocument.text',\n        'application/vnd.openxmlformats-officedocument',\n        'application/zip',\n        'application/x-7z-compressed',\n        'application/x-rar-compressed',\n        'application/x-tar',\n        'application/x-bzip',\n        'application/x-bzip2',\n        'application/x-gzip',\n        'application/vnd.android.package-archive',\n        'application/vnd.visio',\n        'application/x-deb',\n        'application/x-rpm',\n        'application/x-executable',\n        'font/ttf',\n        'font/otf',\n        'font/woff',\n        'font/woff2',\n        'model/',\n    ],\n    json: ['application/graphql', 'application/json', 'application/ld+json', 'application/vnd.api+json'],\n    text: [\n        'text/', //all starting with text/\n        'application/xml',\n        'application/xhtml+xml',\n        'application/csv',\n        'application/x-www-form-urlencoded',\n        'application/x-yaml',\n        'application/yaml',\n        'application/javascript',\n        'application/sql',\n        'application/rtf',\n    ],\n};\n\nexport default mimeTypeCategories;\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { isBinaryData, isBinaryMimeType } from '@sre/utils/data.utils';\nimport { AxiosResponse } from 'axios';\nimport mimeTypeCategories from './mimeTypeCategories';\n\nconst contentHandlers = {\n    json: parseJson,\n    text: parseText,\n    binary: parseBinary,\n};\n\nfunction parseJson(data) {\n    return JSON.parse(Buffer.from(data).toString('utf8') || '{}');\n}\n\nfunction parseText(data) {\n    return Buffer.from(data).toString('utf8');\n}\n\nasync function parseBinary(data, contentType, agentId) {\n    const binaryInput = BinaryInput.from(data, null, contentType);\n    const smythFile = await binaryInput.getJsonData(AccessCandidate.agent(agentId));\n\n    return smythFile;\n}\n\nexport async function parseArrayBufferResponse(response: AxiosResponse, agent: Agent): Promise<any> {\n    if (!response?.data) {\n        return null;\n    }\n    const data = response.data;\n    const contentType = response.headers['content-type'];\n    const cleanContentType = contentType.split(';')[0];\n\n    // Try to find an exact match first,\n    let handlerType = Object.keys(mimeTypeCategories).find((type) => mimeTypeCategories[type].includes(cleanContentType));\n\n    // If no exact match, try to find a match for the first part of the handlerTypes, some handlers are generic like text/ in that case we check if the handler is a substring of the contentType\n    if (!handlerType) {\n        handlerType = Object.keys(mimeTypeCategories).find((type) => mimeTypeCategories[type].some((prefix) => cleanContentType.startsWith(prefix)));\n    }\n\n    const handler = contentHandlers[handlerType];\n\n    if (handler) {\n        return handler(data, contentType, agent.id);\n    }\n\n    // Fallback: if no content type matches then check if the data is binary\n    // If so then parse it as binary, otherwise parse it as text\n    if (isBinaryMimeType(contentType) || isBinaryData(data)) {\n        return parseBinary(data, contentType, agent.id);\n    } else {\n        return parseText(data);\n    }\n}\n","// accessTokenManager.ts\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport SystemEvents from '@sre/Core/SystemEvents';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport axios from 'axios';\n\nconst console = Logger('AccessTokenManager');\nlet managedVault: any;\n\nSystemEvents.on('SRE:Booted', () => {\n    managedVault = ConnectorService.getManagedVaultConnector('oauth');\n});\nclass AccessTokenManager {\n    private clientId: string;\n    private clientSecret: string;\n    private primaryToken: string; // accessToken || token\n    private secondaryToken: string; // refreshToken || tokenSecret\n    private tokenUrl: string; // tokenURL to refresh accessToken\n    private expires_in: any;\n    private data: any; // value of key(keyId) in teamSettings that needs to be updated if required\n    private keyId: any; // key of object  in teamSettings\n    private logger: any; // Use to log console in debugger\n    private agent: Agent;\n    constructor(\n        clientId: string,\n        clientSecret: string,\n        secondaryToken: string,\n        tokenUrl: string,\n        expires_in: any,\n        primaryToken: string,\n        data: any,\n        keyId: any,\n        logger: any,\n        agent: Agent\n    ) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.primaryToken = primaryToken;\n        this.secondaryToken = secondaryToken;\n        this.tokenUrl = tokenUrl;\n        this.expires_in = expires_in;\n        this.data = data;\n        this.keyId = keyId;\n        this.logger = logger;\n        this.agent = agent;\n    }\n\n    async getAccessToken(): Promise<string> {\n        try {\n            const currentTime: any = new Date().getTime();\n            // should be alway currentTime >= Number(this.expires_in)\n            if (!this.expires_in || currentTime >= Number(this.expires_in)) {\n                if (!this.secondaryToken) {\n                    this.logger.debug('Refresh token is missing. Please re authenticate');\n                    console.log('Refresh token is missing. Please re authenticate...');\n                    // Redirect the user to the OAuth authorization URL or initiate the reauthentication flow\n                    throw new Error('Reauthentication required');\n                }\n                this.logger.debug('Access token is expired or missing. Refreshing access token...');\n                console.log('Access token is expired or missing. Refreshing access token...');\n                return await this.refreshAccessToken();\n            } else {\n                console.log('Access token is still valid');\n                this.logger.debug('Access token is still valid.');\n                return this.primaryToken;\n            }\n        } catch (error) {\n            console.error('Error fetching access token:', error);\n            this.logger.debug('Error fetching access token');\n            throw error;\n        }\n    }\n\n    async refreshAccessToken(): Promise<string> {\n        try {\n            const response = await axios.post(\n                this.tokenUrl,\n                new URLSearchParams({\n                    client_id: this.clientId,\n                    client_secret: this.clientSecret,\n                    refresh_token: this.secondaryToken,\n                    grant_type: 'refresh_token',\n                }).toString(),\n                {\n                    headers: {\n                        'Content-Type': 'application/x-www-form-urlencoded',\n                    },\n                }\n            );\n\n            const newAccessToken: string = response.data.access_token;\n            console.log('Access token refreshed successfully.');\n            this.logger.debug('Access token refreshed successfully.');\n            const expiresInMilliseconds: number = response.data.expires_in * 1000;\n            const expirationTimestamp: number = new Date().getTime() + expiresInMilliseconds;\n            this.data.primary = newAccessToken;\n            this.data.expires_in = expirationTimestamp?.toString();\n            //const oauthTeamSettings = new OauthTeamSettings();\n            //const save: any = await oauthTeamSettings.update({ keyId: this.keyId, data: this.data });\n\n            const save: any = await managedVault.user(AccessCandidate.agent(this.agent.id)).set(this.keyId, JSON.stringify(this.data));\n            if (save && save.status === 200) {\n                console.log('Access token value is updated successfully.');\n                this.logger.debug('Access token value is updated successfully.');\n            } else {\n                console.log('Warning: new access token value is not updated.');\n                this.logger.debug('Warning: new access token value is not updated.');\n            }\n            return newAccessToken;\n        } catch (error) {\n            console.error('Failed to refresh access token:', error);\n            this.logger.debug(`Failed to refresh access token: ${error}`);\n            throw new Error('Failed to refresh access token.');\n        }\n    }\n}\n\nexport default AccessTokenManager;\n","// helper.ts\nimport crypto from 'crypto';\nimport OAuth from 'oauth-1.0a';\nimport AccessTokenManager from './AccessTokenManager';\nimport { REQUEST_CONTENT_TYPES } from '@sre/constants';\nimport axios, { AxiosRequestConfig } from 'axios';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport SystemEvents from '@sre/Core/SystemEvents';\n\nconst console = Logger('OAuth.helper');\nlet managedVault: any;\n\nSystemEvents.on('SRE:Booted', () => {\n    managedVault = ConnectorService.getManagedVaultConnector('oauth');\n});\n\nexport function extractAdditionalParamsForOAuth1(reqConfig: AxiosRequestConfig = {}) {\n    let additionalParams = {};\n    // Parse URL parameters using URL and URLSearchParams\n    const url = new URL(reqConfig.url);\n    const searchParams = url.searchParams;\n    additionalParams = Object.fromEntries(searchParams.entries());\n\n    // Check content type and add required parameters for OAuth 1 signature\n    const contentType = reqConfig.headers?.['Content-Type'] || '';\n    if (contentType === REQUEST_CONTENT_TYPES.urlEncodedFormData) {\n        // For form data, include the form parameters in the signature\n        if (typeof reqConfig.data === 'string') {\n            const formData = new URLSearchParams(reqConfig.data);\n            additionalParams = { ...additionalParams, ...Object.fromEntries(formData) };\n        }\n    } else if (contentType === REQUEST_CONTENT_TYPES.json) {\n        // For JSON data, include a hash of the request body\n        if (reqConfig.data) {\n            const hash = crypto.createHash('sha1').update(JSON.stringify(reqConfig.data)).digest('base64');\n            additionalParams['oauth_body_hash'] = hash;\n        }\n    } else if (contentType === REQUEST_CONTENT_TYPES.multipartFormData) {\n        const formData = reqConfig.data as FormData;\n        for (const [key, value] of formData.entries()) {\n            // Exclude binary form data (File, Blob, etc.)\n            if (typeof value === 'object' && value !== null && 'size' in value && 'type' in value) {\n                continue;\n            }\n\n            additionalParams[key] = value;\n        }\n    }\n\n    return additionalParams;\n}\n\nexport const buildOAuth1Header = (url, method, oauth1Credentials, additionalParams = {}) => {\n    const oauth = new OAuth({\n        consumer: {\n            key: oauth1Credentials.consumerKey,\n            secret: oauth1Credentials.consumerSecret,\n        },\n        signature_method: 'HMAC-SHA1',\n        hash_function(base_string, key) {\n            return crypto.createHmac('sha1', key).update(base_string).digest('base64');\n        },\n    });\n\n    // Include additional parameters if necessary (e.g., for non-standard providers)\n    const requestData = {\n        url,\n        method,\n        ...additionalParams,\n    };\n    const signedRequest = oauth.authorize(requestData, { key: oauth1Credentials.token, secret: oauth1Credentials.tokenSecret });\n    return oauth.toHeader(signedRequest);\n};\n\nexport const retrieveOAuthTokens = async (agent, config) => {\n    let tokenKey: any = null;\n    try {\n        tokenKey = `OAUTH_${config.componentId ?? config.id}_TOKENS`;\n\n        try {\n            const result: any = await managedVault.user(AccessCandidate.agent(agent.id)).get(tokenKey);\n            const tokensData = typeof result === 'object' ? result : JSON.parse(result);\n\n            if (!tokensData) {\n                throw new Error('Failed to retrieve OAuth tokens from vault. Please authenticate ...');\n            }\n\n            const primaryToken = tokensData.primary; // accessToken or token\n            const secondaryToken = tokensData.secondary; // refreshToken or tokenSecret\n            const type = tokensData.type; // oauth || oauth2\n            // sometimes refreshToken is not avaialbe . e.g in case of linkedIn. so only add check for primary token\n            if (config.data.oauthService !== 'OAuth2 Client Credentials') {\n                if (!primaryToken) {\n                    throw new Error('Retrieved OAuth tokens do not exist, invalid OR incomplete. Please authenticate ...');\n                }\n            }\n\n            const responseData: any = {\n                primaryToken,\n                secondaryToken,\n                type,\n            };\n\n            if (type === 'oauth') {\n                // Check and assign if present\n                if ('consumerKey' in tokensData) responseData.consumerKey = tokensData.consumerKey;\n                if ('consumerSecret' in tokensData) responseData.consumerSecret = tokensData.consumerSecret;\n                responseData.team = tokensData.team;\n            } else if (type === 'oauth2') {\n                // Check and assign if present\n                responseData.tokenURL = tokensData.tokenURL;\n                if ('clientID' in tokensData) responseData.clientID = tokensData.clientID;\n                if ('clientSecret' in tokensData) responseData.clientSecret = tokensData.clientSecret;\n                responseData.expiresIn = tokensData.expires_in ?? 0; // Optional property, default to 0 if not present. time to expire access token\n                responseData.team = tokensData.team;\n            }\n\n            return { responseData, data: tokensData, keyId: tokenKey };\n        } catch (error) {\n            throw new Error(`Failed to parse retrieved tokens: ${error}`);\n        }\n    } catch (error) {\n        console.error('Error retrieving OAuth tokens:', error);\n        throw error; // rethrow for potential handling by the calling code\n    }\n};\n\nexport const handleOAuthHeaders = async (agent, config, reqConfig, logger, additionalParams = {}, rootUrl) => {\n    let headers = {}; // Initialize headers as an empty object\n    const { responseData: oauthTokens, data, keyId } = await retrieveOAuthTokens(agent, config);\n\n    try {\n        // Extract template variable key IDs for consumerKey, consumerSecret, clientID, and clientSecret\n        const keys = ['consumerKey', 'consumerSecret', 'clientID', 'clientSecret'];\n        let oAuthConfigString = JSON.stringify({\n            consumerKey: config.data.consumerKey,\n            consumerSecret: config.data.consumerSecret,\n            clientID: config.data.clientID,\n            clientSecret: config.data.clientSecret,\n            tokenURL: config.data.tokenURL,\n        });\n\n        oAuthConfigString = await TemplateString(oAuthConfigString).parseTeamKeysAsync(oauthTokens.team || agent.teamId).asyncResult;\n\n        const oAuthConfig = JSON.parse(oAuthConfigString);\n\n        if (oAuthConfig.oauthService === 'OAuth2 Client Credentials') {\n            const accessToken = await getClientCredentialToken(data, logger, keyId, oauthTokens, config, agent);\n            headers['Authorization'] = `Bearer ${accessToken}`;\n        } else {\n            if (oauthTokens.type === 'oauth') {\n                // For OAuth1, generate and replace the signature in headers\n                const oauthHeader = buildOAuth1Header(\n                    rootUrl,\n                    reqConfig.method,\n                    {\n                        consumerKey: oAuthConfig.consumerKey,\n                        consumerSecret: oAuthConfig.consumerSecret,\n                        token: oauthTokens.primaryToken,\n                        tokenSecret: oauthTokens.secondaryToken,\n                    },\n                    additionalParams\n                );\n\n                headers = { ...reqConfig.headers, ...oauthHeader };\n                logger.debug('OAuth1 access token check success.');\n            } else if (oauthTokens.type === 'oauth2') {\n                // For OAuth2, add the 'Authorization' header with the bearer token\n                const accessTokenManager = new AccessTokenManager(\n                    oAuthConfig.clientID,\n                    oAuthConfig.clientSecret,\n                    oauthTokens.secondaryToken,\n                    oAuthConfig.tokenURL,\n                    oauthTokens.expiresIn,\n                    oauthTokens.primaryToken,\n                    data,\n                    keyId,\n                    logger,\n                    agent\n                );\n\n                const accessToken = await accessTokenManager.getAccessToken();\n                headers['Authorization'] = `Bearer ${accessToken}`;\n            }\n        }\n        return headers;\n    } catch (error) {\n        logger.error(`Access token check failed: ${error}`);\n        throw error;\n    }\n};\n\nconst getKeyIdsFromTemplateVars = (str: string): string[] => {\n    if (!str) return [];\n\n    const pattern = /{{KEY\\((.*?)\\)}}/g;\n    const keyIds: any = [];\n    let match: any = [];\n\n    while ((match = pattern.exec(str)) !== null) {\n        if (match?.length < 2) continue;\n        keyIds.push(match[1]);\n    }\n\n    return keyIds;\n};\n\nasync function getClientCredentialToken(data, logger, keyId, oauthTokens, config, agent) {\n    const logAndThrowError = (message) => {\n        logger.debug(message);\n        throw new Error(message);\n    };\n\n    try {\n        data = data[keyId] || {};\n        const { clientID, clientSecret, tokenURL } = config.data;\n        const currentTime = new Date().getTime();\n        // Check for token expiration\n        if (!oauthTokens.expiresIn || currentTime >= Number(oauthTokens.expiresIn)) {\n            // Verify required parameters\n            if (!clientID || !clientSecret || !tokenURL) {\n                logAndThrowError('Missing client_id, client_secret OR token_url');\n            }\n\n            const params = new URLSearchParams({\n                grant_type: 'client_credentials',\n                client_id: clientID,\n                client_secret: clientSecret,\n            });\n\n            const response = await axios.post(tokenURL, params.toString(), {\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n            });\n\n            console.log('Access token refreshed successfully.');\n            logger.debug('Access token refreshed successfully.');\n\n            const newAccessToken = response.data.access_token;\n            const expiresInMilliseconds = response.data.expires_in * 1000;\n            const expirationTimestamp = currentTime + expiresInMilliseconds;\n\n            // Set data if it's empty\n            if (Object.keys(data).length === 0) {\n                data = {\n                    primary: '',\n                    secondary: '',\n                    type: 'oauth2',\n                    tokenURL,\n                    expires_in: '',\n                    team: agent.teamId,\n                    oauth_info: {\n                        oauth_keys_prefix: `OAUTH_${config.componentId ?? config.id}`,\n                        service: 'oauth2_client_credentials',\n                        tokenURL,\n                        clientID,\n                        clientSecret,\n                    },\n                };\n            }\n\n            data.primary = newAccessToken;\n            data.expires_in = expirationTimestamp.toString();\n            //const oauthTeamSettings = new OauthTeamSettings();\n            //const save = await oauthTeamSettings.update({ keyId: keyId, data: data });\n            await managedVault.user(AccessCandidate.agent(agent.id)).set(keyId, data);\n\n            return newAccessToken;\n        } else {\n            console.log('Access token value is still valid.');\n            logger.debug('Access token value is still valid.');\n            return oauthTokens.primaryToken;\n        }\n    } catch (error) {\n        logAndThrowError(`Failed to refresh access token: ${error}`);\n    }\n}\n","import axios, { AxiosRequestConfig } from 'axios';\nimport Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from '../Component.class';\nimport { REQUEST_CONTENT_TYPES } from '@sre/constants';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { parseHeaders } from './parseHeaders';\nimport { parseUrl } from './parseUrl';\nimport { parseData } from './parseData';\nimport { parseProxy } from './parseProxy';\nimport { parseArrayBufferResponse } from './ArrayBufferResponse.helper';\nimport { extractAdditionalParamsForOAuth1, handleOAuthHeaders as generateOAuthHeaders } from './OAuth.helper';\n\nexport default class APICall extends Component {\n    protected configSchema = Joi.object({\n        method: Joi.string().valid('GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS').required().label('Method'),\n        url: Joi.string()\n            .max(8192) /*.custom(isUrlValid, 'URL validation')*/\n            .required()\n            .label('URL'),\n        headers: Joi.string().allow('').label('Headers'),\n        contentType: Joi.string()\n            .valid('none', 'application/json', 'multipart/form-data', 'binary', 'application/x-www-form-urlencoded', 'text/plain', 'application/xml')\n            .label('Content-Type'),\n        body: Joi.string().allow('').label('Body'),\n        _templateSettings: Joi.object().allow(null).label('Template Settings'),\n        _templateVars: Joi.object().allow(null).label('Template Variables'),\n        proxy: Joi.string().allow('').label('Proxy'),\n        oauthService: Joi.string().allow('').label('OAuth Service'),\n        scope: Joi.string().allow('').label('Scope'),\n        authorizationURL: Joi.string().allow('').label('Authorization URL'),\n        tokenURL: Joi.string().allow('').label('Token URL'),\n        clientID: Joi.string().allow('').label('Client ID'),\n        clientSecret: Joi.string().allow('').label('Client Secret'),\n        oauth2CallbackURL: Joi.string().allow('').label('OAuth2 Callback URL'),\n        callbackURL: Joi.string().allow('').label('Callback URL'), // !TEMP: prevent validation error\n        requestTokenURL: Joi.string().allow('').label('Request Token URL'),\n        accessTokenURL: Joi.string().allow('').label('Access Token URL'),\n        userAuthorizationURL: Joi.string().allow('').label('User Authorization URL'),\n        consumerKey: Joi.string().allow('').label('Consumer Key'),\n        consumerSecret: Joi.string().allow('').label('Consumer Secret'),\n        oauth1CallbackURL: Joi.string().allow('').label('OAuth1 Callback URL'),\n        authenticate: Joi.string().allow('').label('Authenticate'),\n    });\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n\n        try {\n            logger.debug(`=== API Call Log ===`);\n\n            const method = config?.data?.method || 'get';\n\n            const reqConfig: AxiosRequestConfig = {};\n            reqConfig.method = method;\n\n            reqConfig.url = await parseUrl(input, config, agent);\n\n            const { data, headers } = await parseData(input, config, agent);\n\n            reqConfig.data = data;\n\n            reqConfig.headers = (await parseHeaders(input, config, agent)).concat({ ...headers });\n\n            reqConfig.proxy = await parseProxy(input, config, agent);\n\n            let Response: any = {};\n            let Headers: any = {};\n            let _error: any = undefined;\n            try {\n                if (config?.data?.oauthService !== '' && config?.data?.oauthService !== 'None') {\n                    const rootUrl = new URL(reqConfig.url).origin;\n                    const additionalParams = extractAdditionalParamsForOAuth1(reqConfig);\n                    const oauthHeaders = await generateOAuthHeaders(agent, config, reqConfig, logger, additionalParams, rootUrl);\n                    //reqConfig.headers = { ...reqConfig.headers, ...oauthHeaders };\n                    reqConfig.headers = reqConfig.headers.concat({ ...oauthHeaders });\n                }\n\n                logger.debug('Making API call', reqConfig);\n                // in order to handle binary data automatically, we need to set responseType to 'arraybuffer' for all requests, then parse the response data based on content-type\n                reqConfig.responseType = 'arraybuffer';\n\n                const response = await axios.request(reqConfig);\n\n                Response = await parseArrayBufferResponse(response, agent);\n                Headers = Object.fromEntries(Object.entries(response.headers));\n            } catch (error) {\n                logger.debug(`Error making API call: ${error.message}`);\n                Headers = error?.response?.headers ? Object.fromEntries(Object.entries(error.response.headers)) : {};\n                Response = await parseArrayBufferResponse(error.response, agent);\n                _error = error.message;\n            }\n\n            return { Response, Headers, _error, _debug: logger.output };\n        } catch (error) {\n            return { _error: error.message, _debug: logger.output };\n        }\n    }\n}\n","import Joi from 'joi';\n\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport Component from './Component.class';\nimport { LLMInference } from '@sre/LLMManager/LLM.inference';\nexport default class VisionLLM extends Component {\n    protected configSchema = Joi.object({\n        prompt: Joi.string().required().max(4000000).label('Prompt'), // 1M tokens is around 4M characters\n        maxTokens: Joi.number().min(1).label('Maximum Tokens'),\n        model: Joi.string().max(200).required(),\n    });\n\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            logger.debug(`=== Vision LLM Log ===`);\n            const model: string = config.data.model || 'gpt-4o-mini';\n            const llmInference: LLMInference = await LLMInference.getInstance(model);\n            // if the llm is undefined, then it means we removed the model from our system\n            if (!llmInference.connector) {\n                return {\n                    _error: `The model '${model}' is not available. Please try a different one.`,\n                    _debug: logger.output,\n                };\n            }\n            let prompt: any = TemplateString(config.data.prompt).parse(input).result;\n\n            logger.debug(` Parsed prompt\\n`, prompt, '\\n');\n\n            const fileSources = Array.isArray(input.Images) ? input.Images : [input.Images];\n\n            const response = await llmInference.visionRequest(prompt, fileSources, config, agent);\n            logger.debug(` Enhanced prompt \\n`, prompt, '\\n');\n            // in case we have the response but it's empty string, undefined or null\n            if (!response) {\n                return { _error: ' LLM Error = Empty Response!', _debug: logger.output };\n            }\n\n            if (response?.error) {\n                logger.error(` LLM Error=${JSON.stringify(response.error)}`);\n\n                return { Reply: response?.data, _error: response?.error + ' ' + response?.details, _debug: logger.output };\n            }\n\n            const result = { Reply: response };\n\n            result['_debug'] = logger.output;\n\n            return result;\n        } catch (error: any) {\n            return { _error: error.message, _debug: logger.output };\n        }\n    }\n}\n","import { SREConfig, TConnectorService } from '@sre/types/SRE.types';\nimport { ConnectorService } from './ConnectorsService';\nimport SystemEvents from './SystemEvents';\nimport { Logger } from '../helpers/Log.helper';\n\nconst logger = Logger('SRE');\nconst CInstance = ConnectorService;\n\nexport default class SmythRuntime {\n    public started = false;\n\n    protected constructor() {\n        this.started = true;\n    }\n\n    protected static instance?: SmythRuntime;\n    public static get Instance(): SmythRuntime {\n        if (!SmythRuntime.instance) {\n            SmythRuntime.instance = new SmythRuntime();\n        }\n        return SmythRuntime.instance;\n    }\n\n    private initialized = false;\n    public init(_config: SREConfig): SmythRuntime {\n        if (this.initialized) {\n            throw new Error('SRE already initialized');\n        }\n        this.initialized = true;\n\n        const config = this.autoConf(_config);\n\n        for (let connectorType in config) {\n            for (let configEntry of config[connectorType]) {\n                CInstance.init(connectorType as TConnectorService, configEntry.Connector, configEntry.Id, configEntry.Settings, configEntry.Default);\n            }\n        }\n\n        SystemEvents.emit('SRE:Initialized');\n\n        return SmythRuntime.Instance as SmythRuntime;\n    }\n\n    /**\n     * This function tries to auto configure, or fixes the provided configuration\n     *\n     * FIXME: The current version does not actually auto configure SRE, it just fixes the provided configuration for now\n     * TODO: Implement auto configuration based on present environment variables and auto-detected configs\n     * @param config\n     */\n    private autoConf(config: SREConfig) {\n        const newConfig: SREConfig = {};\n        for (let connectorType in config) {\n            newConfig[connectorType] = [];\n            if (typeof config[connectorType] === 'object') config[connectorType] = [config[connectorType]];\n\n            let hasDefault = false;\n            for (let connector of config[connectorType]) {\n                if (!connector.Connector) {\n                    console.warn(`Missing Connector Name in ${connectorType} entry ... it will be ignored`);\n                    continue;\n                }\n                if (connector.Default) {\n                    if (hasDefault) {\n                        console.warn(`Entry ${connectorType} has more than one default Connector ... only the first one will be used`);\n                    }\n                    hasDefault = true;\n                }\n                newConfig[connectorType].push(connector);\n            }\n\n            if (!hasDefault && newConfig[connectorType].length > 0) {\n                newConfig[connectorType][0].Default = true;\n            }\n        }\n\n        return newConfig;\n    }\n\n    public ready(): boolean {\n        return this.initialized;\n    }\n\n    public async _stop() {\n        logger.info('Shutting Down SmythRuntime ...');\n        CInstance._stop();\n        SmythRuntime.instance = undefined;\n        this.started = false;\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { ACLAccessDeniedError, IAccessCandidate, TAccessLevel, TAccessResult, TAccessTicket } from '@sre/types/ACL.types';\nimport { ACL } from './AccessControl/ACL.class';\nimport { AccessCandidate } from './AccessControl/AccessCandidate.class';\nimport { AccessRequest } from './AccessControl/AccessRequest.class';\n\nconst console = Logger('SecureConnector');\n\nexport abstract class SecureConnector extends Connector {\n    public abstract name: string;\n\n    //this determines the access rights for the requested resource\n    //the connector should check if the resource exists or not\n    //if the resource exists we read its ACL and return it\n    //if the resource does not exist we return an write access ACL for the candidate\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n\n    public async start() {\n        console.info(`Starting ${this.name} connector ...`);\n    }\n\n    public async stop() {\n        console.info(`Stopping ${this.name} connector ...`);\n    }\n\n    protected async hasAccess(acRequest: AccessRequest) {\n        const aclHelper = await this.getResourceACL(acRequest.resourceId, acRequest.candidate);\n\n        //const aclHelper = ACLHelper.from(acl);\n\n        const exactAccess = aclHelper.checkExactAccess(acRequest);\n        if (exactAccess) return true;\n\n        // if the exact access is denied, we check if the candidate has a higher access\n        const ownerRequest = AccessRequest.clone(acRequest).setLevel(TAccessLevel.Owner);\n        const ownerAccess = aclHelper.checkExactAccess(ownerRequest);\n        if (ownerAccess) return true;\n\n        // if the exact access is denied, we check if the requested resource has a public access\n        const publicRequest = AccessRequest.clone(acRequest).setCandidate(AccessCandidate.public());\n        const publicAccess = aclHelper.checkExactAccess(publicRequest);\n        if (publicAccess) return true;\n\n        // if the public access is denied, we check if the candidate's team has access\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n        const teamRequest = AccessRequest.clone(acRequest).setCandidate(AccessCandidate.team(teamId));\n        const teamAccess = aclHelper.checkExactAccess(teamRequest);\n        if (teamAccess) return true;\n\n        // if the team access is denied, we check if the team has a higher access\n        const teamOwnerRequest = AccessRequest.clone(teamRequest).setLevel(TAccessLevel.Owner);\n        const teamOwnerAccess = aclHelper.checkExactAccess(teamOwnerRequest);\n        if (teamOwnerAccess) return true;\n\n        return false;\n    }\n    public async getAccessTicket(resourceId: string, request: AccessRequest): Promise<TAccessTicket> {\n        const sysAcRequest = AccessRequest.clone(request).resource(resourceId);\n        const accessTicket = {\n            request,\n            access: (await this.hasAccess(sysAcRequest)) ? TAccessResult.Granted : TAccessResult.Denied,\n        };\n\n        return accessTicket as TAccessTicket;\n    }\n\n    //#region [ Decorators ]==========================\n\n    //AccessControl decorator\n    //This decorator will inject the access control logic into storage connector methods\n    // in order to work properly, the connector expects the resourceId to be the first argument and the access request to be the second argument\n\n    static AccessControl(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        // Store the original method in a variable\n        const originalMethod = descriptor.value;\n\n        // Modify the descriptor's value to wrap the original method\n        descriptor.value = async function (...args: any[]) {\n            // Extract the method arguments\n            const [acRequest, resourceId] = args;\n\n            // Inject the access control logic\n            const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n            if (accessTicket.access !== TAccessResult.Granted) {\n                console.error(`Access denied for ${acRequest.candidate.id} on ${resourceId}`);\n                throw new ACLAccessDeniedError('Access Denied');\n            }\n\n            // Call the original method with the original arguments\n            return originalMethod.apply(this, args);\n        };\n\n        // Return the modified descriptor\n        return descriptor;\n    }\n\n    //#endregion\n}\n","import { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL } from '@sre/types/ACL.types';\nimport {\n    DatasourceDto,\n    IStorageVectorDataSource,\n    IStorageVectorNamespace,\n    IVectorDataSourceDto,\n    QueryOptions,\n    Source,\n    StorageVectorNamespaceMetadata,\n    VectorDBMetadata,\n    VectorsResultData,\n} from '@sre/types/VectorDB.types';\nimport { Document } from '@langchain/core/documents';\n\nexport interface IVectorDBRequest {\n    search(namespace: string, query: string | number[], options?: QueryOptions): Promise<VectorsResultData>;\n    // insert(namespace: string, source: IVectorDataSourceDto | IVectorDataSourceDto[]): Promise<string[]>;\n    // delete(namespace: string, id: string | string[]): Promise<void>;\n\n    createDatasource(namespace: string, datasource: DatasourceDto): Promise<{ id: string; vectorIds: string[] }>;\n    deleteDatasource(namespace: string, datasourceId: string): Promise<void>;\n    listDatasources(namespace: string): Promise<{ id: string; data: IStorageVectorDataSource }[]>;\n    getDatasource(namespace: string, datasourceId: string): Promise<IStorageVectorDataSource>;\n\n    createNamespace(namespace: string, metadata?: { [key: string]: any }): Promise<void>;\n    deleteNamespace(namespace: string): Promise<void>;\n    namespaceExists(namespace: string): Promise<boolean>;\n    listNamespaces(): Promise<IStorageVectorNamespace[]>;\n    getNamespace(namespace: string): Promise<IStorageVectorNamespace>;\n}\n\nexport abstract class VectorDBConnector extends SecureConnector {\n    public abstract id: string;\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n\n    public user(candidate: AccessCandidate): IVectorDBRequest {\n        return {\n            search: async (namespace: string, query: string | number[], options: QueryOptions) => {\n                return await this.search(candidate.readRequest, namespace, query, options);\n            },\n\n            createDatasource: async (namespace: string, datasource: DatasourceDto) => {\n                return await this.createDatasource(candidate.writeRequest, namespace, datasource);\n            },\n            deleteDatasource: async (namespace: string, datasourceId: string) => {\n                await this.deleteDatasource(candidate.writeRequest, namespace, datasourceId);\n            },\n            listDatasources: async (namespace: string) => {\n                return await this.listDatasources(candidate.readRequest, namespace);\n            },\n            getDatasource: async (namespace: string, datasourceId: string) => {\n                return await this.getDatasource(candidate.readRequest, namespace, datasourceId);\n            },\n\n            createNamespace: async (namespace: string, metadata?: { [key: string]: any }) => {\n                await this.createNamespace(candidate.writeRequest, namespace, metadata);\n            },\n            deleteNamespace: async (namespace: string) => {\n                await this.deleteNamespace(candidate.writeRequest, namespace);\n            },\n            listNamespaces: async () => {\n                return await this.listNamespaces(candidate.readRequest);\n            },\n            namespaceExists: async (namespace: string) => {\n                return await this.namespaceExists(candidate.readRequest, namespace);\n            },\n            getNamespace: async (namespace: string) => {\n                return await this.getNamespace(candidate.readRequest, namespace);\n            },\n        };\n    }\n\n    protected abstract search(\n        acRequest: AccessRequest,\n        namespace: string,\n        query: string | number[],\n        options: QueryOptions\n    ): Promise<VectorsResultData>;\n\n    protected abstract insert(acRequest: AccessRequest, namespace: string, source: IVectorDataSourceDto | IVectorDataSourceDto[]): Promise<string[]>;\n\n    protected abstract delete(acRequest: AccessRequest, namespace: string, id: string | string[]): Promise<void>;\n\n    protected abstract createDatasource(\n        acRequest: AccessRequest,\n        namespace: string,\n        datasource: DatasourceDto\n    ): Promise<{ id: string; vectorIds: string[] }>;\n\n    protected abstract deleteDatasource(acRequest: AccessRequest, namespace: string, datasourceId: string): Promise<void>;\n\n    protected abstract listDatasources(acRequest: AccessRequest, namespace: string): Promise<{ id: string; data: IStorageVectorDataSource }[]>;\n\n    protected abstract getDatasource(acRequest: AccessRequest, namespace: string, datasourceId: string): Promise<IStorageVectorDataSource>;\n\n    protected abstract createNamespace(\n        acRequest: AccessRequest,\n        namespace: string,\n\n        metadata?: { [key: string]: any }\n    ): Promise<void>;\n\n    protected abstract deleteNamespace(acRequest: AccessRequest, namespace: string): Promise<void>;\n\n    protected abstract listNamespaces(acRequest: AccessRequest): Promise<IStorageVectorNamespace[]>;\n\n    protected abstract namespaceExists(acRequest: AccessRequest, namespace: string): Promise<boolean>;\n\n    protected abstract getNamespace(acRequest: AccessRequest, namespace: string): Promise<IStorageVectorNamespace>;\n\n    public static constructNsName(teamId: string, name: string) {\n        const joinedName = name.trim().replace(/\\s/g, '_').toLowerCase();\n        return `${teamId}_${joinedName}`;\n    }\n\n    public static parseNsName(nsName: string) {\n        const parts = nsName.split('_');\n        if (parts.length < 2) return null;\n        return {\n            teamId: parts[0],\n            name: parts.slice(1).join('_'),\n        };\n    }\n}\n","//==[ SRE: S3Storage ]======================\n\nimport { IStorageRequest, StorageConnector } from '@sre/IO/Storage.service/StorageConnector';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { IAccessCandidate, IACL, TAccessLevel, TAccessResult, TAccessRole } from '@sre/types/ACL.types';\n\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { VectorDBConnector } from '../VectorDBConnector';\nimport {\n    DatasourceDto,\n    IStorageVectorDataSource,\n    IStorageVectorNamespace,\n    IVectorDataSourceDto,\n    PineconeConfig,\n    QueryOptions,\n    StorageVectorNamespaceMetadata,\n    VectorsResultData,\n} from '@sre/types/VectorDB.types';\nimport { Pinecone } from '@pinecone-database/pinecone';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { VectorsHelper } from '../Vectors.helper';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { NKVConnector } from '@sre/IO/NKV.service/NKVConnector';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport { JSONContentHelper } from '@sre/helpers/JsonContent.helper';\nimport { CacheConnector } from '@sre/MemoryManager/Cache.service';\nimport crypto from 'crypto';\n\nconst console = Logger('Pinecone VectorDB');\n\nexport class PineconeVectorDB extends VectorDBConnector {\n    public name = 'PineconeVectorDB';\n    public id = 'pinecone';\n    private client: Pinecone;\n    private indexName: string;\n    private redisCache: CacheConnector;\n    private accountConnector: AccountConnector;\n    private openaiApiKey: string;\n    private nkvConnector: NKVConnector;\n    private isCustomStorageInstance: boolean;\n\n    constructor(config: PineconeConfig) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n        if (!config.pineconeApiKey) throw new Error('Pinecone API key is required');\n        if (!config.indexName) throw new Error('Pinecone index name is required');\n\n        this.client = new Pinecone({\n            apiKey: config.pineconeApiKey,\n        });\n        console.info('Pinecone client initialized');\n        console.info('Pinecone index name:', config.indexName);\n        this.indexName = config.indexName;\n        this.accountConnector = ConnectorService.getAccountConnector();\n        this.redisCache = ConnectorService.getCacheConnector('Redis');\n        this.nkvConnector = ConnectorService.getNKVConnector();\n        this.openaiApiKey = config.openaiApiKey || process.env.OPENAI_API_KEY;\n        this.isCustomStorageInstance = config.isCustomStorageInstance || false;\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL> {\n        const teamId = await this.accountConnector.getCandidateTeam(AccessCandidate.clone(candidate));\n        const preparedNs = VectorDBConnector.constructNsName(teamId, resourceId);\n        const acl = await this.getACL(AccessCandidate.clone(candidate), preparedNs);\n        const exists = !!acl;\n\n        if (!exists) {\n            //the resource does not exist yet, we grant write access to the candidate in order to allow the resource creation\n            return new ACL().addAccess(candidate.role, candidate.id, TAccessLevel.Owner);\n        }\n        return ACL.from(acl);\n    }\n\n    @SecureConnector.AccessControl\n    protected async createNamespace(acRequest: AccessRequest, namespace: string, metadata?: { [key: string]: any }): Promise<void> {\n        //* Pinecone does not need explicit namespace creation, instead, it creates the namespace when the first vector is inserted\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n\n        const candidate = AccessCandidate.team(teamId);\n        const nsExists = await this.nkvConnector.user(candidate).exists(`vectorDB:${this.id}`, `namespace:${preparedNs}`);\n\n        if (!nsExists) {\n            const nsData: IStorageVectorNamespace = {\n                namespace: preparedNs,\n                displayName: namespace,\n                teamId,\n                metadata: {\n                    ...metadata,\n                    isOnCustomStorage: this.isCustomStorageInstance,\n                    indexName: this.indexName,\n                },\n            };\n            await this.nkvConnector.user(candidate).set(`vectorDB:${this.id}:namespaces`, preparedNs, JSON.stringify(nsData));\n        }\n\n        const acl = new ACL().addAccess(acRequest.candidate.role, acRequest.candidate.id, TAccessLevel.Owner).ACL;\n        await this.setACL(acRequest, preparedNs, acl);\n\n        return new Promise<void>((resolve) => resolve());\n    }\n\n    @SecureConnector.AccessControl\n    protected async namespaceExists(acRequest: AccessRequest, namespace: string): Promise<boolean> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        return await this.nkvConnector\n            .user(AccessCandidate.team(teamId))\n            .exists(`vectorDB:${this.id}:namespaces`, VectorDBConnector.constructNsName(teamId, namespace));\n    }\n\n    @SecureConnector.AccessControl\n    protected async getNamespace(acRequest: AccessRequest, namespace: string): Promise<any> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n        const nsData = await this.nkvConnector.user(AccessCandidate.team(teamId)).get(`vectorDB:${this.id}:namespaces`, preparedNs);\n        return JSONContentHelper.create(nsData?.toString()).tryParse() as IStorageVectorNamespace;\n    }\n\n    @SecureConnector.AccessControl\n    protected async listNamespaces(acRequest: AccessRequest): Promise<any[]> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const candidate = AccessCandidate.team(teamId);\n        const nsKeys = await this.nkvConnector.user(candidate).list(`vectorDB:${this.id}:namespaces`);\n        return nsKeys.map((k) => JSONContentHelper.create(k.data?.toString()).tryParse() as IStorageVectorNamespace);\n    }\n\n    @SecureConnector.AccessControl\n    protected async deleteNamespace(acRequest: AccessRequest, namespace: string): Promise<void> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const candidate = AccessCandidate.team(teamId);\n        const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n\n        await this.client\n            .Index(this.indexName)\n            .namespace(VectorDBConnector.constructNsName(teamId, namespace))\n            .deleteAll()\n            .catch((e) => {\n                if (e?.name == 'PineconeNotFoundError') {\n                    console.warn(`Namespace ${namespace} does not exist and was requested to be deleted`);\n                    return;\n                }\n                throw e;\n            });\n\n        await this.deleteACL(AccessCandidate.clone(acRequest.candidate), namespace);\n\n        await this.nkvConnector.user(candidate).delete('vectorDB:pinecone:namespaces', preparedNs);\n    }\n\n    @SecureConnector.AccessControl\n    protected async search(\n        acRequest: AccessRequest,\n        namespace: string,\n        query: string | number[],\n        options: QueryOptions = {}\n    ): Promise<VectorsResultData> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        let ns = await this.nkvConnector\n            .user(AccessCandidate.team(teamId))\n            .get(`vectorDB:${this.id}:namespaces`, VectorDBConnector.constructNsName(teamId, namespace));\n\n        if (!ns) {\n            throw new Error('Namespace does not exist');\n        }\n\n        const nsData = JSONContentHelper.create(ns.toString()).tryParse() as IStorageVectorNamespace;\n        if (nsData.metadata?.isOnCustomStorage && !this.isCustomStorageInstance) {\n            throw new Error('Tried to access namespace on custom storage.');\n        } else if (!nsData.metadata?.isOnCustomStorage && this.isCustomStorageInstance) {\n            throw new Error('Tried to access namespace that is not on custom storage.');\n        }\n\n        const pineconeIndex = this.client.Index(this.indexName).namespace(VectorDBConnector.constructNsName(teamId, namespace));\n        let _vector = query;\n        if (typeof query === 'string') {\n            _vector = await VectorsHelper.load({ openaiApiKey: this.openaiApiKey }).embedText(query);\n        }\n\n        const results = await pineconeIndex.query({\n            topK: options?.topK || 10,\n            vector: _vector as number[],\n            includeMetadata: true,\n            includeValues: true,\n        });\n\n        return results.matches.map((match) => {\n            if (match.metadata?.user) {\n                match.metadata.user = VectorsHelper.parseMetadata(match.metadata.user);\n            }\n            return {\n                id: match.id,\n                values: match.values,\n                metadata: match.metadata,\n            };\n        });\n    }\n\n    @SecureConnector.AccessControl\n    protected async insert(\n        acRequest: AccessRequest,\n        namespace: string,\n        sourceWrapper: IVectorDataSourceDto | IVectorDataSourceDto[]\n    ): Promise<string[]> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        sourceWrapper = Array.isArray(sourceWrapper) ? sourceWrapper : [sourceWrapper];\n        const helper = VectorsHelper.load({ openaiApiKey: this.openaiApiKey });\n\n        // make sure that all sources are of the same type (source.source)\n        if (sourceWrapper.some((s) => helper.detectSourceType(s.source) !== helper.detectSourceType(sourceWrapper[0].source))) {\n            throw new Error('All sources must be of the same type');\n        }\n\n        const sourceType = helper.detectSourceType(sourceWrapper[0].source);\n        if (sourceType === 'unknown' || sourceType === 'url') throw new Error('Invalid source type');\n        const transformedSource = await helper.transformSource(sourceWrapper, sourceType);\n        const preparedSource = transformedSource.map((s) => ({\n            id: s.id,\n            values: s.source as number[],\n            metadata: s.metadata,\n        }));\n\n        // await pineconeStore.addDocuments(chunks, ids);\n        await this.client.Index(this.indexName).namespace(VectorDBConnector.constructNsName(teamId, namespace)).upsert(preparedSource);\n\n        const accessCandidate = acRequest.candidate;\n\n        const isNewNs = await VectorsHelper.load({ openaiApiKey: this.openaiApiKey }).isNewNs(AccessCandidate.clone(accessCandidate), namespace);\n        if (isNewNs) {\n            let acl = new ACL().addAccess(accessCandidate.role, accessCandidate.id, TAccessLevel.Owner).ACL;\n            await this.setACL(acRequest, namespace, acl);\n        }\n\n        return preparedSource.map((s) => s.id);\n    }\n\n    @SecureConnector.AccessControl\n    protected async delete(acRequest: AccessRequest, namespace: string, id: string | string[]): Promise<void> {\n        const _ids = Array.isArray(id) ? id : [id];\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n\n        const res = await this.client.Index(this.indexName).namespace(VectorDBConnector.constructNsName(teamId, namespace)).deleteMany(_ids);\n    }\n\n    @SecureConnector.AccessControl\n    protected async createDatasource(\n        acRequest: AccessRequest,\n        namespace: string,\n        datasource: DatasourceDto\n    ): Promise<{ id: string; vectorIds: string[] }> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const formattedNs = VectorDBConnector.constructNsName(teamId, namespace);\n        const chunkedText = await VectorsHelper.chunkText(datasource.text, {\n            chunkSize: datasource.chunkSize,\n            chunkOverlap: datasource.chunkOverlap,\n        });\n        const ids = Array.from({ length: chunkedText.length }, (_, i) => crypto.randomUUID());\n        const source: IVectorDataSourceDto[] = chunkedText.map((doc, i) => {\n            return {\n                id: ids[i],\n                source: doc,\n                metadata: {\n                    user: VectorsHelper.stringifyMetadata(datasource.metadata), // user-speficied metadata\n                },\n            };\n        });\n        const nsExists = await this.nkvConnector\n            .user(AccessCandidate.team(teamId))\n            .exists(`vectorDB:${this.id}:namespaces`, VectorDBConnector.constructNsName(teamId, namespace));\n        if (!nsExists) {\n            throw new Error('Namespace does not exist');\n        }\n\n        const _vIds = await this.insert(acRequest, namespace, source);\n\n        const dsId = datasource.id || crypto.randomUUID();\n\n        const dsData: IStorageVectorDataSource = {\n            namespaceId: formattedNs,\n            teamId,\n            name: datasource.label || 'Untitled',\n            metadata: VectorsHelper.stringifyMetadata(datasource.metadata),\n            text: datasource.text,\n            embeddingIds: _vIds,\n        };\n        // const url = `smythfs://${teamId}.team/_datasources/${dsId}.json`;\n        // await SmythFS.Instance.write(url, JSON.stringify(dsData), AccessCandidate.team(teamId));\n        await this.nkvConnector\n            .user(AccessCandidate.team(teamId))\n            .set(`vectorDB:${this.id}:namespaces:${formattedNs}:datasources`, dsId, JSON.stringify(dsData));\n        return { id: dsId, vectorIds: _vIds };\n    }\n\n    @SecureConnector.AccessControl\n    protected async deleteDatasource(acRequest: AccessRequest, namespace: string, datasourceId: string): Promise<void> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const formattedNs = VectorDBConnector.constructNsName(teamId, namespace);\n        // const url = `smythfs://${teamId}.team/_datasources/${dsId}.json`;\n        // await SmythFS.Instance.delete(url, AccessCandidate.team(teamId));\n        let ds: IStorageVectorDataSource = JSONContentHelper.create(\n            (\n                await this.nkvConnector\n                    .user(AccessCandidate.team(teamId))\n                    .get(`vectorDB:${this.id}:namespaces:${formattedNs}:datasources`, datasourceId)\n            )?.toString()\n        ).tryParse();\n\n        if (!ds || typeof ds !== 'object') {\n            throw new Error(`Data source not found with id: ${datasourceId}`);\n        }\n\n        const nsExists = await this.nkvConnector\n            .user(AccessCandidate.team(teamId))\n            .exists(`vectorDB:${this.id}:namespaces`, VectorDBConnector.constructNsName(teamId, namespace));\n        if (!nsExists) {\n            throw new Error('Namespace does not exist');\n        }\n\n        await this.delete(acRequest, namespace, ds.embeddingIds || []);\n\n        await this.nkvConnector.user(AccessCandidate.team(teamId)).delete(`vectorDB:${this.id}:namespaces:${formattedNs}:datasources`, datasourceId);\n    }\n\n    @SecureConnector.AccessControl\n    protected async listDatasources(acRequest: AccessRequest, namespace: string): Promise<{ id: string; data: IStorageVectorDataSource }[]> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const formattedNs = VectorDBConnector.constructNsName(teamId, namespace);\n        return (await this.nkvConnector.user(AccessCandidate.team(teamId)).list(`vectorDB:${this.id}:namespaces:${formattedNs}:datasources`)).map(\n            (ds) => {\n                return {\n                    id: ds.key,\n                    data: JSONContentHelper.create(ds.data?.toString()).tryParse() as IStorageVectorDataSource,\n                };\n            }\n        );\n    }\n\n    @SecureConnector.AccessControl\n    protected async getDatasource(acRequest: AccessRequest, namespace: string, datasourceId: string): Promise<IStorageVectorDataSource> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const formattedNs = VectorDBConnector.constructNsName(teamId, namespace);\n        return JSONContentHelper.create(\n            (\n                await this.nkvConnector\n                    .user(AccessCandidate.team(teamId))\n                    .get(`vectorDB:${this.id}:namespaces:${formattedNs}:datasources`, datasourceId)\n            )?.toString()\n        ).tryParse() as IStorageVectorDataSource;\n    }\n\n    private async setACL(acRequest: AccessRequest, preparedNs: string, acl: IACL): Promise<void> {\n        await this.redisCache\n            .user(AccessCandidate.clone(acRequest.candidate))\n            .set(`vectorDB:pinecone:namespace:${preparedNs}:acl`, JSON.stringify(acl));\n    }\n\n    private async getACL(ac: AccessCandidate, preparedNs: string): Promise<ACL | null | undefined> {\n        let aclRes = await this.redisCache.user(ac).get(`vectorDB:pinecone:namespace:${preparedNs}:acl`);\n        const acl = JSONContentHelper.create(aclRes?.toString?.()).tryParse();\n        return acl;\n    }\n\n    private async deleteACL(ac: AccessCandidate, preparedNs: string): Promise<void> {\n        this.redisCache.user(AccessCandidate.clone(ac)).delete(`vectorDB:pinecone:namespace:${preparedNs}:acl`);\n    }\n}\n","import { OpenAIEmbeddings } from '@langchain/openai';\nimport { RecursiveCharacterTextSplitter } from '@langchain/textsplitters';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { VectorDBConnector } from './VectorDBConnector';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport crypto from 'crypto';\nimport { IStorageVectorDataSource, IStorageVectorNamespace, IVectorDataSourceDto, QueryOptions, Source } from '@sre/types/VectorDB.types';\nimport { jsonrepair } from 'jsonrepair';\nimport { NKVConnector } from '../NKV.service/NKVConnector';\nimport { JSONContentHelper } from '@sre/helpers/JsonContent.helper';\nimport { VaultConnector } from '@sre/Security/Vault.service/VaultConnector';\nimport { PineconeVectorDB } from './connectors/PineconeVectorDB.class';\nimport { isUrl } from '@sre/utils/data.utils';\n\ntype SupportedSources = 'text' | 'vector' | 'url';\n\nexport class VectorsHelper {\n    private _vectorDBconnector: VectorDBConnector;\n    private embeddingsProvider: OpenAIEmbeddings;\n    private _vectorDimention: number;\n    private _vaultConnector: VaultConnector;\n    public cusStorageKeyName: string;\n    private isCustomStorageInstance: boolean = false;\n    private openaiApiKey: string;\n    constructor(connectorName?: string, options: { openaiApiKey?: string } = {}) {\n        this._vectorDBconnector = ConnectorService.getVectorDBConnector(connectorName);\n        this.openaiApiKey = options.openaiApiKey || process.env.OPENAI_API_KEY;\n        this.embeddingsProvider = new OpenAIEmbeddings({ apiKey: this.openaiApiKey });\n        if (this._vectorDimention && !isNaN(this._vectorDimention)) {\n            this.embeddingsProvider.dimensions = this._vectorDimention;\n        }\n        this._vaultConnector = ConnectorService.getVaultConnector();\n        this.cusStorageKeyName = `vectorDB:customStorage:${this._vectorDBconnector.id}`;\n    }\n\n    public static load(options: { vectorDimention?: number; connectorName?: string; openaiApiKey?: string } = {}) {\n        const instance = new VectorsHelper(options.connectorName, { openaiApiKey: options.openaiApiKey });\n        options.vectorDimention && instance.setVectorDimention(options.vectorDimention);\n\n        return instance;\n    }\n\n    public setVectorDimention(vectorDimention: number) {\n        this._vectorDimention = vectorDimention;\n    }\n\n    public static async chunkText(\n        text: string,\n        {\n            chunkSize = 4000,\n            chunkOverlap = 500,\n        }: {\n            chunkSize?: number;\n            chunkOverlap?: number;\n        } = {}\n    ): Promise<string[]> {\n        const textSplitter = new RecursiveCharacterTextSplitter({\n            chunkSize,\n            chunkOverlap,\n        });\n        let output = await textSplitter.splitText(text);\n\n        return output;\n    }\n\n    public async isNewNs(ac: AccessCandidate, namespace: string): Promise<boolean> {\n        return !(await this._vectorDBconnector.user(ac).namespaceExists(namespace));\n    }\n\n    public async embedText(text: string) {\n        return this.embeddingsProvider.embedQuery(text);\n    }\n\n    public async embedTexts(texts: string[]) {\n        return this.embeddingsProvider.embedDocuments(texts);\n    }\n\n    public static stringifyMetadata(metadata: any) {\n        try {\n            return jsonrepair(JSON.stringify(metadata));\n        } catch (err) {\n            return metadata;\n        }\n    }\n    public static parseMetadata(metadata: any) {\n        try {\n            return JSON.parse(metadata);\n        } catch (err) {\n            return metadata;\n        }\n    }\n\n    async getTeamConnector(teamId: string): Promise<VectorDBConnector | null> {\n        const config = await this.getCustomStorageConfig(teamId).catch((e) => null);\n        if (!config) return null;\n        return this._vectorDBconnector.instance({ ...config, isCustomStorageInstance: true });\n    }\n\n    async getCustomStorageConfig(teamId: string) {\n        const config = await this._vaultConnector.user(AccessCandidate.team(teamId)).get(this.cusStorageKeyName);\n        if (!config) {\n            if (this._vectorDBconnector instanceof PineconeVectorDB) {\n                // TODO: try to grab the keys from the middleware team settings (legacy storage) (required for backward compatibility)\n            }\n            return null;\n        }\n\n        return JSONContentHelper.create(config).tryParse();\n    }\n\n    public async isNamespaceOnCustomStorage(teamId: string, namespace: string) {\n        const ns = await this._vectorDBconnector.user(AccessCandidate.team(teamId)).getNamespace(namespace);\n        return (ns.metadata?.isOnCustomStorage as boolean) ?? false;\n    }\n\n    public detectSourceType(source: Source): SupportedSources | 'unknown' {\n        if (typeof source === 'string') {\n            return isUrl(source) ? 'url' : 'text';\n        } else if (Array.isArray(source) && source.every((v) => typeof v === 'number')) {\n            return 'vector';\n        } else {\n            return 'unknown';\n        }\n    }\n\n    public transformSource(source: IVectorDataSourceDto[], sourceType: SupportedSources) {\n        //* as the accepted sources increases, you will need to implement the strategy pattern instead of a switch case\n        switch (sourceType) {\n            case 'text': {\n                const texts = source.map((s) => s.source as string);\n\n                return VectorsHelper.load({ openaiApiKey: this.openaiApiKey })\n                    .embedTexts(texts)\n                    .then((vectors) => {\n                        return source.map((s, i) => ({\n                            ...s,\n                            source: vectors[i],\n                            metadata: { ...s.metadata, text: texts[i] },\n                        }));\n                    });\n            }\n            case 'vector': {\n                return source;\n            }\n        }\n    }\n\n    // async configureCustomStorage(teamId: string, config: any) {\n    //     const exists = !!(await this.getCustomStorageConfig(teamId));\n\n    //     if (exists) {\n    //         throw new Error('Custom storage is already configured');\n    //     }\n    //     const preparedConfig = typeof config === 'string' ? config : JSON.stringify(config);\n    //     return this._vaultConnector.user(AccessCandidate.team(teamId)).set(this._cusStorageKeyName(teamId), preparedConfig);\n    // }\n\n    // async deleteCustomStorage(teamId: string) {\n    //     const exists = !!(await this.getCustomStorageConfig(teamId));\n    //     if (!exists) {\n    //         throw new Error('Custom storage is not configured');\n    //     }\n    //     // load the team vectorDB connector that has the custom storage\n    //     const _connector = await this.getTeamVectorDB(teamId);\n    //     const namespaces = _connector.user(AccessCandidate.team(teamId)).listNamespaces();\n    //     // TODO: delete all namespaces who are stored in the custom storage (isOnCustomStorage: true)\n    //     return this._vaultConnector.user(AccessCandidate.team(teamId)).delete(this._cusStorageKeyName(teamId));\n    // }\n}\n","// import Component from './Component.class';\nimport Joi from 'joi';\n// import { LLMInference } from '@sre/LLMManager/LLM.inference';\nimport { validateInteger } from '../utils';\nimport { jsonrepair } from 'jsonrepair';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { JSONContent } from '@sre/helpers/JsonContent.helper';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\nimport { VectorsHelper } from '@sre/IO/VectorDB.service/Vectors.helper';\n// import { LLMHelper } from '@sre/LLMManager/LLM.helper';\n\n// Note: LLMHelper renamed to LLMInference\nclass LLMInference {\n    static async getInstance(model: string) {\n        throw new Error('Method not implemented.');\n    }\n}\n\nexport default class DataSourceLookup extends Component {\n    protected configSchema = Joi.object({\n        topK: Joi.string()\n            .custom(validateInteger({ min: 0 }), 'custom range validation')\n            .label('Result Count'),\n        model: Joi.string().valid('gpt-4o-mini', 'gpt-4', 'gpt-3.5-turbo', 'gpt-4', 'gpt-3.5-turbo-16k').optional(),\n        prompt: Joi.string().max(30000).allow('').label('Prompt').optional(),\n        postprocess: Joi.boolean().strict().optional(),\n        includeMetadata: Joi.boolean().strict().optional(),\n        namespace: Joi.string().allow('').max(80).messages({\n            // Need to reserve 30 characters for the prefixed unique id\n            'string.max': `The length of the 'namespace' name must be 50 characters or fewer.`,\n        }),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const componentId = config.id;\n        const component = agent.components[componentId];\n        const teamId = agent.teamId;\n        let debugOutput = agent.agentRuntime?.debug ? '== Data Source Lookup Log ==\\n' : null;\n\n        const outputs = {};\n        for (let con of config.outputs) {\n            if (con.default) continue;\n            outputs[con.name] = '';\n        }\n\n        const namespace = config.data.namespace.split('_').slice(1).join('_') || config.data.namespace;\n        const model = config.data?.model || 'gpt-4o-mini';\n        const prompt = config.data?.prompt?.trim?.() || '';\n        const postprocess = config.data?.postprocess || false;\n        const includeMetadata = config.data?.includeMetadata || false;\n\n        const _input = typeof input.Query === 'string' ? input.Query : JSON.stringify(input.Query);\n\n        const topK = Math.max(config.data?.topK || 50, 50);\n\n        let vectorDBHelper = VectorsHelper.load();\n\n        const customStorageConnector = await vectorDBHelper.getTeamConnector(teamId);\n        let vectorDbConnector = customStorageConnector || ConnectorService.getVectorDBConnector();\n\n        let existingNs = await vectorDbConnector.user(AccessCandidate.team(teamId)).getNamespace(namespace);\n        if (!existingNs) {\n            await vectorDbConnector.user(AccessCandidate.team(teamId)).createNamespace(namespace);\n            debugOutput += `[Created namespace] \\n${namespace}\\n\\n`;\n        } else if (!existingNs.metadata.isOnCustomStorage) {\n            // If the namespace exists but is not on custom storage, switch to the default connector.\n            vectorDbConnector = ConnectorService.getVectorDBConnector();\n        }\n\n        let results: string[] | { content: string; metadata: any }[];\n        let _error;\n        try {\n            const response = await vectorDbConnector.user(AccessCandidate.team(teamId)).search(namespace, _input, { topK, includeMetadata: true });\n            results = response.slice(0, config.data.topK).map((result) => ({\n                content: result.metadata?.text,\n                metadata: result.metadata,\n            }));\n\n            if (includeMetadata) {\n                // only show user-level metadata\n                results = results.map((result) => ({\n                    content: result.content,\n                    metadata: this.parseMetadata(\n                        result.metadata?.user || result.metadata?.metadata //* legacy user-specific metadata key [result.metadata?.metadata]\n                    ),\n                }));\n            } else {\n                results = results.map((result) => result.content);\n            }\n            debugOutput += `[Results] \\nLoaded ${results.length} results from namespace: ${namespace}\\n\\n`;\n        } catch (error) {\n            _error = error.toString();\n        }\n\n        //is there a post processing LLM?\n\n        //TODO : better handling of context window exceeding max length\n        if (postprocess && prompt) {\n            const promises: any = [];\n            for (let result of results) {\n                const _prompt = TemplateString(prompt.replace(/{{result}}/g, JSON.stringify(result))).parse(input).result;\n                const llmInference = await LLMInference.getInstance(model);\n                // const req = llmInference.promptRequest(_prompt, config, agent).catch((error) => ({ error: error }));\n                // promises.push(req);\n            }\n            results = await Promise.all(promises);\n            for (let i = 0; i < results.length; i++) {\n                if (typeof results[i] === 'string') {\n                    // results[i] = parseJson(results[i]);\n                    results[i] = JSONContent(results[i] as string).tryParse();\n                }\n            }\n        }\n\n        const totalLength = JSON.stringify(results).length;\n        debugOutput += `[Total Length] \\n${totalLength}\\n\\n`;\n        return {\n            Results: results,\n            _error,\n            _debug: debugOutput,\n            //_debug: `Query: ${_input}. \\nTotal Length = ${totalLength} \\nResults: ${JSON.stringify(results)}`,\n        };\n    }\n\n    // private async checkIfTeamOwnsNamespace(teamId: string, namespaceId: string, token: string) {\n    //     try {\n    //         const res = await SmythAPIHelper.fromAuth({ token }).mwSysAPI.get(`/vectors/namespaces/${namespaceId}`);\n    //         if (res.data?.namespace?.teamId !== teamId) {\n    //             throw new Error(`Namespace does not exist`);\n    //         }\n    //         return true;\n    //     } catch (err) {\n    //         throw new Error(`Namespace does not exist`);\n    //     }\n    // }\n\n    private parseMetadata(metadata: any) {\n        try {\n            return JSON.parse(jsonrepair(metadata));\n        } catch (err) {\n            return metadata;\n        }\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\nimport Joi from 'joi';\nimport { validateCharacterSet } from '@sre/utils/validation.utils';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { isUrl, detectURLSourceType } from '../utils';\nimport { SmythFS } from '@sre/IO/Storage.service/SmythFS.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { VectorsHelper } from '@sre/IO/VectorDB.service/Vectors.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { IStorageVectorDataSource } from '@sre/types/VectorDB.types';\n\nexport default class DataSourceIndexer extends Component {\n    private MAX_ALLOWED_URLS_PER_INPUT = 20;\n    protected configSchema = Joi.object({\n        namespace: Joi.string().max(50).allow(''),\n        id: Joi.string().custom(validateCharacterSet, 'id custom validation').allow('').label('source identifier'),\n        name: Joi.string().max(50).allow('').label('label'),\n        metadata: Joi.string().allow(null).allow('').max(10000).label('metadata'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const teamId = agent.teamId;\n        const agentId = agent.id;\n        let debugOutput = agent.agentRuntime?.debug ? '== Source Indexer Log ==\\n' : null;\n\n        try {\n            const _config = {\n                ...config.data,\n                name: TemplateString(config.data.name).parse(input).result,\n                id: TemplateString(config.data.id).parse(input).result,\n                metadata: TemplateString(config.data.metadata).parse(input).result,\n            };\n\n            const outputs = {};\n            for (let con of config.outputs) {\n                if (con.default) continue;\n                outputs[con.name] = con?.description ? `<${con?.description}>` : '';\n            }\n\n            const namespaceId = _config.namespace.split('_').slice(1).join('_') || _config.namespace;\n            debugOutput += `[Selected namespace id] \\n${namespaceId}\\n\\n`;\n\n            const vectorDBHelper = VectorsHelper.load();\n            const vectorDbConnector = (await vectorDBHelper.getTeamConnector(teamId)) || ConnectorService.getVectorDBConnector();\n            const nsExists = await vectorDbConnector.user(AccessCandidate.team(teamId)).namespaceExists(namespaceId);\n\n            if (!nsExists) {\n                // throw new Error(`Namespace ${namespaceId} does not exist`);\n                const newNs = await vectorDbConnector.user(AccessCandidate.team(teamId)).createNamespace(namespaceId);\n                debugOutput += `[Created namespace] \\n${newNs}\\n\\n`;\n            }\n\n            const inputSchema = this.validateInput(input);\n            if (inputSchema.error) {\n                throw new Error(`Input validation error: ${inputSchema.error}\\n EXITING...`);\n            }\n\n            const providedId = _config.id;\n            // const isAutoId = _config.isAutoId;\n            const idRegex = /^[a-zA-Z0-9\\-\\_\\.]+$/;\n\n            if (!providedId) {\n                // Assign a new ID if it's set to auto-generate or not provided\n                // _config.id = crypto.randomBytes(16).toString('hex');\n                throw new Error(`Id is required`);\n            } else if (!idRegex.test(providedId)) {\n                // Validate the provided ID if it's not auto-generated\n                throw new Error(`Invalid id. Accepted characters: 'a-z', 'A-Z', '0-9', '-', '_', '.'`);\n            }\n\n            // check if the datasource already exists with the same id\n            // await this.checkForRecordDuplicate(dsId, token);\n\n            let indexRes: any = null;\n            let parsedUrlArray: string[] | null = null;\n\n            //! DISABLE URL ARRAY PARSING FOR NOW UNTIL WE HAVE A GOOD WAY TO HANDLE BULK INDEXING\n            // if ((parsedUrlArray = parseUrlArray(inputSchema.value.Source))) {\n            //     debugOutput += `STEP: Parsing input as url array\\n\\n`;\n            //     if (parsedUrlArray.length > this.MAX_ALLOWED_URLS_PER_INPUT) {\n            //         throw new Error(`Too many urls in input. Max allowed: ${this.MAX_ALLOWED_URLS_PER_INPUT}`);\n            //     }\n\n            //     for (let url of parsedUrlArray) {\n            //         indexRes = await this.addDSFromUrl({\n            //             teamId,\n            //             namespaceId,\n            //             dsId, // WILL OVERRIDE EACH OTHER\n            //             type: detectURLSourceType(url),\n            //             url,\n            //             name: _config.name || 'Untitled',\n            //         });\n\n            //         debugOutput += `STEP: Created datasource for url: ${url}\\n\\n`;\n            //     }\n            // } else\n\n            const dsId = DataSourceIndexer.genDsId(providedId, teamId, namespaceId);\n\n            if (isUrl(inputSchema.value.Source)) {\n                debugOutput += `STEP: Parsing input as url\\n\\n`;\n                throw new Error('URLs are not supported yet');\n                // indexRes = await this.addDSFromUrl({\n                //     teamId,\n                //     namespaceId,\n                //     dsId,\n                //     type: detectURLSourceType(inputSchema.value.Source),\n                //     url: inputSchema.value.Source,\n                //     name: _config.name || 'Untitled',\n                //     metadata: _config.metadata || null,\n                // });\n            } else {\n                debugOutput += `STEP: Parsing input as text\\n\\n`;\n                indexRes = await this.addDSFromText({\n                    teamId,\n                    namespaceId: namespaceId,\n                    text: inputSchema.value.Source,\n                    name: _config.name || 'Untitled',\n                    metadata: _config.metadata || null,\n                    sourceId: dsId,\n                });\n            }\n\n            debugOutput += `Created datasource successfully\\n\\n`;\n\n            return {\n                _debug: debugOutput,\n                Success: {\n                    result: indexRes?.data?.dataSource || true,\n                    id: _config.id,\n                },\n                // _error,\n            };\n        } catch (err: any) {\n            debugOutput += `Error: ${err?.message || \"Couldn't index data source\"}\\n\\n`;\n            return {\n                _debug: debugOutput,\n                _error: err?.message || \"Couldn't index data source\",\n            };\n        }\n    }\n\n    validateInput(input: any) {\n        return Joi.object({\n            Source: Joi.any().required(),\n        })\n            .unknown(true)\n            .validate(input);\n    }\n\n    private async addDSFromText({ teamId, sourceId, namespaceId, text, name, metadata }) {\n        let vectorDBHelper = VectorsHelper.load();\n        let vectorDbConnector = ConnectorService.getVectorDBConnector();\n        const isOnCustomStorage = await vectorDBHelper.isNamespaceOnCustomStorage(teamId, namespaceId);\n        if (isOnCustomStorage) {\n            const customTeamConnector = await vectorDBHelper.getTeamConnector(teamId);\n            if (customTeamConnector) {\n                vectorDbConnector = customTeamConnector;\n            }\n        }\n        const id = await vectorDbConnector.user(AccessCandidate.team(teamId)).createDatasource(namespaceId, {\n            text,\n            metadata,\n            id: sourceId,\n            label: name,\n        });\n\n        return id;\n    }\n\n    public static genDsId(providedId: string, teamId: string, namespaceId: string) {\n        return `${teamId}::${namespaceId}::${providedId}`;\n    }\n\n    private async addDSFromUrl({ teamId, namespaceId, dsId, type, url, name, metadata }) {\n        throw new Error('URLs are not supported yet');\n    }\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicAtLeast extends Component {\n    protected configSchema = Joi.object({\n        // TODO (Forhad): Need to check if min and max work instead of the custom validateInteger\n        minSetInputs: Joi.string()\n            .custom(validateInteger({ min: 0, max: 9 }), 'custom range validation')\n            .label('Minimum Inputs'),\n    });\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        const result: any = { Output: undefined };\n\n        if (typeof config.data.minSetInputs !== 'string' || config.data.minSetInputs.trim() === '' || isNaN(Number(config.data.minSetInputs))) {\n            return result;\n        }\n\n        const minSetInputs = Number(config.data.minSetInputs);\n        if (config.inputs.length < minSetInputs) {\n            return result;\n        }\n\n        let trueCount = 0;\n        for (let cfgInput of config.inputs) {\n            if (input[cfgInput.name]) {\n                trueCount++;\n            }\n        }\n\n        if (trueCount >= minSetInputs) {\n            result.Output = true;\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n\n        return result;\n    }\n}\n\ninterface RangeValidationArgs {\n    min?: number;\n    max?: number;\n}\n\nfunction validateInteger(args: RangeValidationArgs) {\n    return (value: string, helpers: any) => {\n        const numValue = Number(value);\n        const fieldName = helpers.schema._flags.label || helpers.state.path[helpers.state.path.length - 1];\n\n        // Check if the value is a number\n        if (isNaN(numValue)) {\n            throw new Error(`The value for '${fieldName}' must be a number`);\n        }\n\n        // Range validations\n        if (args.min !== undefined && args.max !== undefined) {\n            if (numValue < args.min || numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be from ${args.min} to ${args.max}`);\n            }\n        } else if (args.min !== undefined) {\n            if (numValue < args.min) {\n                throw new Error(`The value for '${fieldName}' must be greater or equal to ${args.min}`);\n            }\n        } else if (args.max !== undefined) {\n            if (numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be less or equal to ${args.max}`);\n            }\n        }\n\n        return value; // Value is valid\n    };\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicAtMost extends Component {\n    protected configSchema = Joi.object({\n        // TODO (Forhad): Need to check if min and max work instead of the custom validateInteger\n        maxSetInputs: Joi.string()\n            .custom(validateInteger({ min: 0, max: 9 }), 'custom range validation')\n            .label('Maximum Inputs'),\n    });\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const result: any = { Output: undefined };\n\n        if (typeof config.data.maxSetInputs !== 'string' || config.data.maxSetInputs.trim() === '' || isNaN(Number(config.data.maxSetInputs))) {\n            return result;\n        }\n\n        const maxSetInputs = Number(config.data.maxSetInputs);\n        if (config.inputs.length < maxSetInputs) {\n            return result;\n        }\n\n        let trueCount = 0;\n        for (let cfgInput of config.inputs) {\n            if (input[cfgInput.name]) {\n                trueCount++;\n                if (trueCount > maxSetInputs) {\n                    break;\n                }\n            }\n        }\n\n        if (trueCount <= maxSetInputs) {\n            result.Output = true;\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n\n        return result;\n    }\n}\ninterface RangeValidationArgs {\n    min?: number;\n    max?: number;\n}\n\nfunction validateInteger(args: RangeValidationArgs) {\n    return (value: string, helpers: any) => {\n        const numValue = Number(value);\n        const fieldName = helpers.schema._flags.label || helpers.state.path[helpers.state.path.length - 1];\n\n        // Check if the value is a number\n        if (isNaN(numValue)) {\n            throw new Error(`The value for '${fieldName}' must be a number`);\n        }\n\n        // Range validations\n        if (args.min !== undefined && args.max !== undefined) {\n            if (numValue < args.min || numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be from ${args.min} to ${args.max}`);\n            }\n        } else if (args.min !== undefined) {\n            if (numValue < args.min) {\n                throw new Error(`The value for '${fieldName}' must be greater or equal to ${args.min}`);\n            }\n        } else if (args.max !== undefined) {\n            if (numValue > args.max) {\n                throw new Error(`The value for '${fieldName}' must be less or equal to ${args.max}`);\n            }\n        }\n\n        return value; // Value is valid\n    };\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport AgentRequest from '@sre/AgentManager/AgentRequest.class';\nimport AgentSettings from '@sre/AgentManager/AgentSettings.class';\nimport { TAgentProcessParams } from '@sre/types/Agent.types';\nimport { uid } from '../utils';\n\nimport { CLIConnector } from '@sre/IO/CLI.service/CLIConnector';\nimport * as FileType from 'file-type';\nimport fs from 'fs';\nimport mime from 'mime';\nimport path from 'path';\nimport { ConnectorService } from './ConnectorsService';\nexport class AgentProcess {\n    public agent: Agent;\n\n    private _loadPromise: Promise<any>;\n\n    private constructor(private agentData: any) {\n        this.initAgent(agentData);\n    }\n    private async initAgent(agentData: any) {\n        let data;\n        let agentId;\n\n        if (typeof agentData === 'object') {\n            data = agentData;\n            if (data.components && data.connections) {\n                data = { data, version: '1.0' };\n            }\n\n            agentId = data.data.id || 'tmp-' + uid();\n        } else {\n            const jsonRegex = /^{.*}$/g;\n            const jsonData = agentData.match(jsonRegex)?.[0];\n\n            const idRegex = /^[a-zA-Z0-9\\-]+$/g;\n            agentId = agentData.match(idRegex)?.[0];\n\n            //We are loading from an agentId\n            if (agentId) {\n                const agentDataConnector = ConnectorService.getAgentDataConnector();\n                data = await agentDataConnector.getAgentData(agentId, 'latest');\n            }\n\n            //we are loading an agent from provided data\n            if (!data && jsonData) {\n                data = JSON.parse(jsonData);\n                //generate an agentId if not provided\n                agentId = data.id || 'tmp-' + uid();\n\n                if (data.components && data.connections) {\n                    data = { data, version: '1.0' };\n                }\n            }\n        }\n\n        const agentSettings = new AgentSettings(agentId);\n        this.agent = new Agent(agentId, data, agentSettings);\n    }\n\n    public async ready() {\n        if (this._loadPromise) {\n            return this._loadPromise;\n        }\n\n        return (this._loadPromise = new Promise((resolve) => {\n            let maxWait = 10000;\n            //wait for agent to be set\n            const itv = setInterval(() => {\n                if (this.agent) {\n                    clearInterval(itv);\n                    resolve(true);\n                }\n                maxWait -= 100;\n                if (maxWait <= 0) {\n                    clearInterval(itv);\n                    resolve(false);\n                }\n            }, 100);\n        }));\n    }\n\n    public static load(agentData: any) {\n        const agentProcess = new AgentProcess(agentData);\n        return agentProcess;\n    }\n\n    public async run(reqConfig: TAgentProcessParams | Array<string> | AgentRequest) {\n        await this.ready();\n        if (!this.agent) throw new Error('Failed to load agent');\n        let request: AgentRequest = this.parseReqConfig(reqConfig);\n\n        this.agent.setRequest(request);\n\n        const pathMatches = request.path.match(/(^\\/v[0-9]+\\.[0-9]+?)?(\\/api\\/(.+)?)/);\n        if (!pathMatches || !pathMatches[2]) {\n            return { status: 404, data: { error: 'Endpoint not found' } };\n        }\n        const endpointPath = pathMatches[2];\n        const input = request.method == 'GET' ? request.query : request.body;\n        const result: any = await this.agent.process(endpointPath, input).catch((error) => ({ error: error.message }));\n\n        return { data: result };\n    }\n\n    public reset() {\n        //the current version of agent cannot be used to run multiple requests\n        //as a workaround we provide this function to reset AgentProcess state by generating a new Agent\n        //TODO: refactor Agent.class in order to allow multiple consecutive requests running\n        this.initAgent(this.agentData);\n    }\n\n    private parseReqConfig(reqConfig: TAgentProcessParams | Array<string> | AgentRequest): AgentRequest {\n        if (reqConfig instanceof AgentRequest) return reqConfig;\n        if (Array.isArray(reqConfig)) return this.parseCLI(reqConfig);\n        return new AgentRequest(reqConfig);\n    }\n\n    private parseCLI(argList: Array<string>): AgentRequest {\n        const cliConnector: CLIConnector = ConnectorService.getCLIConnector();\n        const methods = ['get', 'post', 'put', 'delete', 'patch', 'head', 'options'];\n        const cli: any = cliConnector.parse(argList, ['endpoint', 'post', 'get', 'put', 'delete', 'patch', 'head', 'options', 'headers', 'session']);\n\n        const usedMethod = methods.find((method) => cli[method]);\n\n        const req: AgentRequest = new AgentRequest();\n\n        req.method = usedMethod?.toUpperCase() || 'GET';\n        req.body = {};\n        req.query = {};\n\n        switch (usedMethod) {\n            case 'get':\n            case 'delete':\n            case 'head':\n            case 'options':\n                req.query = cli[usedMethod];\n                break;\n            case 'post':\n            case 'put':\n            case 'patch':\n                req.body = cli[usedMethod];\n                break;\n        }\n\n        req.path = `/api/${cli.endpoint}`;\n        req.params = cli.endpoint?.split('/');\n\n        req.headers = cli.headers || {};\n        //convert all keys to lowercase\n        for (let key in req.headers) {\n            req.headers[key.toLowerCase()] = req.headers[key];\n            delete req.headers[key];\n        }\n\n        req.sessionID = cli.session || uid();\n\n        req.files = [];\n        if (req.body) {\n            for (let entry in req.body) {\n                let value = req.body[entry];\n                const filePath = path.join(process.cwd(), value);\n                const fileName = path.basename(filePath);\n                if (!fs.existsSync(filePath)) continue;\n\n                //read the file and create a file object\n\n                try {\n                    // Read the file content\n                    const fileBuffer = fs.readFileSync(filePath);\n                    const ext: any = fileName.split('.').pop();\n\n                    const fileObj = {\n                        fieldname: entry,\n                        originalname: fileName,\n                        buffer: fileBuffer,\n                        mimetype: mime.getType(ext) || 'application/octet-stream',\n                    };\n\n                    delete req.body[entry];\n                    req.files.push(fileObj);\n\n                    // Try to determine the MIME type from the file content\n                    FileType.fileTypeFromBuffer(fileBuffer).then((fileType) => {\n                        if (fileType) {\n                            fileObj.mimetype = fileType.mime;\n                        }\n                    });\n                } catch (error) {\n                    console.warn('Coud not read file', filePath, error.message);\n                }\n            }\n        }\n\n        return req;\n    }\n\n    public async post(path: string, input?: any, headers?: any) {\n        return this.run({ method: 'POST', path, body: input || {}, headers });\n    }\n\n    public async get(path: string, query?: any, headers?: any) {\n        return this.run({ method: 'GET', path, query, headers });\n    }\n\n    public async readDebugState(stateId: string, reqConfig: TAgentProcessParams | Array<string> | AgentRequest) {\n        await this.ready();\n        if (!this.agent) throw new Error('Failed to load agent');\n        let request: AgentRequest = this.parseReqConfig(reqConfig);\n\n        this.agent.setRequest(request);\n\n        return this.agent.agentRuntime.readState(stateId, true);\n    }\n}\n","import { encode, encodeChat } from 'gpt-tokenizer';\nimport { ChatMessage } from 'gpt-tokenizer/esm/GptEncoding';\nimport { LLMRegistry } from '@sre/LLMManager/LLMRegistry.class';\nimport { CustomLLMRegistry } from '@sre/LLMManager/CustomLLMRegistry.class';\nimport { ILLMContextStore } from '@sre/types/LLM.types';\n\n// TODO [Forhad]: we can move methods to MessageProcessor\n\n//content, name, role, tool_call_id, tool_calls, function_call\nexport class LLMContext {\n    private _systemPrompt: string = '';\n    private _llmContextStore: ILLMContextStore;\n    public get systemPrompt() {\n        return this._systemPrompt;\n    }\n    public set systemPrompt(systemPrompt) {\n        this._systemPrompt = systemPrompt;\n    }\n    public contextLength: number;\n\n    private _messages: any[] = [];\n    public get messages() {\n        //TODO : check if the store is ready\n        return this._messages;\n    }\n\n    public get model() {\n        return this.llmInference.model;\n    }\n    /**\n     *\n     * @param source a messages[] object, or smyth file system uri (smythfs://...)\n     */\n    constructor(private llmInference, _systemPrompt: string = '', /*private _messages: any[] = [],*/ llmContextStore?: ILLMContextStore) {\n        this._systemPrompt = _systemPrompt;\n\n        //TODO:allow configuring a storage service\n        if (llmContextStore) {\n            this._llmContextStore = llmContextStore;\n            this._llmContextStore.load().then((messages) => {\n                this._messages = messages;\n            });\n        }\n    }\n\n    private push(...message: any[]) {\n        this._messages.push(...message);\n        //TODO: persist to storage\n        if (this._llmContextStore) {\n            this._llmContextStore.save(this._messages);\n        }\n    }\n    public addUserMessage(content: string, message_id: string) {\n        this.push({ role: 'user', content, __smyth_data__: { message_id } });\n    }\n    public addAssistantMessage(content: string, message_id: string) {\n        this.push({ role: 'assistant', content, __smyth_data__: { message_id } });\n    }\n    public addToolMessage(messageBlock: any, toolsData: any, message_id: string) {\n        this.push({ messageBlock, toolsData, __smyth_data__: { message_id } });\n    }\n\n    public async getContextWindow(maxTokens: number, maxOutputTokens: number = 256): Promise<any[]> {\n        //TODO: handle non key accounts (limit tokens)\n        // const maxModelContext = this._llmHelper?.modelInfo?.keyOptions?.tokens || this._llmHelper?.modelInfo?.tokens || 256;\n\n        //#region get max model context\n        let maxModelContext;\n        const isStandardLLM = LLMRegistry.isStandardLLM(this.model);\n\n        if (isStandardLLM) {\n            maxModelContext = LLMRegistry.getMaxContextTokens(this.model, true); // we just provide true for hasAPIKey to get the original max context\n        } else {\n            const customLLMRegistry = await CustomLLMRegistry.getInstance(this.model);\n            maxModelContext = customLLMRegistry.getMaxContextTokens(this.model);\n        }\n        //#endregion get max model context\n\n        let maxInputContext = Math.min(maxTokens, maxModelContext);\n\n        if (maxInputContext + maxOutputTokens > maxModelContext) {\n            maxInputContext -= maxInputContext + maxOutputTokens - maxModelContext;\n        }\n\n        let messages = [];\n\n        const systemMessage = { role: 'system', content: this._systemPrompt };\n        //loop through messages from last to first and use encodeChat to calculate token lengths\n\n        let tokens = encodeChat([systemMessage as ChatMessage], 'gpt-4o').length;\n        for (let i = this._messages.length - 1; i >= 0; i--) {\n            // internal_messages are smythOS specific intermediate formats that enable us to store certain data and only convert them when needed\n            let internal_message: any;\n\n            //parse specific tools messages\n            if (this._messages[i]?.messageBlock && this._messages[i]?.toolsData) {\n                internal_message = this.llmInference.connector\n                    .transformToolMessageBlocks({\n                        messageBlock: this._messages[i]?.messageBlock,\n                        toolsData: this._messages[i]?.toolsData,\n                    })\n                    .reverse(); //need to reverse because we are iterating from last to first\n            } else {\n                internal_message = [this._messages[i] as ChatMessage];\n            }\n\n            for (let message of internal_message) {\n                //skip system messages because we will add our own\n\n                if (message.role === 'system') continue;\n\n                //skip empty messages\n                if (!message.content) {\n                    //FIXME: tool call messages does not have a content but have a tool field do we need to count them as tokens ?\n                    messages.unshift(message);\n                    continue;\n                }\n\n                delete message['__smyth_data__']; //remove smyth data entry, this entry may hold smythOS specific data\n\n                const textContent = typeof message.content === 'string' ? message.content : JSON.stringify(message.content);\n                const encoded = encode(textContent);\n                tokens += encoded.length;\n                if (tokens > maxInputContext) {\n                    if (typeof message.content !== 'string') {\n                        //FIXME: handle this case for object contents (used by Anthropic for tool calls for example)\n                        break;\n                    }\n                    //handle context window overflow\n                    //FIXME: the logic here is weak, we need a better one\n                    const diff = tokens - maxInputContext;\n                    const excessPercentage = diff / encoded.length;\n\n                    //truncate message content\n                    //const textContent = typeof message.content === 'string' ? message.content : JSON.stringify(message.content);\n\n                    message.content = message.content.slice(0, Math.floor(message.content.length * (1 - excessPercentage)) - 200);\n                    message.content += '...\\n\\nWARNING : The context window has been truncated to fit the maximum token limit.';\n\n                    tokens -= encoded.length;\n                    tokens += encodeChat([message], 'gpt-4').length;\n                    //break;\n                }\n                messages.unshift(message);\n            }\n        }\n        //add system message as first message in the context window\n        messages.unshift(systemMessage);\n\n        return messages;\n    }\n}\n","import axios from 'axios';\nimport yaml from 'js-yaml';\n\nimport { REQUEST_METHODS } from '../constants';\n\n// * We need a couple of packages to resolve references in the OpenAPI specification\n//FIXME : YAML support temporarly disabled to allow executable packaging\n//import SwaggerParser from '@apidevtools/swagger-parser';\n//import $RefParser from '@apidevtools/json-schema-ref-parser';\n//import { JSONSchema } from '@apidevtools/json-schema-ref-parser/dist/lib/types';\n\n//const swaggerParser = new SwaggerParser();\n\ntype JSONSchema = Record<string, any>;\n\n/**\n * Utility function to resolve $ref values within a schema.\n * @param schema The schema containing potential $ref values.\n * @param root The root schema for reference resolution.\n * @returns The dereferenced schema.\n */\nconst dereferenceSchema = async (schema: any, root: any = schema): Promise<any> => {\n    if (typeof schema !== 'object' || schema === null) {\n        return schema;\n    }\n\n    if (schema.$ref) {\n        const ref = schema.$ref;\n        const path = ref.replace(/^#\\//, '').split('/'); // Remove the initial '#/' and split the path\n        let resolved = root;\n        for (const segment of path) {\n            if (resolved[segment] === undefined) {\n                throw new Error(`Could not resolve $ref: ${ref}`);\n            }\n            resolved = resolved[segment];\n        }\n        return dereferenceSchema(resolved, root); // Recursively dereference\n    }\n\n    // Recursively resolve all properties and items\n    if (Array.isArray(schema)) {\n        return Promise.all(schema.map((item) => dereferenceSchema(item, root)));\n    }\n\n    const result: any = {};\n    for (const key of Object.keys(schema)) {\n        result[key] = await dereferenceSchema(schema[key], root);\n    }\n    return result;\n};\n\nexport class OpenAPIParser {\n    static mapReqMethods(paths: Array<Record<string, any>>): Map<string, any> {\n        const methods = new Map();\n\n        for (const path in paths) {\n            const pathData = paths[path];\n\n            for (const method in pathData) {\n                const data = pathData[method];\n\n                if (REQUEST_METHODS.includes(method.toUpperCase())) {\n                    methods.set(data?.operationId, method);\n                }\n            }\n        }\n\n        return methods;\n    }\n    static mapEndpoints(paths: Array<Record<string, any>>): Map<string, any> {\n        const operationIds = new Map();\n\n        for (const path in paths) {\n            const pathData = paths[path];\n\n            // it's possible we have multiple methods for a single path\n            for (const method in pathData) {\n                const data = pathData[method];\n\n                if (REQUEST_METHODS.includes(method.toUpperCase())) {\n                    operationIds.set(data?.operationId, path);\n                }\n            }\n        }\n\n        return operationIds;\n    }\n\n    // static async yamlToJson(yamlData: string): Promise<JSONSchema> {\n    //     const data = yaml.load(yamlData);\n    //     //FIXME : YAML support temporarly disabled to allow executable packaging\n    //     const schema = await $RefParser.dereference(data);\n    //     //const schema: any = {};\n\n    //     return schema;\n    // }\n\n    static async yamlToJson(yamlData: string): Promise<JSONSchema> {\n        const data = yaml.load(yamlData);\n        const schema = await dereferenceSchema(data);\n        return schema;\n    }\n\n    // static async getJson(data: string | Record<string, any>): Promise<Record<string, any>> {\n    //     try {\n    //         let _data = data;\n    //         if (typeof data === 'string') {\n    //             _data = JSON.parse(_data as string);\n    //         }\n    //         //FIXME : YAML support temporarly disabled to allow executable packaging\n    //         const result = swaggerParser.dereference(_data as any);\n    //         //const result: any = {};\n    //         return result;\n    //     } catch (error) {\n    //         try {\n    //             return OpenAPIParser.yamlToJson(data as string);\n    //         } catch (error) {\n    //             throw new Error('Invalid OpenAPI specification data format');\n    //         }\n    //     }\n    // }\n\n    static async getJson(data: string | Record<string, any>): Promise<Record<string, any>> {\n        try {\n            let parsedData = data;\n            if (typeof data === 'string') {\n                parsedData = JSON.parse(data);\n            }\n\n            return await dereferenceSchema(parsedData);\n        } catch (error) {\n            try {\n                // Fallback to handle YAML data\n                return await OpenAPIParser.yamlToJson(data as string);\n            } catch (innerError) {\n                throw new Error('Invalid OpenAPI specification or JSON data format');\n            }\n        }\n    }\n    static async getJsonFromUrl(url: string): Promise<Record<string, any>> {\n        const response = await axios.get(url);\n        const data = response.data;\n\n        return OpenAPIParser.getJson(data);\n    }\n\n    static isValidOpenAPI(data: Record<string, any>): boolean {\n        return data?.openapi && data?.paths && data?.servers;\n    }\n}\n","import { AgentProcess } from '@sre/Core/AgentProcess.helper';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { LLMInference } from '@sre/LLMManager/LLM.inference';\nimport { LLMContext } from '@sre/MemoryManager/LLMContext';\nimport { TAgentProcessParams } from '@sre/types/Agent.types';\nimport { ILLMContextStore, ToolData } from '@sre/types/LLM.types';\nimport { isUrl } from '@sre/utils/data.utils';\nimport { processWithConcurrencyLimit, uid } from '@sre/utils/general.utils';\nimport axios, { AxiosRequestConfig } from 'axios';\nimport EventEmitter from 'events';\nimport { JSONContent } from './JsonContent.helper';\nimport { OpenAPIParser } from './OpenApiParser.helper';\nimport { Match, TemplateString } from './TemplateString.helper';\n\nconst console = Logger('ConversationHelper');\ntype FunctionDeclaration = {\n    name: string;\n    description: string;\n    properties: Record<string, any>;\n    requiredFields: string[];\n};\ntype ToolParams = {\n    type: string;\n    endpoint: string;\n    args: Record<string, any>;\n    method: string;\n    baseUrl: string;\n    headers?: Record<string, string>;\n};\n\n//TODO: handle authentication\nexport class Conversation extends EventEmitter {\n    private _agentId: string = '';\n    private _systemPrompt;\n    private userDefinedSystemPrompt: string = '';\n    public toolChoice: string = 'auto';\n    public get systemPrompt() {\n        return this._systemPrompt;\n    }\n    public set systemPrompt(systemPrompt) {\n        this._systemPrompt = systemPrompt;\n        if (this._context) this._context.systemPrompt = systemPrompt;\n    }\n    public assistantName;\n\n    private _reqMethods;\n    private _toolsConfig;\n    private _endpoints;\n    private _baseUrl;\n\n    private _status = '';\n    private _currentWaitPromise;\n\n    private _llmContextStore: ILLMContextStore;\n    private _context: LLMContext;\n    private _maxContextSize = 1024 * 16;\n    private _maxOutputTokens = 1024;\n\n    public get context() {\n        return this._context;\n    }\n\n    private _lastError;\n    private _spec;\n    private _customToolsDeclarations: FunctionDeclaration[] = [];\n    private _customToolsHandlers: Record<string, (args: Record<string, any>) => Promise<any>> = {};\n    public stop = false;\n    public set spec(specSource) {\n        this.ready.then(() => {\n            this._status = '';\n            this.loadSpecFromSource(specSource).then((spec) => {\n                if (!spec) {\n                    this._status = 'error';\n                    this.emit('error', 'Invalid OpenAPI specification data format');\n                    throw new Error('Invalid OpenAPI specification data format');\n                }\n                this._spec = spec;\n                this.updateModel(this._model);\n                this._status = 'ready';\n            });\n        });\n    }\n\n    public set model(model: string) {\n        this.ready.then(() => {\n            this._status = '';\n            this.updateModel(model);\n            this._status = 'ready';\n        });\n    }\n    public get model() {\n        return this._model;\n    }\n    constructor(\n        private _model: string,\n        private _specSource?: string | Record<string, any>,\n        private _settings?: {\n            maxContextSize?: number;\n            maxOutputTokens?: number;\n            systemPrompt?: string;\n            toolChoice?: string;\n            store?: ILLMContextStore;\n            experimentalCache?: boolean;\n            toolsStrategy?: (toolsConfig) => any;\n        }\n    ) {\n        //TODO: handle loading previous session (messages)\n        super();\n\n        //this event listener avoids unhandled errors that can cause crashes\n        this.on('error', (error) => {\n            this._lastError = error;\n            console.warn('Conversation Error: ', error?.message);\n        });\n        if (_settings?.maxContextSize) this._maxContextSize = _settings.maxContextSize;\n        if (_settings?.maxOutputTokens) this._maxOutputTokens = _settings.maxOutputTokens;\n        if (_settings?.systemPrompt) {\n            this.userDefinedSystemPrompt = _settings.systemPrompt;\n        }\n        if (_settings?.toolChoice) {\n            this.toolChoice = _settings.toolChoice;\n        }\n\n        if (_specSource) {\n            this.loadSpecFromSource(_specSource)\n                .then((spec) => {\n                    if (!spec) {\n                        this._status = 'error';\n                        this.emit('error', 'Unable to parse OpenAPI specifications');\n                        throw new Error('Invalid OpenAPI specification data format');\n                    }\n                    this._spec = spec;\n\n                    this.updateModel(this._model);\n                    this._status = 'ready';\n                })\n                .catch((error) => {\n                    this._status = 'error';\n                    this.emit('error', error);\n                });\n        } else {\n            this.updateModel(this._model);\n            this._status = 'ready';\n        }\n    }\n\n    public get ready() {\n        if (this._currentWaitPromise) return this._currentWaitPromise;\n        this._currentWaitPromise = new Promise((resolve, reject) => {\n            if (this._status) {\n                return resolve(this._status);\n            }\n\n            const maxWaitTime = 30000;\n            let waitTime = 0;\n            const interval = 100;\n\n            const wait = setInterval(() => {\n                if (this._status) {\n                    clearInterval(wait);\n                    return resolve(this._status);\n                } else {\n                    waitTime += interval;\n                    if (waitTime >= maxWaitTime) {\n                        clearInterval(wait);\n                        return reject('Timeout: Failed to prepare data');\n                    }\n                }\n            }, interval);\n        });\n\n        return this._currentWaitPromise;\n    }\n\n    //TODO : handle attachments\n    public async prompt(message?: string, toolHeaders = {}) {\n        if (this.stop) return;\n        await this.ready;\n\n        const reqMethods = this._reqMethods;\n        const toolsConfig = this._toolsConfig;\n        const endpoints = this._endpoints;\n        const baseUrl = this._baseUrl;\n        const message_id = 'msg_' + uid();\n\n        /* ==================== STEP ENTRY ==================== */\n        console.debug('Request to LLM with the given model, messages and functions properties.', {\n            model: this.model,\n            message,\n            toolsConfig,\n        });\n        /* ==================== STEP ENTRY ==================== */\n        const llmInference: LLMInference = await LLMInference.getInstance(this.model);\n\n        if (message) this._context.addUserMessage(message, message_id);\n\n        const contextWindow = await this._context.getContextWindow(this._maxContextSize, this._maxOutputTokens);\n\n        const { data: llmResponse } = await llmInference\n            .toolRequest(\n                {\n                    model: this.model,\n                    messages: contextWindow,\n                    toolsConfig: this._settings?.toolsStrategy ? this._settings.toolsStrategy(toolsConfig) : toolsConfig,\n                    maxTokens: this._maxOutputTokens,\n                },\n                this._agentId\n            )\n            .catch((error: any) => {\n                throw new Error(\n                    '[LLM Request Error]\\n' +\n                        JSON.stringify({\n                            code: error?.name || 'LLMRequestFailed',\n                            message: error?.message || 'Something went wrong while calling LLM.',\n                        })\n                );\n            });\n\n        // useTool = true means we need to use it\n        if (llmResponse?.useTool) {\n            /* ==================== STEP ENTRY ==================== */\n            console.debug({\n                type: 'ToolsData',\n                message: 'Tool(s) is available for use.',\n                toolsData: llmResponse?.toolsData,\n            });\n            /* ==================== STEP ENTRY ==================== */\n\n            const toolsData: ToolData[] = [];\n\n            for (const tool of llmResponse?.toolsData) {\n                const endpoint = endpoints?.get(tool?.name) || tool?.name;\n                // Sometimes we have object response from the LLM such as Anthropic\n                const parsedArgs = JSONContent(tool?.arguments).tryParse();\n                let args = typeof tool?.arguments === 'string' ? parsedArgs || {} : tool?.arguments;\n\n                if (args?.error) {\n                    throw new Error('[Tool] Arguments Parsing Error\\n' + JSON.stringify({ message: args?.error }));\n                }\n\n                const toolArgs = {\n                    type: tool?.type,\n                    method: reqMethods?.get(tool?.name),\n                    endpoint,\n                    args,\n                    baseUrl,\n                    headers: toolHeaders,\n                };\n\n                /* ==================== STEP ENTRY ==================== */\n                console.debug({\n                    type: 'UseTool',\n                    message: 'As LLM returned a tool to use, so use it with the provided arguments.',\n                    plugin_url: { baseUrl, endpoint, args },\n                    arguments: args,\n                });\n                /* ==================== STEP ENTRY ==================== */\n\n                this.emit('beforeToolCall', { tool, args });\n                //TODO: Should we run these tools in parallel?\n                let { data: functionResponse, error } = await this.useTool(toolArgs);\n\n                if (error) {\n                    this.emit('toolCallError', toolArgs, error);\n                    functionResponse = typeof error === 'object' && typeof error !== null ? JSON.stringify(error) : error;\n                }\n\n                functionResponse =\n                    typeof functionResponse === 'object' && typeof functionResponse !== null ? JSON.stringify(functionResponse) : functionResponse;\n\n                /* ==================== STEP ENTRY ==================== */\n                console.debug({\n                    type: 'ToolResult',\n                    message: 'Result from the tool',\n                    response: functionResponse,\n                });\n                /* ==================== STEP ENTRY ==================== */\n\n                this.emit('afterToolCall', toolArgs, functionResponse);\n                toolsData.push({ ...tool, result: functionResponse });\n            }\n\n            // const messagesWithToolResult = llmInference.connector.transformToolMessageBlocks({ messageBlock: llmResponse?.message, toolsData });\n\n            // this._context.push(...messagesWithToolResult);\n\n            //this._context.push({ messageBlock: llmResponse?.message, toolsData });\n            this._context.addToolMessage(llmResponse?.message, toolsData, message_id);\n\n            return this.prompt(null, toolHeaders);\n        }\n\n        //this._context.push(llmResponse?.message);\n        this._context.addAssistantMessage(llmResponse?.message?.content, message_id);\n\n        let content = JSONContent(llmResponse?.content).tryParse();\n\n        /* ==================== STEP ENTRY ==================== */\n        console.debug({\n            type: 'FinalResult',\n            message: 'Here is the final result after processing all the tools and LLM response.',\n            response: content,\n        });\n        /* ==================== STEP ENTRY ==================== */\n\n        return content;\n    }\n\n    //TODO : handle attachments\n    public async streamPrompt(message?: string, toolHeaders = {}, concurrentToolCalls = 4) {\n        if (this.stop) return;\n        await this.ready;\n\n        //let promises = [];\n        let _content = '';\n        const reqMethods = this._reqMethods;\n        const toolsConfig = this._toolsConfig;\n        const endpoints = this._endpoints;\n        const baseUrl = this._baseUrl;\n        const message_id = 'msg_' + uid();\n\n        /* ==================== STEP ENTRY ==================== */\n        // console.debug('Request to LLM with the given model, messages and functions properties.', {\n        //     model: this.model,\n        //     message,\n        //     toolsConfig,\n        // });\n        /* ==================== STEP ENTRY ==================== */\n        const llmInference: LLMInference = await LLMInference.getInstance(this.model);\n\n        if (message) this._context.addUserMessage(message, message_id);\n\n        const contextWindow = await this._context.getContextWindow(this._maxContextSize, this._maxOutputTokens);\n\n        const eventEmitter: any = await llmInference\n            .streamRequest(\n                {\n                    model: this.model,\n                    messages: contextWindow,\n                    toolsConfig: this._settings?.toolsStrategy ? this._settings.toolsStrategy(toolsConfig) : toolsConfig,\n                    maxTokens: this._maxOutputTokens,\n                    cache: this._settings?.experimentalCache,\n                },\n                this._agentId\n            )\n            .catch((error) => {\n                console.error('Error on streamRequest: ', error);\n            });\n\n        if (!eventEmitter || eventEmitter.error) {\n            throw new Error('[LLM Request Error]');\n        }\n\n        if (message) this.emit('start');\n        eventEmitter.on('data', (data) => {\n            this.emit('data', data);\n        });\n\n        eventEmitter.on('content', (content) => {\n            _content += content;\n            this.emit('content', content);\n        });\n\n        let toolsPromise = new Promise((resolve, reject) => {\n            let hasTools = false;\n            let hasError = false;\n            eventEmitter.on('error', (error) => {\n                hasError = true;\n                reject(error);\n            });\n\n            eventEmitter.on('toolsData', async (toolsData) => {\n                hasTools = true;\n                let llmMessage: any = {\n                    role: 'assistant',\n                    content: _content,\n                    tool_calls: [],\n                };\n                llmMessage.tool_calls = toolsData.map((tool) => {\n                    return {\n                        id: tool.id,\n                        type: tool.type,\n                        function: {\n                            name: tool.name,\n                            arguments: tool.arguments,\n                        },\n                    };\n                });\n\n                //if (llmMessage.tool_calls?.length <= 0) return;\n\n                this.emit('toolInfo', toolsData); // replaces onFunctionCallResponse in legacy code\n\n                const toolProcessingTasks = toolsData.map(\n                    (tool: { index: number; name: string; type: string; arguments: Record<string, any> }) => async () => {\n                        const endpoint = endpoints?.get(tool?.name) || tool?.name;\n                        // Sometimes we have object response from the LLM such as Anthropic\n\n                        let args = typeof tool?.arguments === 'string' ? JSONContent(tool?.arguments).tryParse() || {} : tool?.arguments;\n\n                        if (args?.error) {\n                            throw new Error('[Tool] Arguments Parsing Error\\n' + JSON.stringify({ message: args?.error }));\n                        }\n\n                        //await beforeFunctionCall(llmMessage, toolsData[tool.index]);\n                        this.emit('beforeToolCall', { tool, args });\n\n                        const toolArgs = {\n                            type: tool?.type,\n                            method: reqMethods?.get(tool?.name),\n                            endpoint,\n                            args,\n                            baseUrl,\n                            headers: toolHeaders,\n                        };\n\n                        let { data: functionResponse, error } = await this.useTool(toolArgs);\n\n                        if (error) {\n                            functionResponse = typeof error === 'object' && typeof error !== null ? JSON.stringify(error) : error;\n                        }\n\n                        functionResponse =\n                            typeof functionResponse === 'object' && typeof functionResponse !== null\n                                ? JSON.stringify(functionResponse)\n                                : functionResponse;\n\n                        //await afterFunctionCall(functionResponse, toolsData[tool.index]);\n                        this.emit('afterToolCall', { tool, args }, functionResponse);\n\n                        return { ...tool, result: functionResponse };\n                    }\n                );\n\n                const processedToolsData = await processWithConcurrencyLimit<ToolData>(toolProcessingTasks, concurrentToolCalls);\n\n                // const messagesWithToolResult = llmInference.connector.transformToolMessageBlocks({\n                //     messageBlock: llmMessage,\n                //     toolsData: processedToolsData,\n                // });\n\n                // this._context.push(...messagesWithToolResult);\n                // this._context.push({\n                //     //store raw tool call data, we'll convert it when reading the context window\n                //     messageBlock: llmMessage,\n                //     toolsData: processedToolsData,\n                // });\n\n                this._context.addToolMessage(llmMessage, processedToolsData, message_id);\n\n                this.streamPrompt(null, toolHeaders, concurrentToolCalls).then(resolve).catch(reject);\n\n                //const result = await resolve(await this.streamPrompt(null, toolHeaders, concurrentToolCalls));\n                //console.log('Result after tool call: ', result);\n            });\n\n            eventEmitter.on('end', async (toolsData, usage_data) => {\n                if (usage_data) {\n                    //FIXME : normalize the usage data format\n                    this.emit('usage', usage_data);\n                }\n                if (hasError) return;\n\n                if (!hasTools) {\n                    //console.log(' ===> resolved content no tool', _content);\n                    //this._context.push({ role: 'assistant', content: _content });\n                    this._context.addAssistantMessage(_content, message_id);\n                    resolve(''); //the content were already emitted through 'content' event\n                }\n            });\n        });\n\n        const toolsContent = await toolsPromise.catch((error) => {\n            console.error('Error in toolsPromise: ', error);\n            //this.emit('error', error);\n            this.emit('error', error);\n            return '';\n        });\n        _content += toolsContent;\n        let content = JSONContent(_content).tryParse();\n\n        // let streamPromise = new Promise((resolve, reject) => {\n        //     eventEmitter.on('end', async () => {\n        //         if (toolsPromise) await toolsPromise;\n\n        //         let content = JSONContent(_content).tryParse();\n        //         resolve({ content });\n        //     });\n        // });\n\n        // promises.push(streamPromise);\n\n        //await Promise.all(promises);\n        //return content;\n\n        if (message) {\n            //console.log('main content', content);\n            //this._context.push({ role: 'assistant', content: content });\n            this.emit('end');\n        } else {\n            //console.log('tool content', content);\n        }\n\n        return content;\n    }\n\n    private resolveToolEndpoint(baseUrl: string, method: string, endpoint: string, params: Record<string, any>): string {\n        //handle query params\n        let templateParams = {};\n        if (params) {\n            const parameters = this._spec?.paths?.[endpoint]?.[method.toLowerCase()]?.parameters || [];\n            for (let p of parameters) {\n                if (p.in === 'path') {\n                    templateParams[p.name] = params[p.name] || '';\n                    delete params[p.name];\n                }\n            }\n        }\n        const parsedEndpoint = TemplateString(endpoint).parse(templateParams, Match.singleCurly).clean().result;\n\n        // Create a new URL object using the base URL and endpoint\n        const url = new URL(parsedEndpoint, baseUrl);\n\n        // Iterate over the params object and append each key/value pair to the URL search parameters\n        Object.keys(params).forEach((key) => {\n            url.searchParams.append(key, params[key]);\n        });\n\n        // Return the full URL as a string\n        return url.toString();\n    }\n\n    private async useTool(params: ToolParams): Promise<{\n        data: any;\n        error;\n    }> {\n        const { type, endpoint, args, method, baseUrl, headers = {} } = params;\n\n        if (type === 'function') {\n            const toolHandler = this._customToolsHandlers[endpoint];\n            if (toolHandler) {\n                try {\n                    const result = await toolHandler(args);\n                    return { data: result, error: null };\n                } catch (error) {\n                    return { data: null, error: error?.message || 'Custom tool handler failed' };\n                }\n            }\n            try {\n                const url = this.resolveToolEndpoint(baseUrl, method, endpoint, method == 'get' ? args : {});\n\n                const reqConfig: AxiosRequestConfig = {\n                    method,\n                    url,\n                    headers: {\n                        ...headers,\n                    },\n                };\n\n                if (method !== 'get') {\n                    if (Object.keys(args).length) {\n                        reqConfig.data = args;\n                    }\n                    //(reqConfig.headers as Record<string, unknown>)['Content-Type'] = 'application/json';\n                    reqConfig.headers['Content-Type'] = 'application/json';\n                }\n\n                console.debug('Calling tool: ', reqConfig);\n\n                //TODO : implement a timeout for the tool call\n                if (reqConfig.url.includes('localhost')) {\n                    //if it's a local agent, invoke it directly\n                    const response = await AgentProcess.load(reqConfig.headers['X-AGENT-ID']).run(reqConfig as TAgentProcessParams);\n                    return { data: response.data, error: null };\n                } else {\n                    //if it's a remote agent, call the API via HTTP\n                    const response = await axios.request(reqConfig);\n\n                    return { data: response.data, error: null };\n                }\n            } catch (error: any) {\n                console.warn('Failed to call Tool: ', baseUrl, endpoint);\n                console.warn('  ====>', error);\n                return { data: null, error: error?.response?.data || error?.message };\n            }\n        }\n\n        return { data: null, error: `'${type}' tool type not supported at the moment` };\n    }\n\n    public async addTool(tool: {\n        name: string;\n        description: string;\n        arguments: Record<string, any>;\n        handler: (args: Record<string, any>) => Promise<any>;\n    }) {\n        const requiredFields = Object.values(tool.arguments)\n            .map((arg) => (arg.required ? arg.name : null))\n            .filter((arg) => arg !== null);\n\n        const properties = {};\n        for (let entry in tool.arguments) {\n            properties[entry] = {\n                type: typeof tool.arguments[entry],\n                description: tool.arguments[entry].description,\n            };\n        }\n        const toolDefinition = {\n            name: tool.name,\n            description: tool.description,\n            properties,\n            requiredFields,\n        };\n        this._customToolsDeclarations.push(toolDefinition);\n        this._customToolsHandlers[tool.name] = tool.handler;\n\n        const llmInference: LLMInference = await LLMInference.getInstance(this.model);\n        const toolsConfig: any = llmInference.connector.formatToolsConfig({\n            type: 'function',\n            toolDefinitions: [toolDefinition],\n            toolChoice: this.toolChoice,\n        });\n\n        if (this._toolsConfig) this._toolsConfig.tools.push(...toolsConfig?.tools);\n        else this._toolsConfig = toolsConfig;\n    }\n    /**\n     * updates LLM model, if spec is available, it will update the tools config\n     * @param model\n     */\n    // TODO [Forhad]: For now updateModel does not required await, but when we will have tools implementation in custom model then we need to await for it\n    private async updateModel(model: string) {\n        try {\n            this._model = model;\n\n            if (this._spec) {\n                this._reqMethods = OpenAPIParser.mapReqMethods(this._spec?.paths);\n                this._endpoints = OpenAPIParser.mapEndpoints(this._spec?.paths);\n                this._baseUrl = this._spec?.servers?.[0].url;\n\n                const functionDeclarations = this.getFunctionDeclarations(this._spec);\n                functionDeclarations.push(...this._customToolsDeclarations);\n                const llmInference: LLMInference = await LLMInference.getInstance(this._model);\n                this._toolsConfig = llmInference.connector.formatToolsConfig({\n                    type: 'function',\n                    toolDefinitions: functionDeclarations,\n                    toolChoice: this.toolChoice,\n                });\n\n                let messages = [];\n                if (this._context) messages = this._context.messages; // preserve messages\n\n                this._context = new LLMContext(llmInference, this.systemPrompt, this._llmContextStore);\n            } else {\n                this._toolsConfig = null;\n                this._reqMethods = null;\n                this._endpoints = null;\n                this._baseUrl = null;\n            }\n        } catch (error) {\n            this.emit('error', error);\n        }\n    }\n\n    /**\n     * this function is used to patch the spec with missing fields that are required for the tool to work\n     * @param spec\n     */\n    private patchSpec(spec: Record<string, any>) {\n        const paths = spec?.paths;\n        for (const path in paths) {\n            const pathData = paths[path];\n\n            // it's possible we have multiple methods for a single path\n            for (const key in pathData) {\n                const data = pathData[key];\n                if (!data?.operationId) {\n                    //normalize path and use it as operationId\n                    data.operationId = path.replace(/\\//g, '_').replace(/{|}/g, '').replace(/\\./g, '_');\n                }\n            }\n        }\n        return spec;\n    }\n    /**\n     * Loads OpenAPI specification from source\n     * @param specSource\n     * @returns\n     */\n    private async loadSpecFromSource(specSource: string | Record<string, any>) {\n        if (typeof specSource === 'object') {\n            //is this a valid OpenAPI spec?\n            if (OpenAPIParser.isValidOpenAPI(specSource)) return this.patchSpec(specSource);\n            //is this a valid agent data?\n            if (specSource?.behavior && specSource?.components && specSource?.connections) return await this.loadSpecFromAgent(specSource);\n            return null;\n        }\n\n        if (typeof specSource === 'string') {\n            //is this an openAPI url?\n            if (isUrl(specSource as string)) {\n                const spec = await OpenAPIParser.getJsonFromUrl(specSource as string);\n\n                if (spec.info?.description) this.systemPrompt = spec.info.description;\n\n                // we always overwrite system prompt with user defined one\n                if (this.userDefinedSystemPrompt) this.systemPrompt = this.userDefinedSystemPrompt;\n\n                if (spec.info?.title) this.assistantName = spec.info.title;\n\n                const specUrl = new URL(specSource as string);\n                const defaultBaseUrl = specUrl.origin;\n\n                if (!spec?.servers) spec.servers = [{ url: defaultBaseUrl }];\n                if (spec.servers?.length == 0) spec.servers = [{ url: defaultBaseUrl }];\n\n                if (this.assistantName) {\n                    this.systemPrompt = `Assistant Name : ${this.assistantName}\\n\\n${this.systemPrompt}`;\n                }\n\n                this._agentId = specUrl.hostname; //just set an agent ID in order to identify the agent in SRE //FIXME: maybe this requires a better solution\n                return this.patchSpec(spec);\n            }\n            //is this an agentId ?\n            const agentDataConnector = ConnectorService.getAgentDataConnector();\n            const agentId = specSource as string;\n            const agentData = await agentDataConnector.getAgentData(agentId).catch((error) => null);\n            if (!agentData) return null;\n            this._agentId = agentId;\n\n            const spec = await this.loadSpecFromAgent(agentData);\n            return spec;\n        }\n    }\n    private async loadSpecFromAgent(agentData: Record<string, any>) {\n        const agentDataConnector = ConnectorService.getAgentDataConnector();\n        this.systemPrompt = agentData?.data?.behavior || this.systemPrompt;\n\n        // we always overwrite system prompt with user defined one\n        if (this.userDefinedSystemPrompt) this.systemPrompt = this.userDefinedSystemPrompt;\n\n        this.assistantName = agentData?.data?.name || agentData?.data?.templateInfo?.name || this.assistantName;\n        if (this.assistantName) {\n            this.systemPrompt = `Assistant Name : ${this.assistantName}\\n\\n${this.systemPrompt}`;\n        }\n        const spec = await agentDataConnector.getOpenAPIJSON(agentData, 'http://localhost/', 'latest', true).catch((error) => null);\n        return this.patchSpec(spec);\n    }\n\n    /**\n     * Extracts function declarations from OpenAPI specification\n     * @param spec\n     * @returns\n     */\n    private getFunctionDeclarations(spec): FunctionDeclaration[] {\n        const paths = spec?.paths;\n        const reqMethods = OpenAPIParser.mapReqMethods(paths);\n\n        let declarations: FunctionDeclaration[] = [];\n\n        for (const path in paths) {\n            const pathData = paths[path];\n\n            // it's possible we have multiple methods for a single path\n            for (const key in pathData) {\n                const data = pathData[key];\n\n                const method = reqMethods.get(data?.operationId) || 'get';\n\n                let properties = {};\n                let requiredFields: string[] = [];\n\n                if (method.toLowerCase() === 'get') {\n                    const params = data?.parameters || [];\n                    for (const prop of params) {\n                        properties[prop.name] = {\n                            ...prop.schema,\n                            description: prop.description,\n                        };\n\n                        if (prop.required === true) {\n                            requiredFields.push(prop?.name || '');\n                        }\n                    }\n                } else {\n                    properties = data?.requestBody?.content?.['application/json']?.schema?.properties;\n                    requiredFields = data?.requestBody?.content?.['application/json']?.schema?.required;\n\n                    // Open AI doesn't support 'required' to be boolean inside property\n                    for (const prop in properties) {\n                        delete properties[prop]?.required;\n                    }\n                }\n\n                if (!properties) properties = {};\n                if (!requiredFields) requiredFields = [];\n\n                const declaration = {\n                    name: data?.operationId,\n                    description: data?.description || data?.summary || '',\n                    properties,\n                    requiredFields,\n                };\n                declarations.push(declaration);\n            }\n        }\n\n        return declarations;\n    }\n}\n","import Joi from 'joi';\n\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { Conversation } from '@sre/helpers/Conversation.helper';\nimport Component from './Component.class';\n\nexport default class AgentPlugin extends Component {\n    protected configSchema = Joi.object({\n        agentId: Joi.string().max(200).required(),\n        openAiModel: Joi.string().max(200).required(), // for backward compatibility\n        model: Joi.string().max(200).required(),\n        descForModel: Joi.string().max(5000).allow('').label('Description for Model'),\n        id: Joi.string().max(200),\n        name: Joi.string().max(500),\n        desc: Joi.string().max(5000).allow('').label('Description'),\n        logoUrl: Joi.string().max(8192).allow(''),\n        version: Joi.string().max(100).allow(''),\n        domain: Joi.string().max(253).allow(''),\n    });\n\n    constructor() {\n        super();\n    }\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n\n        logger.debug(`=== Agent Plugin Log ===`);\n\n        try {\n            const subAgentId = config.data?.agentId;\n\n            if (!subAgentId) {\n                return { _error: 'Agent Component ID is required!', _debug: logger.output };\n            }\n\n            //tag this request to tell the nested agent that the call comes from internal agent\n            const reqTag = agent.agentRuntime?.reqTag;\n\n            const model = config?.data?.model || config?.data?.openAiModel;\n            const descForModel = TemplateString(config?.data?.descForModel).parse(input).result;\n            const prompt = typeof input?.Prompt === 'string' ? input?.Prompt : JSON.stringify(input?.Prompt);\n\n            const agentDataConnector = ConnectorService.getAgentDataConnector();\n\n            //let subAgentDomain = await isDeployed(subAgentId);\n            // when domain found for sub agent, that means it's deployed\n            const isSubAgentDeployed = await agentDataConnector.isDeployed(subAgentId);\n\n            let version = config.data?.version || '';\n\n            logger.debug('Version: ', version);\n\n            if (version === 'same-as-parent') {\n                const isParentAgentDeployed = await agentDataConnector.isDeployed(agent?.id);\n\n                if (isParentAgentDeployed) {\n                    if (isSubAgentDeployed) {\n                        version = 'latest';\n                    } else {\n                        return {\n                            _error: `Call failed, Agent '${config.data?.name}' (${subAgentId}) is not deployed. Please deploy the agent and try again.`,\n                            _debug: logger.output,\n                        };\n                    }\n                } else {\n                    version = ''; // empty string ('') means latest dev version\n                }\n            } else if (version === 'dev-latest') {\n                version = '';\n            } else if (version === 'prod-latest') {\n                if (isSubAgentDeployed) {\n                    version = 'latest';\n                } else {\n                    return {\n                        _error: `Call failed, Agent '${config.data?.name}' (${subAgentId}) is not deployed. Please deploy the agent and try again.`,\n                        _debug: logger.output,\n                    };\n                }\n            }\n\n            const conv = new Conversation(model, subAgentId, { systemPrompt: descForModel });\n\n            const result = await conv.prompt(prompt, {\n                'X-AGENT-ID': subAgentId,\n                'X-AGENT-VERSION': version,\n                'X-REQUEST-TAG': reqTag, //request Tag identifies the request and tells the called agent that the call comes from internal agent\n                'x-caller-session-id': agent.callerSessionId,\n            });\n\n            logger.debug(`Response:\\n`, result, '\\n');\n\n            return { Response: result, _debug: logger.output };\n        } catch (error: any) {\n            console.error('Error on running Agent Component: ', error);\n            return { _error: `Error on running Agent Component!\\n${error?.message || JSON.stringify(error)}`, _debug: logger.output };\n        }\n    }\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { CacheConnector } from '@sre/MemoryManager/Cache.service';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { DEFAULT_MAX_TOKENS_FOR_LLM } from '@sre/constants';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { encode } from 'gpt-tokenizer';\nimport Component from './Component.class';\nimport { JSONContent } from '@sre/helpers/JsonContent.helper';\nimport { LLMInference } from '@sre/LLMManager/LLM.inference';\nimport { LLMRegistry } from '@sre/LLMManager/LLMRegistry.class';\nimport { CustomLLMRegistry } from '@sre/LLMManager/CustomLLMRegistry.class';\nimport { TLLMMessageRole } from '@sre/types/LLM.types';\nimport { VaultHelper } from '@sre/Security/Vault.service/Vault.helper';\n\n//const sessions = {};\nlet cacheConnector: CacheConnector;\nfunction getCacheConnector() {\n    if (!cacheConnector) {\n        cacheConnector = ConnectorService.getCacheConnector();\n    }\n    return cacheConnector;\n}\n\nasync function saveMessagesToSession(agentId, userId, conversationId, messages, ttl?) {\n    if (!userId && !conversationId) return;\n    const cacheConnector = getCacheConnector();\n    const conv_uid = `${agentId}:conv-u${userId}-c${conversationId}`;\n\n    cacheConnector.user(AccessCandidate.agent(agentId)).set(conv_uid, JSON.stringify(messages), null, null, ttl);\n}\n\nasync function readMessagesFromSession(agentId, userId, conversationId, maxTokens = DEFAULT_MAX_TOKENS_FOR_LLM) {\n    if (!userId && !conversationId) return [];\n    const cacheConnector = getCacheConnector();\n\n    const conv_uid = `${agentId}:conv-u${userId}-c${conversationId}`;\n    //read the last messages from a given session and ensure that the total chat tokens are within the limit\n    //start from the last message and keep adding messages until the total tokens exceed the limit\n    //if (!sessions[agentId]) return [];\n    //if (!sessions[agentId][conv_uid]) return [];\n\n    const sessionData = await cacheConnector.user(AccessCandidate.agent(agentId))?.get(conv_uid);\n\n    const messages = sessionData ? JSONContent(sessionData).tryParse() : [];\n    //const messages = sessions[agentId][conv_uid].messages;\n\n    const filteredMessages: any[] = [];\n\n    let tokens = 0;\n    if (messages[0]?.role == 'system') {\n        const encoded = encode(messages[0]?.content);\n        const messageTokens = encoded.length + 3;\n        tokens += messageTokens;\n    }\n\n    for (let i = messages.length - 1; i >= 0; i--) {\n        if (messages[i].role == 'system') continue;\n        const message = messages[i];\n        const encoded = encode(message?.content);\n        const messageTokens = encoded.length + 3;\n        if (tokens + messageTokens > maxTokens) break;\n        filteredMessages.unshift(message);\n        tokens += messageTokens;\n    }\n\n    if (messages[0]?.role == 'system') filteredMessages.unshift(messages[0]);\n\n    return filteredMessages;\n}\n\n//TODO : update this implementation to use ConversationManager\n//        This will allow better context management and support for tool calls\nexport default class LLMAssistant extends Component {\n    protected configSchema = Joi.object({\n        model: Joi.string().max(200).required(),\n        behavior: Joi.string().max(30000).allow('').label('Behavior'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            logger.debug('== LLM Assistant Log ==\\n');\n\n            const model: string = config.data.model || 'echo';\n            const ttl = config.data.ttl || undefined;\n            let teamId = agent?.teamId;\n\n            const llmInference: LLMInference = await LLMInference.getInstance(model, teamId);\n            // if the llm is undefined, then it means we removed the model from our system\n            if (!llmInference.connector) {\n                return {\n                    _error: `The model '${model}' is not available. Please try a different one.`,\n                    _debug: logger.output,\n                };\n            }\n\n            logger.debug(` Model : ${model}`);\n\n            const userInput = input.UserInput;\n            const userId = input.UserId;\n            const conversationId = input.ConversationId;\n\n            let behavior = TemplateString(config.data.behavior).parse(input).result;\n            logger.debug(`[Parsed Behavior] \\n${behavior}\\n\\n`);\n\n            //#region get max tokens\n            let maxTokens = 2048;\n            const isStandardLLM = LLMRegistry.isStandardLLM(model);\n\n            if (isStandardLLM) {\n                const provider = LLMRegistry.getProvider(model);\n                const apiKey = await VaultHelper.getAgentKey(provider, agent?.id);\n                maxTokens = LLMRegistry.getMaxCompletionTokens(model, !!apiKey);\n            } else {\n                const customLLMRegistry = await CustomLLMRegistry.getInstance(teamId);\n                maxTokens = await customLLMRegistry.getMaxCompletionTokens(model);\n            }\n            //#endregion get max tokens\n\n            const messages: any[] = await readMessagesFromSession(agent.id, userId, conversationId, Math.round(maxTokens / 2));\n\n            messages.push({ role: TLLMMessageRole.User, content: userInput });\n\n            if (messages[0]?.role != TLLMMessageRole.System) {\n                messages.unshift({ role: TLLMMessageRole.System, content: behavior });\n            }\n\n            const customParams = {\n                messages,\n            };\n\n            const response: any = await llmInference.promptRequest(null, config, agent, customParams).catch((error) => ({ error: error }));\n\n            // in case we have the response but it's empty string, undefined or null\n            if (!response) {\n                return { _error: ' LLM Error = Empty Response!', _debug: logger.output };\n            }\n\n            if (response?.error) {\n                logger.error(` LLM Error=${JSON.stringify(response.error)}`);\n\n                return { Response: response?.data, _error: response?.error + ' ' + response?.details, _debug: logger.output };\n            }\n\n            messages.push({ role: 'assistant', content: response });\n            saveMessagesToSession(agent.id, userId, conversationId, messages, ttl);\n\n            const result = { Response: response };\n\n            result['_debug'] = logger.output;\n\n            return result;\n        } catch (error) {\n            return { _error: error.message, _debug: logger.output };\n        }\n    }\n}\n","import Agent from './Agent.class';\nimport AgentRequest from './AgentRequest.class';\n\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { uid } from '@sre/utils';\nconst console = Logger('ForkedAgent');\n\n/**\n * This class creates a forked agent from a parent agent branch, it allows running a sub-branch of the parent agent asynchrounously by providing a separate agent context\n * We use composition instead of inheritance to avoid circular dependencies between Agent and ForkedAgent\n */\nexport default class ForkedAgent {\n    public agent: Agent;\n    public get agentRequest() {\n        return this.agent.agentRequest;\n    }\n    public get components() {\n        return this.agent.components;\n    }\n    public get agentRuntime() {\n        return this.agent.agentRuntime;\n    }\n    public get jobID() {\n        return this.agent.jobID;\n    }\n    constructor(\n        private parent: Agent,\n        componentId: string //the component to fork from\n    ) {\n        const data = fork(this.parent.data, componentId);\n        //TODO : we need to create a default APIEndpoint bound to the root component if root component is not an APIEndpoint\n        const content = { name: this.parent.name, data, teamId: this.parent.teamId, debugSessionEnabled: false, version: this.parent.version };\n\n        const agentRequest = new AgentRequest(this.parent.agentRequest.req);\n        agentRequest.headers = []; //clear all headers from parent agent to conflict with child agent\n\n        this.agent = new Agent(this.parent.id, content, this.parent.agentSettings, agentRequest);\n        const JobID = componentId + '-' + uid();\n        this.agent.jobID = JobID;\n        //since the jobID was updated we need to create a different runtime\n        //FIXME : we need to find a way to avoid creating default runtime for forked agents, then replace it\n        //this.agent.agentRuntime = new AgentRuntime(this.agent);\n\n        //super(parent.id, content, agentRequest);\n    }\n\n    process(path: string, input: any) {\n        return this.agent.process(path, input);\n    }\n}\n\n// Helper function to clone a component and update its ID\nfunction cloneComponent(component) {\n    const newComponent = JSON.parse(JSON.stringify(component));\n    newComponent.id = component.id;\n    return newComponent;\n}\n\n// Helper function to recursively clone components and their connections\nfunction cloneRecursively(componentData, currentID, newIDMap, clonedComponents, clonedConnections) {\n    const componentToClone = componentData.components.find((c) => c.id === currentID);\n    if (!componentToClone) {\n        return;\n    }\n\n    const clonedComponent = cloneComponent(componentToClone);\n    newIDMap[currentID] = clonedComponent.id; // Map old ID to new ID\n    clonedComponents.push(clonedComponent);\n\n    // Find all outgoing connections for the current component\n    const outgoingConnections = componentData.connections.filter((conn) => conn.sourceId === currentID);\n    outgoingConnections.forEach((conn) => {\n        // Clone the connection and update the IDs\n        const clonedConnection = JSON.parse(JSON.stringify(conn));\n        clonedConnection.sourceId = clonedComponent.id;\n        if (!newIDMap[conn.targetId]) {\n            // Recursively clone the connected component if it hasn't been cloned yet\n            cloneRecursively(componentData, conn.targetId, newIDMap, clonedComponents, clonedConnections);\n        }\n        clonedConnection.targetId = newIDMap[conn.targetId];\n        clonedConnections.push(clonedConnection);\n    });\n}\n\nfunction fork(componentData, componentID) {\n    const clonedComponents: any[] = [];\n    const clonedConnections: any[] = [];\n    const newIDMap = {}; // Map to keep track of old to new ID mappings\n\n    // Start the cloning process from the specified component ID\n    cloneRecursively(componentData, componentID, newIDMap, clonedComponents, clonedConnections);\n\n    const rootComponentData = clonedComponents.find((e) => e.id == componentID);\n    if (rootComponentData) {\n        if (rootComponentData.name !== 'APIEndpoint') {\n            const APIEndpointData: any = {\n                id: `${componentID}_ENDPOINT`,\n                name: 'APIEndpoint',\n                outputs: [\n                    { name: 'headers', index: 0, default: true },\n                    { name: 'body', index: 1, default: true },\n                    { name: 'query', index: 2, default: true },\n                ],\n                inputs: [],\n                data: { endpoint: componentID, description: '', method: 'POST' },\n                displayName: 'APIEndpoint',\n                title: 'APIEndpoint',\n                description: '',\n            };\n\n            //APIEndpointData.inputs = JSON.parse(JSON.stringify(rootComponentData.inputs));\n            clonedComponents.push(APIEndpointData);\n\n            //find all previously connected forked inputs\n            const incomingConnections = componentData.connections.filter((conn) => conn.targetId === componentID);\n            // //deduplicate connections by targetId\n            // const uniqueIncomingConnections = incomingConnections.filter(\n            //     (conn, index, self) => index === self.findIndex((t) => t.targetId === conn.targetId && t.sourceIndex === conn.sourceIndex && t.targetIndex === conn.targetIndex),\n            // );\n\n            let i = 3;\n            for (let con of incomingConnections) {\n                const input = rootComponentData.inputs.find((e) => e.index == con.targetIndex);\n                const epInput = JSON.parse(JSON.stringify(input));\n                APIEndpointData.inputs.push(epInput);\n\n                const epOutput = {\n                    name: input.name,\n                    expression: `body.${input.name}`,\n                    optional: false,\n                    index: i++,\n                    default: false,\n                };\n                APIEndpointData.outputs.push(epOutput);\n\n                clonedConnections.push({\n                    sourceId: APIEndpointData.id,\n                    targetId: rootComponentData.id,\n                    sourceIndex: epOutput.index,\n                    targetIndex: input.index,\n                });\n            }\n        }\n    }\n    // Return the cloned sub-workflow\n    return {\n        components: clonedComponents,\n        connections: clonedConnections,\n    };\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport ForkedAgent from '@sre/AgentManager/ForkedAgent.class';\nimport Component from './Component.class';\nimport Joi from 'joi';\nimport { delay } from '../utils';\n\nexport default class Async extends Component {\n    static JOBS = {};\n    protected configSchema = null;\n    static ForkedAgent;\n    constructor() {\n        super();\n        // import('../ForkedAgent.class').then((ForkedAgent) => {\n        //     Async.ForkedAgent = ForkedAgent.default;\n        // });\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        //we set data.forked to true in the forked component in order to refork it again.\n        const forked = config.data.forked;\n        let _error = null;\n\n        try {\n            //const runtimeData = agent.agentRuntime.getRuntimeData(config.id);\n\n            if (!forked) {\n                const forkedAgent: ForkedAgent = new ForkedAgent(agent, config.id);\n                const JobID = forkedAgent.jobID;\n\n                forkedAgent.agent.async = true;\n                forkedAgent.agent.jobID = JobID;\n                //clean JobID branch\n                this.cleanJobIDBranch(forkedAgent.agent);\n\n                const componentData = forkedAgent.components[config.id];\n                componentData.data.forked = true;\n\n                forkedAgent.agentRequest.body = { ...input };\n\n                if (!Async.JOBS[agent.id]) Async.JOBS[agent.id] = {};\n                Async.JOBS[agent.id][JobID] = {\n                    //forkedAgent,\n                    status: 'pending',\n                };\n\n                //We use this to inform the debugger about the list of components used by this job\n                //this is only used to provide a visual feedback in the debugger UI\n                if (agent.debugSessionEnabled) {\n                    const _job_components = Object.keys(forkedAgent.components);\n                    agent.agentRuntime.updateComponent(config.id, { _job_components });\n                }\n\n                forkedAgent\n                    .process(`/api/${config.id}`, input)\n                    .then((result) => {\n                        Async.JOBS[agent.id][JobID].result = result;\n                        Async.JOBS[agent.id][JobID].status = 'done';\n                    })\n                    .finally(async () => {\n                        if (Async.JOBS[agent.id][JobID].status !== 'done') {\n                            Async.JOBS[agent.id][JobID].status = 'failed';\n                        }\n                        if (agent.debugSessionEnabled) {\n                            await delay(1000); //wait for the debugger to update the UI\n                            //ctxData in agentRuntime might have been updated by the main component\n                            //we need to reload it in order to ensure that we're updating the latest version\n                            agent.agentRuntime.reloadCtxData();\n                            agent.agentRuntime.updateComponent(config.id, { _job_components: [] });\n                        }\n                    });\n\n                return { JobID };\n            } else {\n                //const Input = input.Input;\n                let result = { JobID: agent.jobID };\n                for (let key in input) {\n                    result[key] = input[key];\n                }\n\n                return result;\n            }\n        } catch (error: any) {\n            _error = error;\n        }\n\n        return {};\n    }\n\n    // private recursiveTagAsyncComponents(component, agent: Agent) {\n    //     for (let output of component.outputs) {\n    //         if (component.name == 'Async' && output.name === 'JobID') continue; //'JobID' is a special output\n    //         const connected = agent.connections.filter((c) => c.sourceId === component.id && c.sourceIndex === output.index);\n    //         if (!connected) continue;\n    //         for (let con of connected) {\n    //             const targetComponent = agent.components[con.targetId];\n    //             if (!targetComponent) continue;\n    //             targetComponent.async = true;\n    //             this.recursiveTagAsyncComponents(targetComponent, agent);\n    //         }\n    //     }\n    // }\n    // private tagAsyncComponents(agent: Agent) {\n    //     const componentsList: any[] = Object.values(agent.components);\n    //     const AsyncComponent = componentsList.find((c) => c.name === 'Async');\n    //     if (!AsyncComponent) return;\n    //     AsyncComponent.async = true;\n\n    //     this.recursiveTagAsyncComponents(AsyncComponent, agent);\n    // }\n    private cleanJobIDBranch(agent: Agent) {\n        //this.tagAsyncComponents(agent);\n\n        const componentsList: any[] = Object.values(agent.components);\n        const AsyncComponent = componentsList.find((c) => c.name === 'Async');\n        //const endpointComponent = componentsList.find((c) => c.name === 'APIEndpoint');\n        if (!AsyncComponent) return;\n        const jobIDOutputIndex = AsyncComponent.outputs.findIndex((o) => o.name === 'JobID');\n        if (jobIDOutputIndex === -1) return;\n        //delete connections where sourceId = AsyncComponent.id and sourceOutputIndex = jobIDOutputIndex and the component is not tagged as async\n        agent.connections = agent.connections.filter((c) => {\n            const toDelete = c.sourceId === AsyncComponent.id && c.sourceIndex === jobIDOutputIndex && !agent.components[c.targetId].async;\n            return !toDelete;\n        });\n\n        //TODO : remove orphaned branches\n        this.removeOrphanedBranches(agent);\n    }\n\n    private removeOrphanedBranches(agent: Agent) {\n        const toDelete: any[] = [];\n        for (let componentId in agent.components) {\n            const component = agent.components[componentId];\n            if (component.name === 'APIEndpoint') continue;\n            const connected = agent.connections.some((c) => c.targetId === component.id);\n            if (!connected) {\n                //this.removeComponent(agent, component.id);\n                toDelete.push(component.id);\n            }\n        }\n        for (let id of toDelete) {\n            this.removeComponent(agent, id);\n        }\n    }\n\n    private removeComponent(agent: Agent, componentId: string) {\n        const component = agent.components[componentId];\n        delete agent.components[componentId];\n\n        //delete connections where sourceId = componentId\n        agent.connections = agent.connections.filter((c) => c.sourceId !== componentId);\n        this.removeOrphanedBranches(agent);\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\nimport axios from 'axios';\nimport Joi from 'joi';\nimport Async from './Async.class';\n\nexport default class Await extends Component {\n    static WAITS = {};\n\n    protected configSchema = Joi.object({\n        jobs_count: Joi.number().min(1).max(100).default(1).label('Jobs Count'),\n        max_time: Joi.number().min(1).max(21600).default(1).label('Max time'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            let Results: any = {};\n            const _error = null;\n            let jobs_count = parseInt(config.data.jobs_count || 1);\n            let max_time = parseInt(config.data.max_time || 1);\n\n            const jobs = Array.isArray(input.Jobs) ? input.Jobs : [input.Jobs];\n\n            if (!Await.WAITS[agent.id]) Await.WAITS[agent.id] = {};\n            if (!Await.WAITS[agent.id][config.id]) Await.WAITS[agent.id][config.id] = {};\n            if (!Await.WAITS[agent.id][config.id][agent.agentRuntime.workflowReqId])\n                Await.WAITS[agent.id][config.id][agent.agentRuntime.workflowReqId] = [];\n\n            //add jobs to the list\n            for (let jobID of jobs) Await.WAITS[agent.id][config.id][agent.agentRuntime.workflowReqId].push(jobID);\n\n            logger.debug('Jobs', jobs);\n            logger.debug('Waiting for jobs to finish');\n\n            let promise = new Promise((resolve, reject) => {\n                let interval = setInterval(() => {\n                    if (max_time < 0) {\n                        clearInterval(interval);\n                        return resolve(true);\n                    }\n                    let done = true;\n                    let completed = 0;\n                    for (let jobID of jobs) {\n                        if (Async.JOBS?.[agent.id]?.[jobID]?.status == 'pending') {\n                            done = false;\n                            break;\n                        } else {\n                            completed++;\n                        }\n                    }\n                    if (completed >= jobs_count) {\n                        done = true;\n                    }\n\n                    if (done) {\n                        clearInterval(interval);\n                        return resolve(true);\n                    }\n\n                    max_time -= 1;\n                }, 1000);\n            });\n\n            await promise;\n            logger.debug('Jobs finished, collecting results');\n            for (let jobID of jobs) {\n                Results[jobID] = {\n                    output: Async.JOBS?.[agent.id]?.[jobID]?.result,\n                    status: Async.JOBS?.[agent.id]?.[jobID]?.status || 'unknown_job',\n                };\n            }\n            delete Await.WAITS[agent.id][config.id][agent.agentRuntime.workflowReqId];\n\n            logger.debug('Results', Results);\n            return { Results, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error running code \\n${_error}\\n`);\n            delete Await.WAITS[agent.id][config.id][agent.agentRuntime.workflowReqId];\n\n            return { Output: undefined, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        }\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\nimport Joi from 'joi';\n\nexport default class ForEach extends Component {\n    protected configSchema = null;\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        let Loop = {};\n        let Result;\n        let _temp_result;\n        let _error = null;\n        let _in_progress = true;\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const inputObject = input.Input;\n            let inputArray = Array.isArray(inputObject) ? inputObject : [inputObject];\n\n            if (!Array.isArray(inputArray) && typeof inputArray === 'object')\n                //if json object, use the values\n                inputArray = Object.values(inputArray);\n\n            const runtimeData = agent.agentRuntime.getRuntimeData(config.id);\n            const _ForEachData = runtimeData._LoopData || { parentId: config.id, loopIndex: 0, loopLength: inputArray.length };\n\n            logger.debug(`Loop: ${_ForEachData.loopIndex} / ${_ForEachData.loopLength}`);\n            delete _ForEachData.branches; //reset branches (the number of branches is calculated in CallComponent@Agent.class.ts )\n\n            if (_ForEachData.result) {\n                _temp_result = _ForEachData.result;\n                logger.debug(`  => Loop Result : ${JSON.stringify(Loop, null, 2)}`);\n                logger.debug(`---------------------------------------------------`);\n            }\n\n            Loop = inputArray[_ForEachData.loopIndex];\n\n            logger.debug(`  => Loop Data : ${JSON.stringify(Loop, null, 2)}`);\n\n            _in_progress = Loop !== undefined;\n            if (_in_progress) {\n                _ForEachData.loopIndex++;\n            }\n            _ForEachData._in_progress = _in_progress;\n\n            agent.agentRuntime.updateRuntimeData(config.id, { _LoopData: _ForEachData });\n        } catch (error: any) {\n            _error = error;\n            logger.error(error);\n        }\n        if (!_in_progress) {\n            Result = _temp_result || [];\n\n            switch (config?.data?.format) {\n                case 'minimal':\n                    Result = Result.map((item) => cleanupResult(item.result));\n                    break;\n                case 'results-array':\n                    Result = Result.map((item) => Object.values(cleanupResult(item.result))).flat(Infinity);\n                    break;\n            }\n        }\n\n        return { Loop, Result, _temp_result, _error, _in_progress, _debug: logger.output };\n    }\n    async postProcess(output, config, agent: Agent): Promise<any> {\n        output = await super.postProcess(output, config, agent);\n        if (output?.result) {\n            delete output.result._temp_result;\n            delete output.result._in_progress;\n            delete output.result.Loop;\n        }\n        return output;\n    }\n}\nfunction cleanupResult(result) {\n    if (typeof result !== 'object') return result;\n    if (result._debug) delete result._debug;\n    if (result._error) delete result._error;\n    if (result._temp_result) delete result._temp_result;\n    if (result._in_progress) delete result._in_progress;\n    return result;\n}\n","import { HfInference } from '@huggingface/inference';\nimport Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport hfParams from '../data/hugging-face.params.json';\nimport Joi from 'joi';\nimport { TemplateStringHelper } from '@sre/helpers/TemplateString.helper';\nimport { convertStringToRespectiveType, delay, isBase64, kebabToCapitalize, kebabToCamel } from '../utils';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\n\nfunction shouldNestInputs(formatRequestPattern) {\n    const trimmedPattern = formatRequestPattern?.trim();\n    return /^(inputs|data):\\s*{(?![{])/.test(trimmedPattern);\n}\n\nfunction validateAndParseJson(value, helpers) {\n    let parsedJson: any = null;\n\n    // Try parsing the JSON string\n    try {\n        parsedJson = JSON.parse(value);\n    } catch (error) {\n        // If parsing fails, return an error\n        return helpers.error('string.invalidJson', { value });\n    }\n\n    // Check if the result is an object\n    if (typeof parsedJson !== 'object' || parsedJson === null) {\n        return helpers.error('string.notJsonObject', { value });\n    }\n\n    // Check for empty keys\n    for (const key in parsedJson) {\n        if (key.trim() === '') {\n            return helpers.error('object.emptyKey', { value });\n        }\n    }\n\n    // Return the parsed JSON if all validations pass\n    return parsedJson;\n}\n\nexport default class HuggingFace extends Component {\n    protected configSchema = Joi.object({\n        accessToken: Joi.string().max(350).required().label('Access Token'),\n        modelName: Joi.string().max(100).required(),\n        modelTask: Joi.string().max(100).required(),\n        inputConfig: Joi.string().allow(''),\n        parameters: Joi.string().custom(validateAndParseJson, 'custom JSON validation').allow(''),\n        name: Joi.string().max(100).required(),\n        displayName: Joi.string().max(100).required(),\n        desc: Joi.string().max(5000).required().allow(''),\n        logoUrl: Joi.string().max(500).allow(''),\n        disableCache: Joi.boolean().strict(),\n    });\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n\n        logger.debug(`=== Hugging Face Log ===`);\n\n        const agentId = agent?.id;\n\n        const teamId = agent?.teamId;\n        // const accessToken = await parseKey(config?.data?.accessToken, teamId);\n        const accessToken = (await TemplateStringHelper.create(config?.data?.accessToken).parseTeamKeysAsync(teamId).asyncResult) as string;\n\n        if (!accessToken) {\n            return { _error: 'Please provide a valid Hugging Face Access Token', _debug: logger.output };\n        }\n\n        const hf = new HfInference(accessToken);\n\n        const task = config?.data?.modelTask;\n\n        if (!task) {\n            return { _error: 'Hugging Face Task is required!', _debug: logger.output };\n        }\n\n        logger.debug(`Task: ${kebabToCapitalize(task)}`);\n\n        let hfFunc = kebabToCamel(task);\n\n        // * Right now 'text2textGeneration' function is not available, so we are using 'textGeneration' for it.\n        // Reference - https://huggingface.co/docs/api-inference/en/detailed_parameters#text2text-generation-task\n        if (hfFunc === 'text2textGeneration') {\n            hfFunc = 'textGeneration';\n        }\n\n        if (!hf?.[hfFunc]) {\n            return { _error: `Inference API does not support for this task - ${kebabToCapitalize(task)}`, _debug: logger.output };\n        }\n\n        const modelName = config?.data?.modelName;\n\n        if (!modelName) {\n            return { _error: 'Hugging Face Model is required!', _debug: logger.output };\n        }\n\n        logger.debug(`Model Name: ${modelName}`);\n\n        //const inputConfig = JSON.parse(config?.data?.inputConfig || '{}');\n\n        let inputConfig: any = {};\n        const formatRequest = hfParams?.[task]?.formatRequest;\n        const _hfParams = hfParams?.[task]?.inputs;\n        if (_hfParams && Object.keys(_hfParams).length > 0) {\n            for (const key in _hfParams) {\n                const config = _hfParams[key];\n                inputConfig[key] = config;\n            }\n            if (typeof inputConfig === 'object' && inputConfig !== null) {\n                inputConfig = { ...inputConfig, formatRequest };\n            }\n        }\n\n        if (!inputConfig || Object.keys(inputConfig)?.length === 0) {\n            console.log('No inputs config found for Hugging Face Model!');\n        }\n\n        let inputs = {};\n\n        if (!input || Object.keys(input)?.length === 0) {\n            return { _error: 'Please provide a valid input!', _debug: logger.output };\n        }\n\n        if (typeof input !== 'object') {\n            return { _error: 'Invalid input!', _debug: logger.output };\n        }\n\n        if (typeof input == 'object' && Object.keys(input)?.length > 0) {\n            for (const key in input) {\n                if (inputConfig?.[key]) {\n                    let value = input[key];\n                    let name = inputConfig[key]['request_parameter_name'];\n                    let type = inputConfig[key]['request_parameter_type'];\n\n                    if (type && type?.includes('Blob')) {\n                        try {\n                            // const file = new SmythFile(value);\n                            // const blob = await file.toBlob(); // Converts to Blob for file inputs\n                            // inputs[name] = blob;\n                            const binaryFile = BinaryInput.from(value);\n                            const buffer = await binaryFile.getBuffer();\n                            const blob = new Blob([buffer]);\n                            inputs[name] = blob;\n                        } catch (error: any) {\n                            return { _error: error?.message || JSON.stringify(error), _debug: logger.output };\n                        }\n                    } else {\n                        inputs[name] = value;\n                    }\n                }\n            }\n        }\n        // Determine if inputs should be nested based on formatRequest\n        const nestInputs = shouldNestInputs(inputConfig.formatRequest);\n        // Apply the determined structure to newInputs\n        const structuredInputs = nestInputs ? { inputs } : inputs;\n\n        // Blob data will be converted to an empty object '{}', when stringified during logging. We need log something so that user can understand that it is a Blob\n        let inputsLog;\n\n        if (structuredInputs['inputs'] && typeof structuredInputs['inputs'] === 'object') {\n            inputsLog = { ...structuredInputs['inputs'] };\n\n            for (const [key, value] of Object.entries(structuredInputs['inputs'] || {})) {\n                if (value instanceof Blob) {\n                    inputsLog[key] = `Blob size=${value.size}`;\n                }\n            }\n        } else {\n            inputsLog = structuredInputs;\n        }\n\n        logger.debug('Inputs: ', inputsLog);\n\n        let params = JSON.parse(config?.data?.parameters || '{}');\n        params = convertStringToRespectiveType(params);\n\n        let parameters = {};\n\n        if (params && Object.keys(params)?.length > 0) {\n            for (const key in params) {\n                const value = params[key];\n\n                if (typeof value === 'string') {\n                    // if value is 'None' then skip it\n                    if (value?.toLowerCase() === 'none') continue;\n\n                    parameters[key] = TemplateStringHelper.create(value).parse(input).result;\n                } else {\n                    parameters[key] = value;\n                }\n            }\n        }\n\n        let args = { model: modelName, ...structuredInputs };\n\n        const options = {};\n\n        // default value of use_cache is true, make it false if disableCache is true\n        if (config?.data?.disableCache) {\n            options['use_cache'] = false;\n        }\n\n        if (Object.keys(parameters)?.length > 0) {\n            args['parameters'] = parameters;\n\n            logger.debug('Parameters: \\n', parameters);\n        }\n\n        const modelCallWithRetry = async ({ retryCount = 0, retryLimit = 2, retryDelay = 1000 }) => {\n            try {\n                /*\n                Provide the 'request' method when the method is not found and as a fallback for the following error:\n                InferenceOutputError: Invalid inference output: Expected Array<{summary_text: string}>. Use the 'request' method with the same parameters to do a custom call with no type checking.\n                */\n                if (typeof hf[hfFunc] !== 'function' || retryCount === retryLimit) {\n                    hfFunc = 'request';\n                }\n                const result = await hf[hfFunc](args, options);\n                let output;\n\n                if (result instanceof Blob) {\n                    // Handle case where result is directly a Blob\n                    // const file = new SmythFile(result);\n                    // const fileObj = await file.toSmythFileObject({\n                    //     metadata: {\n                    //         teamid: teamId,\n                    //         agentid: agentId,\n                    //     },\n                    //     baseUrl: agent?.baseUrl,\n                    // });\n                    // output = fileObj;\n                    const obj = await BinaryInput.from(result).getJsonData(AccessCandidate.agent(agent.id));\n                    output = obj;\n                } else if (Array.isArray(result)) {\n                    // Handle case where result is an array of objects containing Blobs or base64 strings\n                    output = await Promise.all(\n                        result.map(async (item) => {\n                            if (item.blob instanceof Blob || (typeof item.blob === 'string' && isBase64(item.blob))) {\n                                let binaryInput: BinaryInput;\n\n                                if (item.blob instanceof Blob) {\n                                    // file = new SmythFile(item.blob);\n\n                                    binaryInput = BinaryInput.from(item.blob);\n                                } else {\n                                    // file = new SmythFile(item.blob, item['content-type']);\n                                    binaryInput = BinaryInput.from(item.blob, undefined, item['content-type']);\n                                }\n                                // const fileObj = await file.toSmythFileObject({\n                                //     metadata: {\n                                //         teamid: teamId,\n                                //         agentid: agentId,\n                                //     },\n                                //     baseUrl: agent?.baseUrl,\n                                // });\n                                const fileObj = await binaryInput.getJsonData(AccessCandidate.agent(agent.id));\n                                return { ...item, blob: fileObj };\n                            } else {\n                                return item;\n                            }\n                        })\n                    );\n                } else {\n                    // Handle case where result is neither a Blob nor an array of Blob-containing objects\n                    output = result;\n                }\n                return output;\n            } catch (error) {\n                if (retryCount < retryLimit) {\n                    await delay(retryDelay);\n\n                    return modelCallWithRetry({\n                        retryCount: retryCount + 1,\n                        retryLimit,\n                        retryDelay: retryDelay * 2,\n                    });\n                }\n\n                throw error;\n            }\n        };\n\n        try {\n            const output = await modelCallWithRetry({\n                retryCount: 0,\n                retryLimit: 2,\n                retryDelay: 5000,\n            });\n\n            logger.debug('Output: \\n', output);\n\n            return { Output: output, _debug: logger.output };\n        } catch (error: any) {\n            console.log(`Error on running Hugging Face Model!`, error);\n            console.log('Error: args, options ', args, options);\n\n            return { _error: `Error from Hugging Face: \\n${error?.message || JSON.stringify(error)}`, _debug: logger.output };\n        }\n    }\n}\n","import axios from 'axios';\nimport Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Joi from 'joi';\nimport { TemplateStringHelper } from '@sre/helpers/TemplateString.helper';\nimport { isSmythFileObject } from '../utils';\nimport { SmythFS } from '@sre/IO/Storage.service/SmythFS.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\n\nfunction validateAndParseJson(value, helpers) {\n    let parsedJson: any = null;\n\n    // Try parsing the JSON string\n    try {\n        parsedJson = JSON.parse(value);\n    } catch (error) {\n        // If parsing fails, return an error\n        return helpers.error('string.invalidJson', { value });\n    }\n\n    // Check if the result is an object\n    if (typeof parsedJson !== 'object' || parsedJson === null) {\n        return helpers.error('string.notJsonObject', { value });\n    }\n\n    // Check for empty keys\n    for (const key in parsedJson) {\n        if (key.trim() === '') {\n            return helpers.error('object.emptyKey', { value });\n        }\n    }\n\n    // Return the parsed JSON if all validations pass\n    return parsedJson;\n}\n\nexport default class ZapierAction extends Component {\n    protected configSchema = Joi.object({\n        actionName: Joi.string().max(100).required(),\n        actionId: Joi.string().max(100).required(),\n        logoUrl: Joi.string().max(500).allow(''),\n        apiKey: Joi.string().max(350).required(),\n        params: Joi.string().custom(validateAndParseJson, 'custom JSON validation').allow(''),\n    });\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n\n        logger.debug(`=== Zapier Action Log ===`);\n\n        const teamId = agent?.teamId;\n        // const apiKey = await parseKey(config?.data?.apiKey, teamId);\n        const apiKey = await TemplateStringHelper.create(config?.data?.apiKey).parseTeamKeysAsync(teamId).asyncResult;\n\n        if (!apiKey) {\n            return { _error: 'You are not authorized to run the Zapier Action!', _debug: logger.output };\n        }\n\n        const actionId = config?.data?.actionId;\n\n        if (!actionId) {\n            return { _error: 'Zapier Action ID is required!', _debug: logger.output };\n        }\n\n        if (!Object.keys(input || {})?.length) {\n            return { _error: 'Give a plain english description of exact action you want to do!', _debug: logger.output };\n        }\n\n        let _input = {};\n        let _pubUrlsCreated: string[] = [];\n\n        for (const [key, value] of Object.entries(input)) {\n            if (isSmythFileObject(value)) {\n                // _input[key] = (value as SmythFileObject)?.url;\n                const pubUrl = await SmythFS.Instance.genTempUrl((value as any)?.url, AccessCandidate.agent(agent.id));\n                _pubUrlsCreated.push(pubUrl);\n                _input[key] = {\n                    ...(value as any),\n                    url: pubUrl,\n                };\n            } else {\n                _input[key] = value;\n            }\n        }\n\n        try {\n            const url = `https://actions.zapier.com/api/v1/exposed/${actionId}/execute/?api_key=${apiKey}`;\n            const res = await axios.post(url, { ..._input });\n\n            logger.debug(`Output:\\n`, res?.data);\n\n            Promise.all(_pubUrlsCreated.map((url) => SmythFS.Instance.destroyTempUrl(url)))\n                .then(() => {\n                    console.log('Cleaned up all temp urls');\n                })\n                .catch((e) => {\n                    console.log('Error cleaning up temp urls', e);\n                });\n\n            return { Output: res?.data, _debug: logger.output };\n        } catch (error: any) {\n            console.log('Error Running Zapier Action: \\n', error);\n\n            // Sometimes 'error?.response?.data' is an empty Object then we need to use 'error?.message'\n            let message = Object.keys(error?.response?.data || {})?.length ? error?.response?.data : error?.message;\n\n            if (typeof message === 'object') message = JSON.stringify(message);\n\n            logger.error(`Error running Zapier Action!`, message);\n            logger.error('Error Inputs ', input);\n\n            Promise.all(_pubUrlsCreated.map((url) => SmythFS.Instance.destroyTempUrl(url)))\n                .then(() => {\n                    console.log('Cleaned up all temp urls');\n                })\n                .catch((e) => {\n                    console.log('Error cleaning up temp urls', e);\n                });\n\n            return { _error: `Zapier Error: ${message}`, _debug: logger.output };\n        }\n    }\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { Conversation } from '@sre/helpers/Conversation.helper';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\nimport Component from './Component.class';\n\nexport default class GPTPlugin extends Component {\n    protected configSchema = Joi.object({\n        model: Joi.string().optional(),\n        openAiModel: Joi.string().required(), // ! Legacy\n        specUrl: Joi.string().max(2048).uri().required().description('URL of the OpenAPI specification'),\n        descForModel: Joi.string().max(5000).required().allow('').label('Description for Model'),\n        name: Joi.string().max(500).required().allow(''),\n        desc: Joi.string().max(5000).required().allow('').label('Description'),\n        logoUrl: Joi.string().max(8192).allow(''),\n        id: Joi.string().max(200),\n        version: Joi.string().max(100).allow(''),\n        domain: Joi.string().max(253).allow(''),\n    });\n\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n\n        logger.debug(`=== GPT Plugin Log ===`);\n\n        try {\n            const specUrl = config?.data?.specUrl;\n\n            if (!specUrl) {\n                return { _error: 'Please provide a Open API Specification URL!', _debug: logger.output };\n            }\n\n            const model = config?.data?.model || config?.data?.openAiModel;\n            const descForModel = TemplateString(config?.data?.descForModel).parse(input).result;\n            let prompt = '';\n\n            if (input?.Prompt) {\n                prompt = typeof input?.Prompt === 'string' ? input?.Prompt : JSON.stringify(input?.Prompt);\n            } else if (input?.Query) {\n                prompt = typeof input?.Query === 'string' ? input?.Query : JSON.stringify(input?.Query);\n            }\n\n            if (!prompt) {\n                return { _error: 'Please provide a prompt', _debug: logger.output };\n            }\n\n            // TODO [Forhad]: Need to check and validate input prompt token\n\n            const conv = new Conversation(model, specUrl, { systemPrompt: descForModel });\n\n            const result = await conv.prompt(prompt);\n\n            logger.debug(`Response:\\n`, result, '\\n');\n\n            return { Output: result, _debug: logger.output };\n        } catch (error: any) {\n            console.error('Error on running GPT Plugin: ', error);\n            return { _error: `Error on running GPT Plugin!\\n${error?.message || JSON.stringify(error)}`, _debug: logger.output };\n        }\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\nimport Joi from 'joi';\nimport { LLMInference } from '@sre/LLMManager/LLM.inference';\nimport { GenerateImageConfig } from '@sre/types/LLM.types';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\nexport default class ImageGenerator extends Component {\n    protected configSchema = Joi.object({\n        model: Joi.string().valid('dall-e-2', 'dall-e-3').required(),\n        prompt: Joi.string().optional().max(4000000).label('Prompt'), // 1M tokens is around 4M characters\n        sizeDalle2: Joi.string().valid('256x256', '512x512', '1024x1024').required(),\n        sizeDalle3: Joi.string().valid('1024x1024', '1792x1024', '1024x1792').required(),\n        quality: Joi.string().valid('standard', 'hd').required(),\n        style: Joi.string().valid('vivid', 'natural').required(),\n        isRawInputPrompt: Joi.boolean().strict(),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n\n        logger.debug(`=== Image Generator Log ===`);\n\n        let model = config?.data?.model;\n\n        if (!model) {\n            return { _error: 'Model Not Found: Either DALLÂ·E 3 or DALLÂ·E 2 is required!', _debug: logger.output };\n        }\n\n        let prompt = config.data?.prompt || input?.Prompt;\n        prompt = typeof prompt === 'string' ? prompt : JSON.stringify(prompt);\n        prompt = TemplateString(prompt).parse(input).result;\n\n        // ! LATER IMPROVEMENT: support image variation API\n        /* let image = input?.Image || null;\n        let shouldGenerateVariation = false;\n        let tempImagePath = '';\n\n        if (image) {\n            const file = new SmythFile(image);\n            image = await file.toFsReadStream();\n\n            if (image) {\n                shouldGenerateVariation = true;\n                tempImagePath = image?.path;\n\n                model = 'dall-e-2';\n            }\n        } */\n\n        // ! LATER IMPROVEMENT: support image variation API\n        // if (!prompt && !image)\n        if (!prompt) {\n            return { _error: 'Please provide a prompt or Image', _debug: logger.output };\n        }\n\n        let _finalPrompt = prompt;\n\n        logger.debug(`Prompt: \\n`, prompt);\n\n        const responseFormat = config?.data?.responseFormat || 'url';\n\n        let args: GenerateImageConfig & { responseFormat: 'url' | 'b64_json' } = {\n            responseFormat,\n            model,\n        };\n\n        // ! LATER IMPROVEMENT: support image variation API\n        /* if (shouldGenerateVariation) {\n            args = {\n                image,\n                model,\n                responseFormat,\n            };\n        } else {\n            args = {\n                prompt,\n                model,\n                responseFormat,\n            };\n        } */\n\n        if (model === 'dall-e-3') {\n            const size = config?.data?.sizeDalle3 || '1024x1024';\n            const quality = config?.data?.quality || 'standard';\n            const style = config?.data?.style || 'vivid';\n            args.size = size;\n            args.quality = quality;\n            args.style = style;\n\n            const isRawInputPrompt = config?.data?.isRawInputPrompt || false;\n\n            if (isRawInputPrompt) {\n                _finalPrompt = `I NEED to test how the tool works with extremely simple prompts. DO NOT add any detail, just use it AS-IS: ${input?.Prompt}`;\n            }\n        } else if (model === 'dall-e-2') {\n            const size = config?.data?.sizeDalle2 || '256x256';\n            const numberOfImages = parseInt(config?.data?.numberOfImages) || 1;\n            args.size = size;\n            args.n = numberOfImages;\n        }\n\n        try {\n            // ! LATER IMPROVEMENT: support image variation API\n            /* if (shouldGenerateVariation) {\n                response = await OpenAI.generateImageVariation(args);\n\n                // remove temp image\n                const removeFile = promisify(fs.unlink);\n                removeFile(tempImagePath);\n            } else {\n                response = await OpenAI.generateImage(args);\n            } */\n\n            // let response = await OpenAI.generateImage(args);\n            const llmInference: LLMInference = await LLMInference.getInstance(model);\n\n            // if the llm is undefined, then it means we removed the model from our system\n            if (!llmInference.connector) {\n                return {\n                    _error: `The model '${model}' is not available. Please try a different one.`,\n                    _debug: logger.output,\n                };\n            }\n            const response: any = await llmInference.imageGenRequest(_finalPrompt, args, agent).catch((error) => ({ error: error }));\n\n            let output = response?.data?.[0]?.[responseFormat];\n            const revised_prompt = response?.data?.[0]?.revised_prompt;\n\n            if (revised_prompt && prompt !== revised_prompt) {\n                logger.debug(`Revised Prompt:\\n${revised_prompt}`);\n            }\n\n            logger.debug(`Output:`, output);\n\n            return { Output: output, _debug: logger.output };\n        } catch (error: any) {\n            return { _error: `Generating Image(s)\\n${error?.message || JSON.stringify(error)}`, _debug: logger.output };\n        }\n    }\n}\n","import Joi from 'joi';\n\nimport { JSONContentHelper } from '@sre/helpers/JsonContent.helper';\nimport Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { LLMInference } from '@sre/LLMManager/LLM.inference';\n\nexport default class Classifier extends Component {\n    protected configSchema = Joi.object({\n        model: Joi.string().max(200).required(),\n        prompt: Joi.string().max(30000).allow('').label('Prompt'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    escapeJSONString(str: string) {\n        return str.replace(/\\{/g, '<[<(').replace(/\\}/g, ')>]>').replace(/\"/g, '`');\n    }\n    unescapeJSONString(str: string) {\n        return str\n            .replace(/<\\[<\\(/g, '{')\n            .replace(/\\)>]>/g, '}')\n            .replace(/`/g, '\"');\n    }\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        //let debugLog = agent.agentRuntime?.debug ? [] : undefined;\n        const logger = this.createComponentLogger(agent, config.name);\n\n        const inputCopy = JSON.parse(JSON.stringify(input));\n        for (let key in inputCopy) {\n            if (typeof inputCopy[key] === 'string') {\n                inputCopy[key] = this.escapeJSONString(inputCopy[key]);\n            } else if (typeof inputCopy[key] === 'object') {\n                inputCopy[key] = JSON.stringify(inputCopy[key]);\n                inputCopy[key] = this.escapeJSONString(inputCopy[key]);\n            }\n        }\n\n        const _input = typeof input === 'string' ? input : JSON.stringify(inputCopy, null, 2);\n        //const categories = config.outputs.map((output) => (output.name[0] != '[' ? output.name : null)).filter((e) => e);\n        const categories = {};\n        for (let con of config.outputs) categories[con.name] = con.description || '';\n\n        const outputs = {};\n        for (let con of config.outputs) {\n            outputs[con.name] = '<Boolean|String>';\n        }\n\n        const model: string = config.data.model;\n        logger.log(` Selected model : ${model}`);\n\n        let prompt = '';\n        const excludedKeys = ['_debug', '_error'];\n        const outputKeys = Object.keys(outputs).filter((key) => !excludedKeys.includes(key));\n\n        if (outputKeys.length > 0) {\n            const outputFormat = {};\n            outputKeys.forEach((key) => (outputFormat[key] = outputs[key]));\n\n            prompt = `${config.data.prompt}\n${_input}\n\n---\nCategories: \n${JSON.stringify(categories, null, 2)}`;\n\n            prompt = TemplateString(prompt).parse(input).result;\n        }\n\n        logger.log(` Enhanced prompt \\n${prompt}\\n`);\n\n        if (!prompt) {\n            logger.error(` Missing information, Cannot run classifier`);\n\n            return { _error: 'Missing information, Cannot run classifier', _debug: logger.output };\n        }\n\n        const llmInference: LLMInference = await LLMInference.getInstance(model || 'echo');\n        if (!llmInference.connector) {\n            return {\n                _error: `The model '${model}' is not available. Please try a different one.`,\n                _debug: logger.output,\n            };\n        }\n\n        try {\n            let response = await llmInference.promptRequest(prompt, config, agent).catch((error) => ({ error: error }));\n\n            if (response.error) {\n                logger.error(` LLM Error=`, response.error);\n\n                return { _error: response.error.toString(), _debug: logger.output };\n            }\n\n            // let parsed = parseJson(response);\n            let parsed = typeof response === 'string' ? JSONContentHelper.create(response).tryParse() : response;\n\n            for (let entry in parsed) {\n                if (!parsed[entry]) delete parsed[entry];\n                else {\n                    if (typeof parsed[entry] === 'string') {\n                        parsed[entry] = this.unescapeJSONString(parsed[entry]);\n                        // const parsedValue = parseJson(parsed[entry]);\n                        const parsedValue = JSONContentHelper.create(parsed[entry]).tryParse();\n                        if (typeof parsedValue === 'object' && !parsedValue.error) parsed[entry] = parsedValue;\n                    }\n                }\n            }\n\n            if (parsed.error) {\n                parsed._error = parsed.error;\n                logger.warn(` Post process error=${parsed.error}`);\n                delete parsed.error;\n            }\n\n            logger.log(' Classifier result', parsed);\n\n            parsed['_debug'] = logger.output;\n\n            return parsed;\n        } catch (error) {\n            return { _error: error.message, _debug: logger.output };\n        }\n    }\n}\n","import Joi from 'joi';\nimport Component from './Component.class';\nimport { LLMInference } from '@sre/LLMManager/LLM.inference';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\nexport default class MultimodalLLM extends Component {\n    protected configSchema = Joi.object({\n        prompt: Joi.string().required().max(4000000).label('Prompt'), // 1M tokens is around 4M characters\n        maxTokens: Joi.number().min(1).label('Maximum Tokens'),\n        model: Joi.string().max(200).required(),\n    });\n\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n\n        logger.debug(`=== Multimodal LLM Log ===`);\n\n        try {\n            const model: string = config.data.model || 'gpt-4o-mini';\n            const llmInference: LLMInference = await LLMInference.getInstance(model, agent.teamId);\n\n            if (!llmInference.connector) {\n                return {\n                    _error: `The model '${model}' is not available. Please try a different one.`,\n                    _debug: logger.output,\n                };\n            }\n\n            logger.debug(` Model : ${model}`);\n\n            let prompt: any = TemplateString(config.data.prompt).parse(input).result;\n\n            logger.debug(` Parsed prompt\\n`, prompt, '\\n');\n\n            const outputs = {};\n            for (let con of config.outputs) {\n                if (con.default) continue;\n                outputs[con.name] = con?.description ? `<${con?.description}>` : '';\n            }\n\n            const excludedKeys = ['_debug', '_error'];\n            const outputKeys = Object.keys(outputs).filter((key) => !excludedKeys.includes(key));\n\n            if (outputKeys.length > 0) {\n                const outputFormat = {};\n                outputKeys.forEach((key) => (outputFormat[key] = '<value>'));\n\n                prompt +=\n                    '\\n\\nExpected output format = ' +\n                    JSON.stringify(outputFormat) +\n                    '\\n\\n The output JSON should only use the entries from the output format.';\n\n                logger.debug(`[Component enhanced prompt]\\n${prompt}\\n\\n`);\n            }\n\n            const fileSources = Array.isArray(input.Input) ? input.Input : [input.Input];\n\n            const response = await llmInference.multimodalRequest(prompt, fileSources, config, agent);\n\n            logger.debug(` Enhanced prompt \\n`, prompt, '\\n');\n\n            if (!response) {\n                return { _error: ' LLM Error = Empty Response!', _debug: logger.output };\n            }\n\n            if (response?.error) {\n                logger.error(` LLM Error=${JSON.stringify(response.error)}`);\n                return { Reply: response?.data, _error: response?.error + ' ' + response?.details, _debug: logger.output };\n            }\n\n            const result = { Reply: response };\n            result['_debug'] = logger.output;\n\n            return result;\n        } catch (error: any) {\n            logger.error(`Error processing File(s)!\\n${JSON.stringify(error)}`);\n            return {\n                _error: `${error?.error || ''} ${error?.details || ''}`.trim() || error?.message || 'Something went wrong!',\n                _debug: logger.output,\n            };\n        }\n    }\n}\n","import Component from './Component.class';\nimport APIEndpoint from './APIEndpoint.class';\nimport APIOutput from './APIOutput.class';\nimport PromptGenerator from './PromptGenerator.class';\nimport APICall from './APICall/APICall.class';\nimport VisionLLM from './VisionLLM.class';\nimport FSleep from './FSleep.class';\nimport FHash from './FHash.class';\nimport FEncDec from './FEncDec.class';\nimport FTimestamp from './FTimestamp.class';\nimport DataSourceLookup from './DataSourceLookup.class';\nimport DataSourceIndexer from './DataSourceIndexer.class';\nimport DataSourceCleaner from './DataSourceCleaner.class';\nimport JSONFilter from './JSONFilter.class';\nimport LogicAND from './LogicAND.class';\nimport LogicOR from './LogicOR.class';\nimport LogicXOR from './LogicXOR.class';\nimport LogicAtLeast from './LogicAtLeast.class';\nimport LogicAtMost from './LogicAtMost.class';\nimport AgentPlugin from './AgentPlugin.class';\nimport LLMAssistant from './LLMAssistant.class';\nimport Async from './Async.class';\nimport Await from './Await.class';\nimport ForEach from './ForEach.class';\nimport Code from './Code.class';\nimport HuggingFace from './HuggingFace.class';\nimport ZapierAction from './ZapierAction.class';\nimport GPTPlugin from './GPTPlugin.class';\nimport ImageGenerator from './ImageGenerator.class';\nimport Classifier from './Classifier.class';\nimport FSign from './FSign.class';\nimport MultimodalLLM from './MultimodalLLM.class';\n\nconst components = {\n    Component: new Component(),\n    Note: new Component(), //this is a fake component\n    APIEndpoint: new APIEndpoint(),\n    APIOutput: new APIOutput(),\n    PromptGenerator: new PromptGenerator(),\n    LLMPrompt: new PromptGenerator(),\n    APICall: new APICall(),\n    VisionLLM: new VisionLLM(),\n    FSleep: new FSleep(),\n    FHash: new FHash(),\n    FEncDec: new FEncDec(),\n    FSign: new FSign(),\n    FTimestamp: new FTimestamp(),\n    DataSourceLookup: new DataSourceLookup(),\n    DataSourceIndexer: new DataSourceIndexer(),\n    DataSourceCleaner: new DataSourceCleaner(),\n    JSONFilter: new JSONFilter(),\n    LogicAND: new LogicAND(),\n    LogicOR: new LogicOR(),\n    LogicXOR: new LogicXOR(),\n    LogicAtLeast: new LogicAtLeast(),\n    LogicAtMost: new LogicAtMost(),\n    AgentPlugin: new AgentPlugin(),\n    LLMAssistant: new LLMAssistant(),\n    Async: new Async(),\n    Await: new Await(),\n    ForEach: new ForEach(),\n    Code: new Code(),\n    HuggingFace: new HuggingFace(),\n    ZapierAction: new ZapierAction(),\n    GPTPlugin: new GPTPlugin(),\n    ImageGenerator: new ImageGenerator(),\n    Classifier: new Classifier(),\n    MultimodalLLM: new MultimodalLLM(),\n};\n\nexport default components;\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\nfunction decodeUriParts(url: string): string {\n    try {\n        const urlObj = new URL(url);\n        urlObj.pathname = decodeURIComponent(urlObj.pathname);\n\n        // Handle search params individually\n        const searchParams = new URLSearchParams(urlObj.search);\n        for (const [key, value] of searchParams.entries()) {\n            try {\n                const decodedKey = decodeURIComponent(key);\n                const decodedValue = decodeURIComponent(value);\n                searchParams.delete(key);\n                searchParams.append(decodedKey, decodedValue);\n            } catch (paramError) {\n                console.warn(`Failed to decode search parameter: ${key}=${value}`, paramError);\n                // Keep the original key-value pair\n            }\n        }\n        urlObj.search = searchParams.toString();\n\n        urlObj.hash = decodeURIComponent(urlObj.hash);\n        return urlObj.toString();\n    } catch (error) {\n        console.warn('Failed to decode URL parts, proceeding with original value:', error);\n        return url;\n    }\n}\n\nexport async function parseUrl(input, config, agent: Agent) {\n    const teamId = agent ? agent.teamId : null;\n    const templateSettings = config?.template?.settings || {};\n\n    let url = config?.data?.url;\n\n    // Decode URL parts\n    url = decodeURIComponent(url);\n\n    //parse component template vars\n    if (config.data._templateVars && templateSettings) {\n        url = await TemplateString(url).parseComponentTemplateVarsAsync(templateSettings).asyncResult; // replaces component template vars with their IDs (this turns the string parses into an async parser) // replaces IDs with actual values then returns parser promise\n\n        url = await TemplateString(url).parse(config.data._templateVars).result;\n    }\n\n    //parse vault keys\n    url = await TemplateString(url).parseTeamKeysAsync(teamId).asyncResult;\n\n    //parse input variables and clean up the remaining unparsed values\n    url = TemplateString(url).parse(input).clean().result;\n\n    // Decode URL parts again after all parsing is done\n    url = decodeURIComponent(url);\n\n    //URL will take care of encoding the url properly\n    const urlObj = new URL(url);\n\n    //urlObj.href will return the encoded url\n    return urlObj.href;\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { REQUEST_CONTENT_TYPES } from '@sre/constants';\nimport { JSONContent } from '@sre/helpers/JsonContent.helper';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { AxiosHeaders } from 'axios';\n\nexport async function parseHeaders(input, config, agent: Agent) {\n    const teamId = agent ? agent.teamId : null;\n    const templateSettings = config?.template?.settings || {};\n    const contentType = config?.data?.contentType || REQUEST_CONTENT_TYPES.none;\n    let headers = config?.data?.headers || '{}';\n\n    //parse component template vars\n    if (config.data._templateVars && templateSettings) {\n        headers = await TemplateString(headers).parseComponentTemplateVarsAsync(templateSettings).asyncResult; // replaces component template vars with their IDs (this turns the string parses into an async parser) // replaces IDs with actual values then returns parser promise\n\n        headers = await TemplateString(headers).parse(config.data._templateVars).result;\n    }\n\n    //parse vault keys\n    headers = await TemplateString(headers).parseTeamKeysAsync(teamId).asyncResult;\n\n    //parse input variables and clean up the remaining unparsed values\n    headers = TemplateString(headers).parse(input).clean().result;\n\n    //parse headers as json\n    let jsonHeaders: any = JSONContent(headers).tryParse();\n    if (typeof jsonHeaders !== 'object') {\n        jsonHeaders = { 'x-smyth-error': 'Error parsing headers' };\n    }\n\n    //normalize headers key names to lowercase\n    jsonHeaders = Object.fromEntries(Object.entries(jsonHeaders).map(([key, value]) => [key.toLowerCase(), value]));\n\n    //if headers does not contain content-type, add it\n    if (!jsonHeaders['content-type'] && contentType !== 'none') {\n        jsonHeaders['content-type'] = contentType;\n    }\n\n    return new AxiosHeaders(jsonHeaders);\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport { AxiosProxyConfig } from 'axios';\n\nexport async function parseProxy(input, config, agent: Agent): Promise<AxiosProxyConfig | false> {\n    const teamId = agent ? agent.teamId : null;\n    const templateSettings = config?.template?.settings || {};\n\n    let proxy = config?.data?.proxy;\n\n    if (!proxy) {\n        return false;\n    }\n\n    proxy = decodeURIComponent(proxy); //decode the url in order to parse the template vars\n\n    //parse component template vars\n    if (config.data._templateVars && templateSettings) {\n        proxy = await TemplateString(proxy)\n            .parseComponentTemplateVarsAsync(templateSettings) // replaces component template vars with their IDs (this turns the string parses into an async parser)\n            .parse(config.data._templateVars).asyncResult; // replaces IDs with actual values then returns parser promise\n    }\n\n    //parse vault keys\n    proxy = await TemplateString(proxy).parseTeamKeysAsync(teamId).asyncResult;\n\n    //parse input variables and clean up the remaining unparsed values\n    proxy = TemplateString(proxy).parse(input).clean().result;\n\n    //URL will take care of encoding the url properly\n    const urlObj = new URL(proxy);\n\n    const proxyConfig: AxiosProxyConfig = {\n        host: urlObj.hostname,\n        port: parseInt(urlObj.port),\n        auth: urlObj.username\n            ? {\n                  username: urlObj.username,\n                  password: urlObj.password,\n              }\n            : undefined,\n    };\n\n    return proxyConfig;\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\n\nexport default class FSleep extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const _error = undefined;\n            const delay = parseInt(config.data.delay || 1);\n            const Output = input.Input;\n            logger.debug(`Sleeping for ${delay} seconds`);\n            await new Promise((resolve) => setTimeout(resolve, delay * 1000));\n            return { Output, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error processing data \\n${_error}\\n`);\n            return { hash: undefined, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        }\n    }\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport crypto from 'crypto';\n\nexport default class FHash extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const _error = undefined;\n\n            const data = input.Data;\n            const algorithm = config.data.algorithm;\n            const encoding = config.data.encoding;\n            logger.debug(` Generating hash using ${algorithm} algorithm and ${encoding} encoding`);\n\n            const hashAlgo = crypto.createHash(algorithm);\n            hashAlgo.update(data);\n\n            const Hash = hashAlgo.digest(encoding);\n            logger.debug(` Generated hash: ${Hash}`);\n            return { Hash, _error, _debug: logger.output };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error generating hash \\n${_error}\\n`);\n            return { hash: undefined, _error, _debug: logger.output };\n        }\n    }\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\n\nexport default class FEncDec extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const _error = undefined;\n\n            const data = input.Data;\n            const action = config.data.action || 'Encode';\n            const encoding = config.data.encoding;\n            logger.debug(`${encoding} ${action} data`);\n\n            const Output = action == 'Encode' ? Buffer.from(data).toString(encoding) : Buffer.from(data, encoding).toString('utf8');\n\n            return { Output, _error, _debug: logger.output };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error processing data \\n${_error}\\n`);\n            return { hash: undefined, _error, _debug: logger.output };\n        }\n    }\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport crypto from 'crypto';\nimport querystring from 'querystring';\n\nexport default class FSign extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const _error = undefined;\n            const teamId = agent ? agent.teamId : null;\n\n            let data = input.Data;\n            //if (typeof data === 'object') data = JSON.stringify(data);\n            let signingKey = input.Key || config.data.key;\n            // signingKey = parseTemplate(signingKey, input, { processUnmatched: false });\n            // signingKey = await parseKey(signingKey, teamId);\n            signingKey = await TemplateString(signingKey).parse(input).parseTeamKeysAsync(teamId).asyncResult;\n\n            const signMethod = config.data.signMethod || 'HMAC';\n            const dataTransform = config.data.dataTransform || 'None';\n            const hashType = config.data.hashType || 'md5';\n            const RSA_padding = config.data.RSA_padding;\n            const RSA_saltLength = config.data.RSA_saltLength;\n            const encoding = config.data.encoding || 'hex';\n\n            if (typeof data != 'string') {\n                switch (dataTransform) {\n                    case 'Stringify':\n                        data = JSON.stringify(data);\n                        break;\n                    case 'Querystring':\n                        data = querystring.stringify(data);\n                        break;\n                }\n            }\n            logger.debug(' Data to sign = ', data);\n            logger.debug(` Signing data using ${signMethod} algorithm and ${encoding} encoding`);\n            const Signature = this.signData(data, signingKey, signMethod, encoding, { hashType, RSA_padding, RSA_saltLength });\n\n            logger.debug(` Signature generated: ${Signature}`);\n            return { Signature, _error, _debug: logger.output };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error generating hash \\n${_error}\\n`);\n            return { hash: undefined, _error, _debug: logger.output };\n        }\n    }\n\n    private signData(data, key, signMethod, encoding = 'hex', options: any = {}) {\n        // Determine if the algorithm is for HMAC or RSA/DSA/ECDSA\n        switch (signMethod) {\n            case 'RSA':\n                const algo = `${signMethod}-${options.hashType || 'md5'}`.toUpperCase();\n                const sign = crypto.createSign(algo);\n                sign.update(data);\n\n                const sign_options = {\n                    key,\n                    padding: options.RSA_padding ? crypto.constants[options.RSA_padding] : undefined,\n                    saltLength: options.RSA_saltLength ? crypto.constants[options.RSA_saltLength] : undefined,\n                };\n                // For RSA/DSA/ECDSA, options may include padding and saltLength\n                return sign.sign(sign_options, encoding.toLowerCase() as crypto.BinaryToTextEncoding);\n\n            case 'HMAC':\n                const hmac = crypto.createHmac(options.hashType, key);\n                hmac.update(data);\n                return hmac.digest(encoding as crypto.BinaryToTextEncoding);\n        }\n\n        return null;\n    }\n}\n","import Component from './Component.class';\nimport Agent from '@sre/AgentManager/Agent.class';\n\nexport default class FTimestamp extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            const _error = undefined;\n            const format = config.data.format; //TODO set timestamp format\n            const Timestamp = Date.now();\n            logger.debug(`Timestamp : ${Timestamp}`);\n\n            return { Timestamp, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error processing data \\n${_error}\\n`);\n            return { hash: undefined, _error, _debug: logger.output, _debug_time: logger.elapsedTime };\n        }\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\nimport Joi from 'joi';\nimport { validateCharacterSet } from '../utils';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { SmythFS } from '@sre/IO/Storage.service/SmythFS.class';\nimport { JSONContent, JSONContentHelper } from '@sre/helpers/JsonContent.helper';\nimport { IStorageVectorDataSource } from '@sre/types/VectorDB.types';\nimport { VectorsHelper } from '@sre/IO/VectorDB.service/Vectors.helper';\nimport DataSourceIndexer from './DataSourceIndexer.class';\n\nexport default class DataSourceCleaner extends Component {\n    protected configSchema = Joi.object({\n        namespaceId: Joi.string().max(50).allow('').label('namespace'),\n        id: Joi.string().custom(validateCharacterSet, 'custom validation characterSet').allow('').label('source identifier'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const teamId = agent.teamId;\n        const agentId = agent.id;\n        let debugOutput = agent.agentRuntime?.debug ? '== Source Indexer Log ==\\n' : null;\n\n        try {\n            const configSchema = this.validateConfigData(config.data);\n            if (configSchema.error) {\n                throw new Error(`Config data validation error: ${configSchema.error}\\n EXITING...`);\n            }\n\n            const outputs = {};\n            for (let con of config.outputs) {\n                if (con.default) continue;\n                outputs[con.name] = con?.description ? `<${con?.description}>` : '';\n            }\n\n            const inputSchema = this.validateInput(input);\n            if (inputSchema.error) {\n                throw new Error(`Input validation error: ${inputSchema.error}\\n EXITING...`);\n            }\n\n            const namespaceId = configSchema.value.namespaceId.split('_')?.slice(1).join('_') || configSchema.value.namespaceId;\n            let vectorDBHelper = VectorsHelper.load();\n\n            const customStorageConnector = await vectorDBHelper.getTeamConnector(teamId);\n            let vectorDbConnector = customStorageConnector || ConnectorService.getVectorDBConnector();\n\n            let existingnamespace = await vectorDbConnector.user(AccessCandidate.team(teamId)).getNamespace(namespaceId);\n            if (!existingnamespace) {\n                await vectorDbConnector.user(AccessCandidate.team(teamId)).createNamespace(namespaceId);\n                debugOutput += `[Created namespace] \\n${namespaceId}\\n\\n`;\n            } else if (!existingnamespace.metadata.isOnCustomStorage) {\n                // If the namespace exists but is not on custom storage, switch to the default connector.\n                vectorDbConnector = ConnectorService.getVectorDBConnector();\n            }\n\n            const providedId = TemplateString(config.data.id).parse(input).result;\n            const idRegex = /^[a-zA-Z0-9\\-\\_\\.]+$/;\n            if (!idRegex.test(providedId)) {\n                throw new Error(`Invalid id. Accepted characters: 'a-z', 'A-Z', '0-9', '-', '_', '.'`);\n            }\n            debugOutput += `Searching for data source with id: ${providedId}\\n`;\n\n            const dsId = DataSourceIndexer.genDsId(providedId, teamId, namespaceId);\n\n            await vectorDbConnector.user(AccessCandidate.team(teamId)).deleteDatasource(namespaceId, dsId);\n\n            debugOutput += `Deleted data source with id: ${providedId}\\n`;\n\n            return {\n                _debug: debugOutput,\n                Success: true,\n                // _error,\n            };\n        } catch (err: any) {\n            debugOutput += `Failed to delete data source: \\n Error: ${err?.message}\\n`;\n\n            return {\n                _debug: debugOutput,\n                _error: err?.message || \"Couldn't delete data source\",\n            };\n        }\n    }\n\n    validateInput(input: any) {\n        return Joi.object({}).unknown(true).validate(input);\n    }\n\n    validateConfigData(data: any) {\n        return Joi.object({\n            namespaceId: Joi.string().required(),\n            id: Joi.string().optional().allow('').allow(null),\n        })\n            .unknown(true)\n            .validate(data);\n    }\n}\n","import Joi from 'joi';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class JSONFilter extends Component {\n    protected configSchema = Joi.object({\n        fields: Joi.string().max(30000).allow('').label('Prompt'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n        logger.debug(`=== JSONFilter Log ===`);\n        let Output = {};\n        let _error = null;\n        try {\n            const componentId = config.id;\n            const fields = config.data.fields;\n            const obj = input.Input;\n\n            Output = filterFields(obj, fields);\n            logger.debug(`Output filtered`);\n        } catch (error: any) {\n            _error = error;\n            logger.error(` JSONFilter Error \\n ${error.toString()}`);\n        }\n        return { Output, _error, _debug: logger.output };\n    }\n}\n\nfunction filterFields(obj, fields) {\n    const fieldList = fields?.split(',').map((field) => field.trim());\n\n    function filterObject(obj) {\n        if (Array.isArray(obj)) {\n            return obj.map(filterObject);\n        } else if (obj !== null && typeof obj === 'object') {\n            return Object.keys(obj)\n                .filter((key) => fieldList.includes(key))\n                .reduce((acc, key) => {\n                    acc[key] = filterObject(obj[key]);\n                    return acc;\n                }, {});\n        }\n        return obj;\n    }\n\n    return filterObject(obj);\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicAND extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const logger = this.createComponentLogger(agent, config.name);\n        const result: any = { Output: true };\n\n        for (let cfgInput of config.inputs) {\n            // check if all inputs are set (expected inputs are in \"config.inputs\" actual inputs are in \"input\")\n            if (!input[cfgInput.name]) {\n                result.Output = undefined;\n                break;\n            }\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n        return result;\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicOR extends Component {\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const result: any = { Output: undefined };\n        console.log(input);\n        console.log(config);\n        for (let cfgInput of config.inputs) {\n            // check if one of the inputs are set (expected inputs are in \"config.inputs\" actual inputs are in \"input\")\n            if (input[cfgInput.name]) {\n                result.Output = true;\n                break;\n            }\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n\n        return result;\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\n\nexport default class LogicXOR extends Component {\n    constructor() {\n        super();\n    }\n\n    init() {}\n\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n        const result: any = { Output: undefined };\n        let trueCount = 0;\n\n        for (let cfgInput of config.inputs) {\n            // counts the number of set inputs\n            if (input[cfgInput.name]) {\n                trueCount++;\n            }\n        }\n        // checks if only one input is set, to trigger output\n        if (trueCount === 1) {\n            result.Output = true;\n        }\n\n        result.Verified = result.Output !== undefined;\n        result.Unverified = !result.Verified;\n        if (!result.Verified) delete result.Verified;\n        if (!result.Unverified) delete result.Unverified;\n\n        return result;\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport Component from './Component.class';\nimport axios from 'axios';\nimport Joi from 'joi';\nimport _config from '@sre/config';\nimport { TemplateStringHelper } from '@sre/helpers/TemplateString.helper';\n\nexport default class Code extends Component {\n    protected configSchema = Joi.object({\n        code_vars: Joi.string().max(1000).allow('').label('Variables'),\n        code_body: Joi.string().max(500000).allow('').label('Code'),\n        _templateSettings: Joi.object().allow(null).label('Template Settings'),\n        _templateVars: Joi.object().allow(null).label('Template Variables'),\n    });\n    constructor() {\n        super();\n    }\n    init() {}\n    async process(input, config, agent: Agent) {\n        await super.process(input, config, agent);\n\n        const logger = this.createComponentLogger(agent, config.name);\n        try {\n            let Output: any = {};\n            let _error = undefined;\n            const url = _config.env.CODE_SANDBOX_URL + '/run-js';\n\n            let codeInputs = {};\n            for (let fieldName in input) {\n                const _type = typeof input[fieldName];\n                switch (_type) {\n                    case 'string':\n                        //escape string\n                        //codeInputs[fieldName] = `\\`${input[fieldName]}\\``;\n\n                        //encode string\n                        const b64encoded = Buffer.from(input[fieldName]).toString('base64');\n                        codeInputs[fieldName] = `___internal.b64decode('${b64encoded}')`;\n\n                        break;\n                    case 'number':\n                    case 'boolean':\n                        codeInputs[fieldName] = input[fieldName];\n                        break;\n                    default:\n                        codeInputs[fieldName] = input[fieldName];\n                        break;\n                }\n            }\n            //FIXME : don't trust code_vars from user input ==> generate it\n\n            // let code_vars = parseTemplate(config.data.code_vars || '', codeInputs, { escapeString: false, processUnmatched: false });\n            let code_vars = TemplateStringHelper.create(config.data.code_vars || '').parse(codeInputs).result;\n            //TODO: the current template parser doesn't support the processUnmatched or unmached options !!!!\n            // code_vars = parseTemplate(code_vars || '', codeInputs, { escapeString: false, unmached: 'undefined' });\n            let code_body = config.data.code_body;\n            if (config.data._templateVars) {\n                // code_body = parseTemplate(code_body, config.data._templateVars);\n                code_body = TemplateStringHelper.create(code_body).parse(config.data._templateVars).result;\n            }\n            const code = code_vars + '\\n' + code_body;\n\n            logger.debug(` Running code \\n${code}\\n`);\n\n            const result: any = await axios.post(url, { code }).catch((error) => ({ error }));\n\n            if (result.error) {\n                _error = result.error?.response?.data || result.error?.message || result.error.toString();\n                logger.error(` Error running code \\n${_error}\\n`);\n                Output = undefined; //prevents running next component if the code execution failed\n            } else {\n                logger.debug(` Code result \\n${JSON.stringify(result.data, null, 2)}\\n`);\n                Output = result.data?.Output;\n            }\n\n            return { Output, _error, _debug: logger.output };\n        } catch (err: any) {\n            const _error = err?.response?.data || err?.message || err.toString();\n            logger.error(` Error running code \\n${_error}\\n`);\n            return { Output: undefined, _error, _debug: logger.output };\n        }\n    }\n}\n","import Agent from './Agent.class';\nimport { AgentCallLog } from '@sre/types/AgentLogger.types';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { uid } from '@sre/utils';\n\nconst console = Logger('AgentLogger');\n\nexport default class AgentLogger {\n    private static transactions: any = {};\n    constructor(private agent: Agent) {}\n    public static async cleanup() {\n        const trIds = Object.keys(AgentLogger.transactions);\n        for (const trId of trIds) {\n            const transaction = AgentLogger.transactions[trId];\n            if (transaction.canDelete()) {\n                delete AgentLogger.transactions[trId];\n            }\n        }\n    }\n    public static log(agent, trId, logData: AgentCallLog) {\n        if (!trId) trId = 'log-' + uid();\n        return trId;\n    }\n    public static async logTask(agent: Agent, tasks) {}\n}\n","import EventEmitter from 'events';\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\nimport config from '@sre/config';\nimport { delay, uid } from '@sre/utils';\nimport AgentRuntime from '@sre/AgentManager/AgentRuntime.class';\nimport { Logger } from '@sre/helpers/Log.helper';\n\nconst console = Logger('RuntimeContext');\n\ntype TRuntimeData = {\n    input?: { [key: string]: any };\n    _LoopData?: any;\n    _ChildLoopData?: any;\n};\ntype TComponentContext = {\n    active: boolean;\n    name: string;\n    runtimeData?: TRuntimeData;\n    step: number;\n    input?: { [key: string]: any };\n    output?: { [key: string]: any };\n};\nexport class RuntimeContext extends EventEmitter {\n    public circularLimitReached: string | boolean = false;\n    public step: number = 0;\n    public sessionResult: boolean = false;\n    public sessionResults: any;\n    public components: { [id: string]: { ctx: TComponentContext } } = {};\n\n    public checkRuntimeContext: any = null;\n\n    private ctxFile: string = '';\n    private _runtimeFileReady: any;\n\n    constructor(private runtime: AgentRuntime) {\n        super();\n        const agent = runtime.agent;\n        const dbgFolder = path.join(<string>config.env.DATA_PATH || path.join(os.tmpdir(), '.smyth') , `/debug/${agent.id}/`);\n        \n        if (!fs.existsSync(dbgFolder)) {\n            fs.mkdirSync(dbgFolder, { recursive: true });\n        }\n\n        const processRootID = runtime.processID?.split(':')[0] || '';\n        const reqId = processRootID == runtime.xDebugId ? '' : '.' + uid() + runtime.reqTag;\n        this.ctxFile = path.join(dbgFolder, `${runtime.xDebugId}${reqId}${agent.jobID ? `-job-${agent.jobID}` : ''}.json`);\n\n        this.initRuntimeContext();\n    }\n\n    private serialize() {\n        const data = {\n            step: this.step,\n            sessionResult: this.sessionResult,\n            sessionResults: this.sessionResults,\n            components: this.components,\n        };\n\n        return data;\n    }\n    private deserialize(data: any) {\n        this.step = data.step;\n        this.sessionResult = data.sessionResult;\n        this.sessionResults = data.sessionResults;\n        this.components = data.components;\n    }\n    private reset() {\n        this.step = 0;\n        this.sessionResult = false;\n        this.sessionResults = null;\n        this.components = {};\n    }\n\n    private initRuntimeContext() {\n        if (this._runtimeFileReady) return;\n\n        const endpointDBGCall = this.runtime.xDebugId?.startsWith('dbg-'); //weak check for debug session, we need to improve this\n        console.debug('Init ctxFile', this.ctxFile);\n        const agent = this.runtime.agent;\n        let method = (agent.agentRequest.method || 'POST').toUpperCase();\n        const endpoint = agent.endpoints?.[agent.agentRequest.path]?.[method];\n\n        let ctxData: any = {};\n        if (!fs.existsSync(this.ctxFile)) {\n            ctxData = JSON.parse(JSON.stringify({ components: agent.components, connections: agent.connections, timestamp: Date.now() }));\n            if (!ctxData.step) ctxData.step = 0;\n            for (let cptId in ctxData.components) {\n                ctxData.components[cptId] = {\n                    id: cptId,\n                    name: ctxData.components[cptId].name,\n                    //dbg: { active: false, name: ctxData.components[cptId].name },\n                    ctx: { active: false, name: ctxData.components[cptId].name },\n                };\n\n                const cpt = ctxData.components[cptId];\n                //if this debug session was initiated from an endpoint, we mark the endpoint component as active\n                if (endpoint && endpoint.id != undefined && cpt.id == endpoint.id && endpointDBGCall) {\n                    //cpt.dbg.active = true;\n                    cpt.ctx.active = true;\n                }\n            }\n            fs.writeFileSync(this.ctxFile, JSON.stringify(ctxData, null, 2));\n        } else {\n            ctxData = JSON.parse(fs.readFileSync(this.ctxFile, 'utf8'));\n            if (!ctxData.step) ctxData.step = 0;\n        }\n\n        this.deserialize(ctxData);\n        this._runtimeFileReady = true;\n        this.emit('ready');\n    }\n    public async sync() {\n        if (!this.ctxFile) return;\n        this.emit('syncing');\n\n        const deleteSession = this.runtime.sessionClosed;\n\n        if (deleteSession) {\n            if (this.runtime.debug && fs.existsSync(this.ctxFile)) await delay(1000 * 60); //if we're in debug mode, we keep the file for a while to allow final state read\n            if (fs.existsSync(this.ctxFile)) fs.unlinkSync(this.ctxFile);\n        } else {\n            const data = this.serialize();\n            if (data) fs.writeFileSync(this.ctxFile, JSON.stringify(data, null, 2));\n        }\n    }\n\n    public incStep() {\n        this.step++;\n        this.sync();\n    }\n\n    public updateComponent(componentId: string, data: any) {\n        const ctxData = this;\n        if (!ctxData) return;\n        const component = ctxData.components[componentId];\n\n        if (!component) {\n            console.log('>>>>>>> updateComponent Component debug data not found', componentId, component);\n            console.log('>>> ctxFile', this.ctxFile);\n            console.log('>>> ctxData', ctxData);\n        }\n        component.ctx = { ...component.ctx, ...data, step: this.step };\n\n        //if (this.debug) component.dbg = { ...component.dbg, ...data };\n\n        this.sync();\n    }\n    public resetComponent(componentId: string) {\n        const ctxData = this;\n        const component = ctxData.components[componentId];\n        if (!component) {\n            console.log('>>>>>>> resetComponent Component debug data not found', componentId, component);\n            console.log('>>> ctxFile', this.ctxFile);\n            console.log('>>> ctxData', ctxData);\n        }\n        //component.dbg.active = false;\n        //component.dbg.runtimeData = {};\n        component.ctx.runtimeData = {};\n        component.ctx.active = false;\n\n        this.sync();\n    }\n\n    public getComponentData(componentId: string) {\n        const ctxData = this;\n        if (!ctxData) return null;\n        const component = ctxData.components[componentId];\n        if (!component) {\n            console.log('>>>>>>> getComponentData Component debug data not found', componentId, component);\n            console.log('>>> ctxFile', this.ctxFile);\n            console.log('>>> ctxData', ctxData);\n        }\n        //const data = this.debug ? component.dbg : component.ctx;\n        const data = component.ctx;\n\n        return data;\n    }\n}\n","import fs from 'fs';\nimport path from 'path';\nimport Agent from './Agent.class';\nimport Component from '@sre/Components/Component.class';\nimport componentInstance from '@sre/Components/index';\n\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { uid } from '@sre/utils';\nimport { RuntimeContext } from '@sre/MemoryManager/RuntimeContext';\n\nconst console = Logger('AgentRuntime');\nconst AgentRuntimeUnavailable = new Proxy(\n    {},\n    {\n        get: function (target, prop, receiver) {\n            // Check if the property being accessed is a function\n            if (typeof target[prop] === 'function') {\n                return target[prop];\n            } else {\n                // Return a function that logs \"unavailable\"\n                return function () {\n                    console.warn(`AgentRuntime Unavailable tried to call : ${prop.toString()}`);\n                };\n            }\n        },\n    }\n);\nexport default class AgentRuntime {\n    private static processResults: any = {};\n    private static tagsData = {};\n    public static dummy = AgentRuntimeUnavailable;\n\n    private agentContext: RuntimeContext;\n    //private ctxFile: string = '';\n    private xDebugRun: string | undefined = '';\n    private xDebugInject: string | undefined = '';\n    private xDebugRead: string | undefined = '';\n    private xDebugStop: string | undefined = '';\n    private xDebugPendingInject: any = null;\n    public xDebugId: string | undefined = '';\n    private xDebugCmd: string | undefined = '';\n    private _debugActive = false;\n    private _runtimeFileReady = false;\n    public sessionClosed = false;\n\n    private reqTagOwner = false;\n\n    //reqTag is used to identify the current running workflow including nested calls, it allows us to identify circular calls\n    public reqTag: any;\n    public processID: any; //this identifies the current processID, a process ID is the full set of runCycles that is executed by the agent.\n    public workflowReqId: any; //this identifies the current running workflow. a workflow starts when and agent endpoint is called, or a debug session is initiated, and ends when no more steps can be executed.\n\n    public alwaysActiveComponents: any = {};\n    public exclusiveComponents: any = {};\n\n    private checkRuntimeContext: any = null;\n\n    public get circularLimitReached() {\n        return this.agentContext?.circularLimitReached || false;\n    }\n    public set circularLimitReached(value) {\n        if (this.agentContext) this.agentContext.circularLimitReached = value;\n    }\n\n    public get debug() {\n        return this._debugActive;\n    }\n    public get curStep() {\n        return this.agentContext?.step || 0;\n    }\n\n    constructor(public agent: Agent) {\n        this.reqTag = agent.agentRequest.header('X-REQUEST-TAG');\n        const isNestedProcess: boolean = !!this.reqTag;\n\n        if (!this.reqTag) {\n            //tagged request should not be run in debug mode, this comes from a parent agent\n            this.xDebugStop = agent.agentRequest.header('X-DEBUG-STOP');\n            this.xDebugRun = agent.agentRequest.header('X-DEBUG-RUN'); //send this as header to create a session and attach it\n            this.xDebugInject = agent.agentRequest.header('X-DEBUG-INJ');\n            this.xDebugRead = agent.agentRequest.header('X-DEBUG-READ');\n            this.reqTag = 'xTAG-' + uid(); //if request tag is not set, set a new value, this will be used to tag nested agent calls\n            this.reqTagOwner = true;\n        } else {\n            this.xDebugStop = undefined;\n            this.xDebugRun = undefined;\n            this.xDebugInject = undefined;\n            this.xDebugRead = undefined;\n        }\n\n        this.xDebugId = this.xDebugStop || this.xDebugRun || this.xDebugRead;\n\n        //if (req.body) {\n        if (!this.xDebugId && agent.agentRequest.body) {\n            if (this.xDebugInject != undefined && this.xDebugInject != null) {\n                this.xDebugPendingInject = agent.agentRequest.body;\n                this.xDebugRun = this.xDebugInject || 'inj-' + uid();\n            } else {\n                if (this.xDebugRun == '') {\n                    this.xDebugRun = 'dbg-' + uid(); //generate a random debug id\n                }\n            }\n            this.xDebugId = this.xDebugRun;\n        }\n\n        this.processID = this.xDebugId;\n\n        if (!this.xDebugId) {\n            //if it's not a debug session, processID is unique per request\n            this.xDebugId = agent.sessionId;\n            this.processID = this.reqTag;\n        }\n        if (isNestedProcess) {\n            // Need to make processID unique to run same sub-agents multiple times in parallel\n            this.processID += `:${Math.floor(1000 + Math.random() * 9000)}`;\n        }\n\n        //we need a way to identify current running workflow in a unique way\n        //=> In debug mode, xDebugRun holds the debug sessionID which is unique per workflow run\n        //   if the debug session is stopped, xDebugStop holds the sessionID\n        //   Note : We can't use reqTag in debug mode because it changes every time a new debug step is executed\n        //\n        //=> In normal mode, reqTag is unique per workflow run\n        this.workflowReqId = this.xDebugRun || this.xDebugStop || this.reqTag;\n\n        //tagsData can be updated from external integrations (eg. Chatbot, API Endpoint, etc.)\n        if (!AgentRuntime.tagsData[this.reqTag]) AgentRuntime.tagsData[this.reqTag] = {};\n        if (!AgentRuntime.processResults[this.processID])\n            AgentRuntime.processResults[this.processID] = {\n                timestamp: Date.now(),\n                errorResults: [],\n                sessionResults: [],\n            };\n\n        this.agentContext = new RuntimeContext(this);\n        this.agentContext.on('ready', () => {\n            this.alwaysActiveComponents = {};\n            this.exclusiveComponents = {};\n            for (let component of this.agent.data.components) {\n                const cpt: Component = componentInstance[component.name];\n                if (!cpt) {\n                    console.warn(`Component ${component.name} Exists in agent but has no implementation`);\n                    continue;\n                }\n\n                if (cpt.alwaysActive) {\n                    this.alwaysActiveComponents[component.id] = cpt;\n                    this.updateComponent(component.id, { active: true, alwaysActive: true });\n                    const runtimeData = { ...this.getRuntimeData(component.id) };\n                    this.saveRuntimeComponentData(component.id, runtimeData);\n                }\n                if (cpt.exclusive) {\n                    this.exclusiveComponents[component.id] = cpt;\n                    this.updateComponent(component.id, { exclusive: true });\n                    const runtimeData = { ...this.getRuntimeData(component.id) };\n                    this.saveRuntimeComponentData(component.id, runtimeData);\n                }\n            }\n        });\n\n        //if xDebugId is equal to agent session, it means that the debugging features are not active\n        this._debugActive = this.xDebugId != agent.sessionId;\n\n        //console.debug(`New Agent Runtime initialized for agentId=${this.agent.id}  tag=${this.reqTag} debug file=${this.ctxFile}`);\n    }\n\n    public destroy() {\n        this.sessionClosed = true;\n        this.sync();\n    }\n\n    public incTag(componentId) {\n        if (!AgentRuntime.tagsData[this.reqTag][componentId]) AgentRuntime.tagsData[this.reqTag][componentId] = 0;\n        AgentRuntime.tagsData[this.reqTag][componentId]++;\n\n        // console.log(\n        //     `incTag agentId=${this.agent.id} componentId=${componentId} tag=${this.reqTag} ==> ${AgentRuntime.tagsData[this.reqTag][componentId]}`,\n        // );\n        //console.log('incTag tagsData', tagsData);\n    }\n\n    public async sync() {\n        //if (!this.ctxFile) return;\n\n        const deleteTag = (this.reqTagOwner && this.sessionClosed) || this.circularLimitReached;\n        if (deleteTag) {\n            console.log('>>>>>>>>>>>> deleting tagsData', this.reqTag);\n            delete AgentRuntime.tagsData[this.reqTag];\n        }\n\n        this.agentContext.sync();\n    }\n    public getWaitingComponents() {\n        const ctxData = this.agentContext;\n        const dbgComponents: any = Object.values(ctxData?.components || []).filter((c: any) => c?.ctx?.active == true);\n        const waitingComponents: any = dbgComponents.filter((c: any) => c?.ctx?.status && typeof c?.ctx?.output !== undefined);\n        return waitingComponents;\n    }\n    public getExclusiveActiveComponents() {\n        const ctxData = this.agentContext;\n        const dbgComponents: any = Object.values(ctxData?.components || []).filter((c: any) => c?.ctx?.active == true);\n        const exclusiveActiveComponents: any = dbgComponents.filter((c: any) => c?.ctx?.exclusive == true);\n        return exclusiveActiveComponents;\n    }\n    public readState(stateId: string, deltaOnly = false) {\n        //if (!this._debugActive || !this.xDebugRead) return null;\n        if (!this._debugActive || !stateId) return null;\n\n        //this.checkRuntimeContext();\n        const runtime = this;\n        const agent = this.agent;\n\n        const ctxData = runtime.agentContext;\n        const dbgAllComponents: any = runtime.xDebugPendingInject || Object.values(ctxData?.components || []);\n\n        //first try to find exclusive active components\n        let dbgActiveComponents: any;\n        dbgActiveComponents = dbgAllComponents.filter((c: any) => c?.ctx?.active == true && c?.ctx?.exclusive == true);\n        //if no exclusive active components, find all active components\n        if (!dbgActiveComponents || dbgActiveComponents.length == 0)\n            dbgActiveComponents = dbgAllComponents.filter(\n                (c: any) =>\n                    c?.ctx?.active == true ||\n                    (!c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0)\n            );\n        //find waiting components that was not previously run\n        const dbgActiveWaitingComponents: any = dbgAllComponents.filter(\n            (c: any) => c?.ctx?.active == true && c?.ctx?.status && typeof c?.ctx?.output !== undefined\n        );\n\n        const dbgActiveReadyComponents: any = dbgAllComponents.filter((c: any) => c?.ctx?.active == true && !c?.ctx?.status);\n\n        let state = {};\n        for (let dbgComponent of dbgAllComponents) {\n            state[dbgComponent.id] = dbgComponent.ctx;\n        }\n\n        //let dbgSession: any = runtime.xDebugRead;\n        let dbgSession: any = stateId;\n\n        // let alwaysActiveComponents = 0;\n        // for (let activeCpt of dbgActiveComponents) {\n        //     if (this.agent.alwaysActiveComponents[activeCpt.id]) alwaysActiveComponents++;\n        // }\n\n        if (!dbgActiveComponents || dbgActiveComponents.length == 0 /*|| dbgActiveComponents.length == alwaysActiveComponents*/) {\n            dbgSession = null;\n            runtime.sessionClosed = true;\n        }\n\n        const remainingActiveComponents: any = Object.values(ctxData?.components || []).filter(\n            (c: any) => c?.ctx?.active == true && !c?.ctx?.alwaysActive\n        );\n        const activeAsyncComponents: any = Object.values(ctxData?.components || []).filter(\n            (c: any) => !c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0\n        );\n\n        if (remainingActiveComponents.length == 0 && activeAsyncComponents.length == 0 /*&& awaitingInputs.length == 0*/) {\n            runtime.sessionClosed = true;\n        }\n\n        if (runtime.circularLimitReached) {\n            const circularLimitData = runtime.checkCircularLimit();\n            const error = `Circular Calls Limit Reached on ${circularLimitData}. Current agent circular limit is ${agent.circularLimit}`;\n            runtime.sessionClosed = true;\n            return { state, dbgSession, sessionClosed: runtime.sessionClosed, error };\n        }\n\n        const step = this.curStep >= 1 ? this.curStep - 1 : 0; //current state was executed in previous step\n\n        if (deltaOnly) {\n            const delta = {};\n            for (let cptId in state) {\n                const cpt = state[cptId];\n\n                //workaround, here we are supposed to test component steps that are equalt to current step\n                //but due to an inconsistency, the Async component has sometimes a step greater than the current step\n                if (cpt.step >= step) delta[cptId] = cpt;\n                //FIXME : identify the root cause of this issue and replace >= with ==\n            }\n            //return { state: delta, dbgSession, sessionClosed: runtime.sessionClosed, step };\n            state = delta;\n        }\n\n        return { state, dbgSession, sessionClosed: runtime.sessionClosed, step };\n    }\n\n    /**\n     * This method is called by the agent to run a process cycle, it will run all active components and return the results\n     * The function is called multiple times until all components are executed and no more active components are available\n     * @returns\n     */\n    public async runCycle() {\n        console.debug(\n            `runCycle agentId=${this.agent.id} wfReqId=${this.workflowReqId}  reqTag=${this.reqTag} session=${this.xDebugRun} cycleId=${this.processID}`\n        );\n        //this.checkRuntimeContext();\n\n        const runtime = this;\n        const agent = this.agent;\n        const ctxData = runtime.agentContext;\n        const dbgAllComponents: any = runtime.xDebugPendingInject || Object.values(ctxData?.components || []);\n\n        //first try to find exclusive active components\n        let dbgActiveComponents: any;\n        dbgActiveComponents = dbgAllComponents.filter((c: any) => c?.ctx?.active == true && c?.ctx?.exclusive == true);\n        //if no exclusive active components, find all active components\n        if (!dbgActiveComponents || dbgActiveComponents.length == 0)\n            dbgActiveComponents = dbgAllComponents.filter(\n                (c: any) =>\n                    c?.ctx?.active == true ||\n                    (!c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0)\n            );\n        //find waiting components that was not previously run\n        const dbgActiveWaitingComponents: any = dbgAllComponents.filter(\n            (c: any) => c?.ctx?.active == true && c?.ctx?.status && typeof c?.ctx?.output !== undefined\n        );\n        const dbgActiveReadyComponents: any = dbgAllComponents.filter(\n            (c: any) =>\n                (c?.ctx?.active == true && !c?.ctx?.status) ||\n                (!c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0)\n        );\n        //const dbgActiveReadyComponents: any = dbgActiveComponents.filter((c: any) => c?.ctx?.active == true && !c?.ctx?.status);\n\n        let step: any;\n\n        if (!dbgActiveComponents || dbgActiveComponents.length == 0) {\n            runtime.sessionClosed = true;\n            step = {\n                state: { sessionClosed: true },\n                dbgSession: null,\n                //expiredDbgSession: runtime.xDebugRun || runtime.xDebugStop,\n                expiredDbgSession: runtime.xDebugId,\n                sessionClosed: true,\n            };\n        }\n\n        if (!step && dbgActiveComponents.length == dbgActiveWaitingComponents.length && ctxData.sessionResult) {\n            runtime.sessionClosed = true;\n            step = {\n                state: { sessionClosed: true },\n                dbgSession: null,\n                //expiredDbgSession: runtime.xDebugRun,\n                expiredDbgSession: runtime.xDebugId,\n                sessionClosed: true,\n            };\n        }\n        if (!step && dbgActiveReadyComponents.length > 0) {\n            const promises: any = [];\n\n            for (let dbgComponent of dbgActiveReadyComponents) {\n                const injectInput = runtime.xDebugPendingInject ? dbgComponent.ctx.input : undefined;\n                promises.push(agent.callComponent(dbgComponent.ctx.sourceId, dbgComponent.id, injectInput));\n            }\n            const dbgResults = await Promise.all(promises);\n            const state = dbgResults.length == 1 ? dbgResults[0] : dbgResults;\n\n            runtime.xDebugPendingInject = null;\n\n            const remainingActiveComponents: any = Object.values(ctxData?.components || []).filter((c: any) => c?.ctx?.active == true);\n            const activeAsyncComponents: any = Object.values(ctxData?.components || []).filter(\n                (c: any) => !c?.ctx?.output?._error && Array.isArray(c?.ctx?._job_components) && c?.ctx?._job_components.length > 0\n            );\n            const dbgActiveWaitingComponents: any = dbgAllComponents.filter((c: any) => c?.ctx?.status && typeof c?.ctx?.output !== undefined);\n\n            if (dbgActiveWaitingComponents.length == remainingActiveComponents.length) {\n                ctxData.sessionResult = true;\n            }\n\n            //capture results\n            let sessionResults = dbgResults.flat().filter(\n                (e) =>\n                    e.id &&\n                    e.result &&\n                    !e.result._missing_inputs &&\n                    //check if this is the last component in the chain\n                    !agent.connections.find((c) => c.sourceId == e.id)\n            );\n\n            let errorResults = dbgResults.flat().filter((e) => e.id && (e.error || e.result?._error));\n\n            //also filter out erroneous components that are children of a loop\n            //otherwise, errors inside a loop will be reported as session results and can lead to wrong results or generated noise in the final agent output\n            errorResults = errorResults.filter((e) => {\n                return !ctxData?.components?.[e.id]?.ctx?.runtimeData?._ChildLoopData;\n            });\n\n            if (ctxData.sessionResult && sessionResults.length == 0 && runtime.sessionClosed) {\n                //no result ? check if we have errors\n                sessionResults = errorResults;\n            }\n\n            ctxData.sessionResults = sessionResults;\n            step = {\n                state,\n                dbgSession: runtime.xDebugRun,\n                sessionResult: runtime.agentContext.sessionResult,\n                sessionResults: runtime.agentContext.sessionResults,\n                errorResults,\n                sessionClosed: remainingActiveComponents.length == 0 && activeAsyncComponents.length == 0 /*&& awaitingInputs.length == 0*/,\n            };\n        } else {\n            runtime.sessionClosed = true;\n            //return { sessionClosed: true };\n            step = {\n                state: { sessionClosed: true },\n                dbgSession: null,\n                //expiredDbgSession: runtime.xDebugRun || runtime.xDebugStop,\n                expiredDbgSession: runtime.xDebugId,\n                sessionClosed: true,\n            };\n        }\n\n        this.checkCircularLimit();\n        if (step.sessionResults) {\n            AgentRuntime.processResults[this.processID].sessionResults.push(step.sessionResults);\n        }\n        if (step.errorResults) {\n            AgentRuntime.processResults[this.processID].errorResults.push(step.errorResults);\n        }\n\n        if (step?.sessionClosed || this.circularLimitReached) {\n            const finalResult = this.processResults();\n            step.finalResult = finalResult;\n            runtime.sessionClosed = true;\n        }\n\n        this.incStep();\n        this.sync();\n        return step;\n    }\n\n    private processResults() {\n        //this.checkCircularLimit();\n        let result: any = { error: 'Error processing results' };\n        const sessionResults = AgentRuntime.processResults[this.processID].sessionResults;\n        const errorResults = AgentRuntime.processResults[this.processID].errorResults;\n        if (this.circularLimitReached) {\n            const circularLimitData = this.circularLimitReached;\n            result = { error: `Circular Calls Limit Reached on ${circularLimitData}. Current circular limit is ${this.agent.circularLimit}` };\n        } else {\n            let state = [sessionResults, errorResults].flat(Infinity);\n            if (!state || state.length == 0) state = errorResults.flat(Infinity);\n\n            //post process run cycle results\n            //deduplicating redundant entries\n\n            const data = state\n                .reduce(\n                    (acc, current) => {\n                        if (!acc.seen[current.id]) {\n                            acc.result.push(current);\n                            acc.seen[current.id] = true;\n                        }\n                        return acc;\n                    },\n                    { seen: {}, result: [] }\n                )\n                .result.filter((e) => !e.result?._exclude);\n\n            //data.forEach((d: any) => delete d?.result?._debug);\n\n            result = data;\n            /////////////\n        }\n\n        //cleanup\n        delete AgentRuntime.processResults[this.processID];\n\n        this.sync();\n        return result;\n    }\n\n    public checkCircularLimit() {\n        if (this.circularLimitReached) return this.agentContext.circularLimitReached;\n        for (let componentId in AgentRuntime.tagsData[this.reqTag]) {\n            if (AgentRuntime.tagsData[this.reqTag][componentId] > this.agent.circularLimit) {\n                this.sessionClosed = true;\n                this.agentContext.circularLimitReached = componentId;\n                return componentId;\n            }\n        }\n        return false;\n    }\n\n    public async injectDebugOutput(componentId: string) {\n        if (this.xDebugPendingInject) {\n            const component = this.xDebugPendingInject.find((c: any) => c.id == componentId);\n            if (component?.ctx?.output) {\n                //if all outputs values are empty, we don't inject\n                let allEmpty = true;\n                for (let key in component.ctx.output) {\n                    if (component.ctx.output[key] != '') {\n                        allEmpty = false;\n                        break;\n                    }\n                }\n                if (allEmpty) return null;\n\n                return component.ctx.output;\n            }\n        }\n    }\n    public getRuntimeData(componentId) {\n        const componentData = this.getComponentData(componentId);\n        if (!componentData) return {};\n        const rData = componentData.runtimeData || {};\n\n        return rData;\n    }\n    public updateRuntimeData(componentId, data) {\n        const componentData = this.getComponentData(componentId);\n        if (!componentData) return;\n        componentData.runtimeData = { ...componentData.runtimeData, ...data };\n\n        this.sync();\n    }\n\n    public saveRuntimeComponentData(componentId, data) {\n        this.updateComponent(componentId, { runtimeData: data });\n    }\n\n    public incStep() {\n        this.agentContext.incStep();\n    }\n    public updateComponent(componentId: string, data: any) {\n        this.agentContext.updateComponent(componentId, data);\n    }\n\n    public resetComponent(componentId: string) {\n        this.agentContext.resetComponent(componentId);\n    }\n\n    public getComponentData(componentId: string) {\n        return this.agentContext.getComponentData(componentId);\n    }\n}\n","import os from 'os';\nimport process from 'process';\n\nconst OSResourceMonitor: any = {\n    mem: getMemoryUsage(),\n    //processMemory: getProcessMemoryUsage(),\n    cpu: getCpuUsage(),\n    //processCpu: getProcessCpuUsage(),\n};\nexport default OSResourceMonitor;\n\nfunction getCpuUsage() {\n    const cpus = os.cpus();\n    let user = 0;\n    let nice = 0;\n    let sys = 0;\n    let idle = 0;\n    let irq = 0;\n    let total = 0;\n\n    for (let cpu of cpus) {\n        user += cpu.times.user;\n        nice += cpu.times.nice;\n        sys += cpu.times.sys;\n        idle += cpu.times.idle;\n        irq += cpu.times.irq;\n    }\n\n    total = user + nice + sys + idle + irq;\n\n    return {\n        user: (user / total) * 100,\n        sys: (sys / total) * 100,\n        idle: (idle / total) * 100,\n        load: 100 - (idle / total) * 100,\n    };\n}\n\nfunction getMemoryUsage() {\n    const totalMemory = os.totalmem();\n    const freeMemory = os.freemem();\n    const usedMemory = totalMemory - freeMemory;\n\n    return {\n        totalMemory: (totalMemory / 1024 ** 3).toFixed(2) + ' GB',\n        freeMemory: (freeMemory / 1024 ** 3).toFixed(2) + ' GB',\n        usedMemory: (usedMemory / 1024 ** 3).toFixed(2) + ' GB',\n        memoryUsagePercentage: ((usedMemory / totalMemory) * 100).toFixed(2),\n    };\n}\n\nfunction getProcessMemoryUsage() {\n    const memoryUsage = process.memoryUsage();\n    return {\n        total: memoryUsage.rss,\n        heapTotal: (memoryUsage.heapTotal / 1024 ** 2).toFixed(2) + ' MB',\n        heapUsed: (memoryUsage.heapUsed / 1024 ** 2).toFixed(2) + ' MB',\n        external: (memoryUsage.external / 1024 ** 2).toFixed(2) + ' MB',\n    };\n}\n\nfunction getProcessCpuUsage() {\n    const cpuUsage = process.cpuUsage();\n    return {\n        user: cpuUsage.user,\n        system: cpuUsage.system,\n    };\n}\n\nfunction logSystemUsage() {\n    OSResourceMonitor.mem = getMemoryUsage();\n    OSResourceMonitor.cpu = getCpuUsage();\n    //OSResourceMonitor.processMemory = getProcessMemoryUsage();\n    //OSResourceMonitor.processCpu = getProcessCpuUsage();\n}\n\n//setInterval(logSystemUsage, 5000); // update every 5 seconds\n","import Component from '@sre/Components/Component.class';\nimport componentInstance from '@sre/Components/index';\nimport AgentLogger from './AgentLogger.class';\nimport AgentRequest from './AgentRequest.class';\nimport AgentRuntime from './AgentRuntime.class';\nimport AgentSettings from './AgentSettings.class';\nimport OSResourceMonitor from './OSResourceMonitor';\n\nimport config from '@sre/config';\nimport { delay, getCurrentFormattedDate, uid } from '@sre/utils/index';\n\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { TemplateString } from '@sre/helpers/TemplateString.helper';\n\nconst console = Logger('Agent');\nconst idPromise = (id) => id;\nexport default class Agent {\n    public name: any;\n    public data: any;\n    public teamId: any;\n    public components: any;\n    public connections: any;\n    public endpoints: any = {};\n    public sessionId;\n    public sessionTag = '';\n    public callerSessionId;\n    public apiBasePath = '/api';\n    public agentRuntime: AgentRuntime | any;\n\n    public usingTestDomain = false;\n    public domain = '';\n    public debugSessionEnabled = false;\n    public circularLimit = 100; //TODO : make it configurable from agent settings\n    public version = '';\n    //public baseUrl = '';\n    public agentVariables: any = {};\n    private _kill = false;\n    //public agentRequest: Request | AgentRequest | any;\n    public async = false;\n    public jobID = '';\n    public planInfo: any = {};\n\n    public agentRequest: AgentRequest;\n    constructor(\n        public id,\n        agentData,\n        public agentSettings: AgentSettings,\n        agentRequest?: AgentRequest | any //private req: express.Request,\n    ) {\n        //this.agentRequest = new AgentRequest(req);\n        const json = typeof agentData === 'string' ? JSON.parse(agentData) : agentData;\n        this.data = json.data;\n        //this.agentVariables = json.data.variables || {};\n\n        this.name = this.data.name;\n        this.version = this.data.agentVersion || ''; //when version is not set we load the latest dev version\n        this.teamId = this.data.teamId;\n        this.connections = this.data.connections;\n        this.debugSessionEnabled = this.data.debugSessionEnabled;\n\n        this.agentVariables = this.data.variables || {};\n\n        //parse vault agent variables\n        // if (typeof json.data.variables === 'object') {\n        //     for (let key in json.data.variables) {\n        //         const value = json.data.variables[key];\n        //         if (value.startsWith('{{') && value.endsWith('}}')) {\n        //             utils.parseKey(value, this.teamId).then((result) => {\n        //                 this.agentVariables[key] = result;\n        //             });\n        //         } else {\n        //             this.agentVariables[key] = value;\n        //         }\n        //     }\n        // }\n\n        // Base URL required to serve binary data\n        //this.baseUrl = `https://${id}.${config.env.AGENT_DOMAIN}`;\n        //if (config.env.AGENT_DOMAIN_PORT) this.baseUrl += `:${config.env.AGENT_DOMAIN_PORT}`;\n\n        const endpoints = this.data.components.filter((c) => c.name == 'APIEndpoint');\n        for (let endpoint of endpoints) {\n            let method = endpoint.data.method || 'POST';\n            method = method.toUpperCase();\n            if (!this.endpoints[`${this.apiBasePath}/${endpoint.data.endpoint}`])\n                this.endpoints[`${this.apiBasePath}/${endpoint.data.endpoint}`] = {};\n            this.endpoints[`${this.apiBasePath}/${endpoint.data.endpoint}`][method] = endpoint;\n        }\n\n        this.components = {};\n        for (let component of this.data.components) {\n            //FIXME : this does not persist in debug mode, it breaks key value mem logic\n\n            this.components[component.id] = component;\n        }\n\n        for (let connection of this.data.connections) {\n            const sourceComponent = this.components[connection.sourceId];\n            const targetComponent = this.components[connection.targetId];\n            const sourceIndex = connection.sourceIndex;\n            const targetIndex = connection.targetIndex;\n\n            if (!sourceComponent.outputs[sourceIndex].next) sourceComponent.outputs[sourceIndex].next = [];\n            sourceComponent.outputs[sourceIndex].next.push(targetComponent.id);\n\n            if (!targetComponent.inputs[targetIndex].prev) targetComponent.inputs[targetIndex].prev = [];\n            targetComponent.inputs[targetIndex].prev.push(sourceComponent.id);\n        }\n\n        this.tagAsyncComponents();\n\n        if (agentRequest) {\n            this.setRequest(agentRequest);\n        }\n\n        //this.settings = new AgentSettings(this.id);\n    }\n\n    public setRequest(agentRequest: AgentRequest | any) {\n        if (this.agentRequest) return;\n        this.agentRequest = agentRequest;\n        this.agentRequest = agentRequest;\n        const dateTime = getCurrentFormattedDate();\n        this.sessionId = 'rt-' + (this.agentRequest.sessionID || dateTime + '.' + uid());\n\n        const sessionTags = this?.agentRequest?.headers['x-session-tag'];\n        if (sessionTags) this.sessionTag += this.sessionTag ? `,${sessionTags}` : sessionTags;\n\n        var regex = new RegExp(`^\\/v[0-9]+(\\.[0-9]+)?${this.apiBasePath}\\/(.*)`);\n        if (this.agentRequest?.path?.startsWith(`${this.apiBasePath}/`) || this.agentRequest?.path?.match(regex)) {\n            //we only need runtime context for API calls\n            this.agentRuntime = new AgentRuntime(this);\n            this.callerSessionId =\n                this?.agentRequest?.headers['x-caller-session-id']?.substring(0, 256) || this.agentRuntime.workflowReqId || this.sessionId;\n        } else {\n            this.agentRuntime = AgentRuntime.dummy;\n        }\n    }\n\n    public kill() {\n        this._kill = true;\n    }\n    private async parseVariables() {\n        //parse vault agent variables\n        if (typeof this.agentVariables === 'object') {\n            for (let key in this.agentVariables) {\n                const value = this.agentVariables[key];\n                if (value.startsWith('{{') && value.endsWith('}}')) {\n                    //this.agentVariables[key] = (await parseKey(value, this.teamId)) || '';\n                    this.agentVariables[key] = await TemplateString(value).parseTeamKeysAsync(this.teamId).asyncResult;\n                }\n            }\n        }\n    }\n\n    async process(endpointPath, input) {\n        //TODO: replace endpointPath + input params with a single agentRequest object. (This will require intensive regression testing)\n        let result: any;\n        let dbgSession: any = null;\n        let sessionClosed = false;\n\n        //this.agentRuntime.checkRuntimeContext();\n        //insert log\n        const logId = AgentLogger.log(this, null, {\n            sourceId: endpointPath,\n            componentId: `AGENT`,\n            domain: this.domain,\n            input,\n            workflowID: this.agentRuntime.workflowReqId,\n            processID: this.agentRuntime.processID,\n            inputTimestamp: new Date().toISOString(),\n            sessionID: this.callerSessionId,\n            tags: this.sessionTag,\n        });\n\n        const method = this.agentRequest.method.toUpperCase();\n        const endpoint = this.endpoints[endpointPath]?.[method];\n\n        //first check if this is a debug session, and return debug result if it's the case\n        if (this.agentRuntime.debug) {\n            if (!endpoint && this.agentRequest.path != '/api/') {\n                if (logId) AgentLogger.log(this, logId, { error: `Endpoint ${method} ${endpointPath} Not Found` });\n                throw new Error(`Endpoint ${method} ${endpointPath} Not Found`);\n            }\n            let dbgResult: any;\n            //let dbgResult: any = await this.agentRuntime.readState(true); //is this a debug read reqeust ?\n\n            if (!dbgResult) dbgResult = await this.agentRuntime.runCycle(); //no, is this a step over request ?\n\n            // result = dbgResult?.state;\n            // dbgSession = dbgResult?.dbgSession;\n            // sessionClosed = dbgResult?.sessionClosed;\n            if (dbgResult && typeof dbgResult?.state !== 'undefined') {\n                this.agentRuntime.sync();\n                if (dbgResult?.finalResult) {\n                    dbgResult.finalResult = await this.postProcess(dbgResult.finalResult).catch((error) => ({ error }));\n                }\n                return dbgResult;\n            }\n        }\n\n        if (!endpoint) {\n            if (logId) AgentLogger.log(this, logId, { error: `Endpoint ${method} ${endpointPath} Not Found` });\n            throw new Error(`Endpoint ${method} ${endpointPath} Not Found`);\n        }\n\n        this.agentRuntime.updateComponent(endpoint.id, { active: true, input, sourceId: null });\n\n        let step;\n        do {\n            step = await this.agentRuntime.runCycle();\n\n            //adjust latency based on cpu load\n            const qosLatency = Math.floor(OSResourceMonitor.cpu.load * this.planInfo?.maxLatency || 0);\n\n            await delay(30 + qosLatency);\n        } while (!step?.finalResult && !this._kill);\n\n        if (this._kill) {\n            console.warn(`Agent ${this.id} was killed`);\n            return { error: 'Agent killed' };\n        }\n        result = await this.postProcess(step?.finalResult).catch((error) => ({ error }));\n\n        //post process all results\n        if (this.agentRuntime.circularLimitReached) {\n            const circularLimitData = this.agentRuntime.circularLimitReached;\n            result = { error: `Circular Calls Limit Reached on ${circularLimitData}. Current circular limit is ${this.circularLimit}` };\n            throw new Error(`Circular Calls Limit Reached on ${circularLimitData}. Current circular limit is ${this.circularLimit}`);\n        }\n\n        if (logId) AgentLogger.log(this, logId, { outputTimestamp: '' + Date.now(), result });\n\n        this.updateTasksCount(); //Important, don't use await here, we need the call to be non blocking\n\n        //FIXME: does debug call ever reach this point ?\n        return this.agentRuntime.debug ? { state: result, dbgSession, sessionClosed } : result;\n    }\n\n    private async updateTasksCount() {\n        //tasks count update logic\n    }\n\n    public async postProcess(result) {\n        if (Array.isArray(result)) result = result.flat(Infinity);\n        if (!Array.isArray(result)) result = [result];\n\n        for (let i = 0; i < result.length; i++) {\n            const _result = result[i];\n            if (!_result) continue;\n            if (_result._debug) delete _result._debug;\n            if (_result._debug_time) delete _result._debug_time;\n            const _componentData = this.components[_result.id];\n            if (!_componentData) continue;\n            const _component: Component = componentInstance[_componentData.name];\n            if (!_component) continue;\n            //if (_component.hasPostProcess) {\n            const postProcessResult = await _component.postProcess(_result, _componentData, this).catch((error) => ({ error }));\n\n            result[i] = postProcessResult;\n            //}\n        }\n\n        if (result.length == 1) result = result[0];\n        return result;\n    }\n\n    // public saveRuntimeComponentData(componentId, data) {\n    //     //let runtimeData = { ...this.agentRuntime.getRuntimeData(componentId), ...data };\n    //     //this.agentRuntime.updateComponent(componentId, { runtimeData: data });\n\n    //     this.agentRuntime.saveRuntimeComponentData(componentId, data);\n    // }\n    // private getRuntimeData(componentId) {\n    //     // const componentData = this.agentRuntime.getComponentData(componentId);\n    //     // if (!componentData) return {};\n    //     // const rData = componentData.runtimeData || {};\n\n    //     return this.agentRuntime.getRuntimeData(componentId);\n    // }\n\n    // private clearRuntimeComponentData(componentId) {\n    //     this.agentRuntime.resetComponent(componentId);\n    // }\n\n    private hasLoopAncestor(inputEntry) {\n        if (!inputEntry.prev) return false;\n        for (let prevId of inputEntry.prev) {\n            const prevComponentData = this.components[prevId];\n            if (prevComponentData.name == 'ForEach') return true;\n\n            for (let inputEntry of prevComponentData.inputs) {\n                if (this.hasLoopAncestor(inputEntry)) return true;\n            }\n        }\n    }\n\n    private clearChildLoopRuntimeComponentData(componentId) {\n        const componentData = this.components[componentId];\n        const runtimeData = this.agentRuntime.getRuntimeData(componentId);\n        if (runtimeData._ChildLoopData) {\n            for (let inputEntry of componentData.inputs) {\n                if (this.hasLoopAncestor(inputEntry)) {\n                    delete runtimeData.input[inputEntry.name];\n                }\n            }\n        }\n    }\n    private getComponentMissingInputs(componentId, _input) {\n        let missingInputs: any = [];\n        const componentData = this.components[componentId];\n        const component: Component = componentInstance[componentData.name];\n        if (component.alwaysActive) return missingInputs;\n\n        const readablePredecessors = this.findReadablePredecessors(componentId);\n        const readableInputNames = {};\n        for (let pred of readablePredecessors) {\n            if (pred) {\n                readableInputNames[pred.input.name] = pred;\n            }\n        }\n        //readablePredecessors.map((e) => e.input.name);\n\n        const allInputIndexes = this.connections.filter((c) => c.targetId == componentId).map((e) => e.targetIndex);\n        const allInputs = componentData.inputs.filter((r) => allInputIndexes.includes(r.index));\n\n        if (Array.isArray(allInputs) && allInputs.length > 0) {\n            //if the next component has named inputs\n            for (let input of allInputs) {\n                if (input.optional) continue;\n                if (readableInputNames[input.name]) {\n                    const pred = readableInputNames[input.name];\n                    const component: Component = pred.component;\n                    const predComponentData = this.components[pred.id];\n                    const foundOutput = component.hasOutput(pred.output.name, predComponentData, this);\n                    if (foundOutput) continue; //if the input is readable, skip it, because we can read it's value when needed. Readable inputs are non blocking\n                }\n                if (typeof _input[input.name] == 'undefined' /* || _input[input.name] == null*/) {\n                    missingInputs.push(input.name);\n                }\n            }\n        }\n\n        return missingInputs;\n    }\n\n    public findReadablePredecessors(componentId) {\n        const componentData = this.components[componentId];\n        const component: Component = componentInstance[componentData.name];\n\n        const connections = this.connections.filter((c) => c.targetId == componentId);\n        const readablePredecessors = connections.map((c) => {\n            //this.components[c.sourceId])\n            const sourceComponentData = this.components[c.sourceId];\n            const sourceComponent: Component = componentInstance[sourceComponentData.name];\n            const output = sourceComponentData.outputs[c.sourceIndex];\n            const input = componentData.inputs[c.targetIndex];\n            if (sourceComponent.hasReadOutput) {\n                return { output, input, component: sourceComponent, id: c.sourceId };\n            }\n            return null;\n        });\n\n        return readablePredecessors.filter((e) => e != null);\n    }\n\n    /**\n     *\n     * @param sourceId\n     * @param componentId\n     */\n    private updateStep(sourceId, componentId) {\n        const agentRuntime = this.agentRuntime;\n        const step = agentRuntime.curStep;\n        const componentData = agentRuntime.getComponentData(componentId);\n\n        // if (!componentData.steps) componentData.steps = {};\n        // if (!componentData.steps[step]) componentData.steps[step] = { sources: [] };\n        // componentData.steps[step].sources.push(sourceId);\n\n        // if (!componentData.stepSources) componentData.stepSources = {};\n        // if (!componentData.stepSources[sourceId]) componentData.stepSources[sourceId] = [];\n        // componentData.stepSources[sourceId].push(step);\n\n        agentRuntime.updateComponent(componentId, { step });\n    }\n\n    async callComponent(sourceId, componentId, input?) {\n        const agentRuntime = this.agentRuntime;\n        const componentData = this.components[componentId];\n        const component: Component = componentInstance[componentData.name];\n\n        if (this._kill) {\n            console.warn(`Agent ${this.id} was killed, skipping component ${componentData.name}`);\n            return { id: componentData.id, name: componentData.displayName, result: null, error: 'Agent killed' };\n        }\n\n        if (!component) {\n            throw new Error(`Component ${componentData.name} not found`);\n        }\n\n        this.agentRuntime.incTag(componentId);\n        this.agentRuntime.checkCircularLimit();\n        if (this.agentRuntime.circularLimitReached) {\n            return { error: `Circular Calls Reached` };\n        }\n\n        const data = agentRuntime.getComponentData(componentId);\n        if (data?.output?._missing_inputs) {\n            agentRuntime.updateComponent(componentId, { output: {} });\n        }\n\n        const _input = this.prepareComponentInput(componentId, input);\n\n        //insert log\n        const logId = AgentLogger.log(this, null, {\n            sourceId: sourceId || 'AGENT',\n            componentId,\n            domain: this.domain,\n            workflowID: this.agentRuntime.workflowReqId,\n            processID: this.agentRuntime.processID,\n            input:\n                componentData.name == 'APIEndpoint' ? (this.agentRequest.method == 'GET' ? this.agentRequest.query : this.agentRequest.body) : _input,\n            inputTimestamp: new Date().toISOString(),\n            sessionID: this.callerSessionId,\n            tags: this.sessionTag,\n        });\n\n        let output: any = null;\n        let missingInputs: any = [];\n\n        //agentRuntime.updateComponent(componentId, { step: agentRuntime.curStep });\n        this.updateStep(sourceId, componentId);\n\n        //first we check if the debugger is injecting an output, if yes we skip the inputs check\n        if (agentRuntime.debug) {\n            output = await agentRuntime.injectDebugOutput(componentId);\n        }\n\n        if (!output) {\n            missingInputs = this.getComponentMissingInputs(componentId, _input);\n\n            if (missingInputs.length > 0) {\n                agentRuntime.updateComponent(componentId, { active: true, status: 'waiting' });\n                //check if _error output is connected to a component\n                const connections = this.connections.filter((c) => c.sourceId == componentId) || [];\n                let hasErrorHandler = false;\n                for (let connection of connections) {\n                    const outputEndpoint = componentData.outputs[connection.sourceIndex];\n                    if (outputEndpoint.name == '_error') {\n                        hasErrorHandler = true;\n                        break;\n                    }\n                }\n                //if (hasErrorHandler) return { id: componentData.id, name: componentData.name, result: null };\n\n                output = { _error: 'Missing inputs : ' + JSON.stringify(missingInputs), _missing_inputs: missingInputs };\n            }\n\n            if (!output) {\n                //the following case happens when no debugger injection was performed\n                const validationResult = await component.validateConfig(componentData);\n                if (validationResult._error) {\n                    output = validationResult;\n                } else {\n                    try {\n                        await this.parseVariables(); //make sure that any vault variable is loaded before processing the component\n                        //TODO: apply type inference here instead of in the component .process method\n                        output = await component.process({ ...this.agentVariables, ..._input }, componentData, this);\n                        console.log(output);\n                    } catch (error: any) {\n                        //this are fatal errors requiring to cancel the execution of this component.\n                        console.error('Error on component process: ', { componentId, name: componentData.name, input: _input }, error);\n                        if (error?.message) output = { Response: undefined, _error: error.message, _debug: error.message };\n                        else output = { Response: undefined, _error: error.toString(), _debug: error.toString() };\n                    }\n                }\n            }\n        }\n        const runtimeData = this.agentRuntime.getRuntimeData(componentId);\n        agentRuntime.updateComponent(componentId, { output });\n\n        if (output._in_progress) {\n            agentRuntime.updateComponent(componentId, { active: true, status: 'in_progress' });\n        }\n\n        if (output.error || output._error) {\n            //TODO : check if we need to keep loop data while clearing runtime data here\n            //in fact, output._error might be connected to a next component, in which case we need to keep the loop data\n            if (!runtimeData?._ChildLoopData?._in_progress) {\n                //don't reset if we are inside a loop, otherwise ._error branches will break the loop\n\n                this.agentRuntime.resetComponent(componentId);\n            }\n\n            if (logId) {\n                //update log\n                AgentLogger.log(this, logId, { error: output.error || output._error });\n            }\n            if (output.error)\n                return [\n                    {\n                        id: componentData.id,\n                        name: componentData.displayName,\n                        result: null,\n                        error: output.error || output._error,\n                        _debug: output.error || output._error,\n                    },\n                ];\n        }\n\n        let results: any = [];\n        if (output /*&& !component.hasReadOutput*/ && !output._missing_inputs) {\n            AgentLogger.logTask(this, 1); //log successful task (non blocking call)\n\n            //proceed with the next component(s)\n            results = await this.callNextComponents(componentId, output).catch((error) => ({\n                error,\n                id: componentData.id,\n                name: componentData.displayName,\n            }));\n\n            //TODO : maybe handle the number of branches inside ForEach component\n            if (runtimeData._LoopData && output._in_progress && runtimeData._LoopData.branches == undefined) {\n                //handle loop branching\n                const branches = Array.isArray(results) ? results.length : 1;\n                if (output._in_progress) {\n                    runtimeData._LoopData.branches = branches;\n                    agentRuntime.updateRuntimeData(componentId, { _LoopData: runtimeData._LoopData });\n                }\n            }\n\n            if (results._is_leaf) {\n                //we reached the end of the execution tree, we need to check if this branch is a loop\n                delete results._is_leaf;\n                const _ChildLoopData = runtimeData._ChildLoopData;\n                if (_ChildLoopData && _ChildLoopData.parentId) {\n                    const parentId = _ChildLoopData.parentId;\n                    const _LoopData = this.agentRuntime.getRuntimeData(parentId)._LoopData;\n                    if (_LoopData) {\n                        if (!_LoopData.result) _LoopData.result = [];\n                        //we are in a loop, we need to update loop parent status in order to signal that we can run the next loop cycle\n\n                        let resultsCopy = JSON.parse(JSON.stringify(results));\n                        if (results.result) results.result._exclude = true;\n\n                        resultsCopy = await component.postProcess(resultsCopy, componentData, this);\n\n                        _LoopData.result.push(resultsCopy);\n                        _LoopData.branches--;\n\n                        if (_LoopData.branches <= 0) {\n                            agentRuntime.updateComponent(parentId, { active: true, status: '' }); //remove _in_progress status after processing all branches\n                        }\n                        //save the last result so that the loop parent can read it\n                        agentRuntime.updateRuntimeData(parentId, { _LoopData });\n                    }\n                } else {\n                    //leaf but no childLoopData, is this a loop component with no children ?\n                    const _LoopData = this.agentRuntime.getRuntimeData(componentId)._LoopData;\n                    if (_LoopData && _LoopData.loopIndex == 1) {\n                        _LoopData._in_progress = false;\n                        output._in_progress = false;\n                        agentRuntime.updateComponent(componentId, { active: true, status: '' });\n                        agentRuntime.updateRuntimeData(componentId, { _LoopData });\n                    }\n                }\n            }\n        }\n\n        //check if the component context is potentially needed in next cycles\n        if (!output._missing_inputs && !output._in_progress) {\n            //we processed the current component, we can now reset the runtime data and active status\n            const inLoop =\n                runtimeData?._ChildLoopData?._in_progress && runtimeData._ChildLoopData?.loopIndex < runtimeData._ChildLoopData?.loopLength;\n            if (inLoop) {\n                // loop children require to keep external runtime data, we only clear the data that was set inside the loop\n                this.clearChildLoopRuntimeComponentData(componentId);\n                agentRuntime.updateComponent(componentId, { active: true, status: 'waiting' });\n            } else {\n                this.agentRuntime.resetComponent(componentId); //also sets active to false\n            }\n        } //if inputs were missing, the output contains error information, not actual component processing output, in this case we keep the runtime data\n\n        //filter out null results\n        if (Array.isArray(results)) results = results.flat(Infinity).filter((r) => r.result != null);\n\n        if (logId) {\n            //update log\n            AgentLogger.log(this, logId, { output, outputTimestamp: '' + Date.now() });\n        }\n\n        //return this.agentRuntime.debug ? [results, { id: componentData.id, name: componentData.name, result: output }] : results;\n        return [results, { id: componentData.id, name: componentData.displayName, result: output }];\n    }\n    JSONExpression(obj, propertyString) {\n        const properties = propertyString.split(/\\.|\\[|\\]\\.|\\]\\[|\\]/).filter(Boolean);\n        let currentProperty = obj;\n\n        for (let property of properties) {\n            if (currentProperty === undefined || currentProperty === null) {\n                return undefined;\n            }\n\n            currentProperty = currentProperty[property];\n        }\n\n        return currentProperty;\n    }\n\n    //\n    async callNextComponents(componentId, output) {\n        const agentRuntime = this.agentRuntime;\n        //agentRuntime.incStep();\n\n        const componentData = this.components[componentId];\n        const component: Component = componentInstance[componentData.name];\n\n        //if (component.hasReadOutput) return [];\n\n        //get the list of connections for the current component in order to determine the next component(s) to call\n        let connections = this.connections\n            .filter((c) => c.sourceId == componentId /*|| this.alwaysActiveComponents[c.sourceId]*/)\n            .map((c) => ({ ...c, output, componentData }));\n\n        //also find connections from always active components to components with status 'waiting'\n\n        const waitingComponents = agentRuntime.getWaitingComponents();\n        const waitingComponentIds = waitingComponents.map((e) => e.id);\n        const alwaysActiveIds = Object.keys(this.agentRuntime.alwaysActiveComponents);\n        const alwaysActiveConnections = this.connections\n            .filter((c) => alwaysActiveIds.includes(c.sourceId) && waitingComponentIds.includes(c.targetId))\n            .map((c) => {\n                const output = {};\n                const waitingComponent = waitingComponents.find((e) => e.id == c.targetId);\n                const prevComponentData = this.components[c.sourceId];\n                const prevComponent: Component = componentInstance[prevComponentData.name];\n                const outputEndpoint = prevComponentData.outputs[c.sourceIndex];\n                output[outputEndpoint.name] = prevComponent.readOutput(outputEndpoint.name, prevComponentData, this);\n\n                return { ...c, output, componentData: this.components[c.sourceId] };\n            });\n        connections = [...connections, ...alwaysActiveConnections];\n\n        //no more components to call, return the output\n        if (!Array.isArray(connections) || connections.length == 0) {\n            return { id: componentData.id, name: componentData.name, result: output, _is_leaf: true };\n        }\n\n        const targetComponents = //classify connections by objects\n            connections.reduce((acc, obj) => {\n                let key = obj.targetId;\n                if (!acc[key]) {\n                    acc[key] = [];\n                }\n                acc[key].push(obj);\n                return acc;\n            }, {});\n\n        const promises: any = [];\n        for (let targetId in targetComponents) {\n            const targetComponentData = this.components[targetId];\n\n            //if we are not inside an async component, we skip async branches\n            //Note : we exclude Async component from this rule because it's the one that initiates the async job\n            if (!this.async && targetComponentData.async && targetComponentData.name !== 'Async') continue;\n\n            const targetComponent: Component = componentInstance[targetComponentData.name];\n            const connections = targetComponents[targetId];\n\n            if (Array.isArray(connections) && connections.length > 0) {\n                const nextInput = {};\n                for (let connection of connections) {\n                    const output = connection.output;\n                    const componentData = connection.componentData;\n                    const outputEndpoint = componentData.outputs[connection.sourceIndex]; //source\n                    const inputEndpoint = targetComponentData.inputs[connection.targetIndex]; //target\n\n                    //outputs can be named (e.g \"user:email\" or \"Req:body:data\") in which case they refer to a path in the output object\n                    const outputExpression = outputEndpoint.expression || outputEndpoint.name;\n                    const outputParts = outputExpression.split('.');\n\n                    const defaultOutputs = componentData.outputs.find((c) => c.default);\n                    let value: any = undefined;\n                    if (outputEndpoint.default) value = output[outputEndpoint.name] /* || null*/;\n                    else {\n                        if (defaultOutputs /* && output[defaultOutputs.name]?.[outputEndpoint.name]*/) {\n                            value = output[defaultOutputs.name]?.[outputEndpoint.name];\n                        }\n                    }\n                    if (/*value === null || */ value === undefined && outputParts.length >= 1) {\n                        let val = this.JSONExpression(output, outputExpression);\n                        if (val !== undefined) value = val;\n                    }\n\n                    // if (/*value !== null && */ value !== undefined) {\n                    //     nextInput[inputEndpoint.name] = [...new Set([[nextInput[inputEndpoint.name], value]].flat(Infinity))].filter(\n                    //         (e) => e !== undefined /*&& e !== null*/,\n                    //     );\n\n                    //     if (nextInput[inputEndpoint.name].length == 1) nextInput[inputEndpoint.name] = nextInput[inputEndpoint.name][0];\n                    // }\n\n                    //Fix suggested by Sentinel Agent\n                    if (/*value !== null && */ value !== undefined) {\n                        // let combinedInput = [...[nextInput[inputEndpoint.name]].flat(), ...[value].flat()].filter(\n                        //     (e) => e !== undefined /*&& e !== null*/,\n                        // ); // ! Deprecated\n\n                        let combinedInput = _mergeInputs(nextInput[inputEndpoint.name], value).filter((e) => e !== undefined /*&& e !== null*/);\n\n                        nextInput[inputEndpoint.name] = combinedInput.length === 1 ? combinedInput[0] : combinedInput;\n                    }\n                }\n                if (!nextInput || JSON.stringify(nextInput) == '{}') continue;\n\n                const input = this.prepareComponentInput(targetId, nextInput);\n\n                const targetComponent = this.components[targetId];\n\n                const missingInputs = this.getComponentMissingInputs(targetId, input);\n                const status = missingInputs.length > 0 ? 'waiting' : undefined;\n\n                const sourceRuntimeData = this.agentRuntime.getRuntimeData(componentId); //We read the previous component runtime data\n\n                let _ChildLoopData = sourceRuntimeData._LoopData; //is the source a loop component ?\n\n                if (!_ChildLoopData || !_ChildLoopData._in_progress) {\n                    //if it's a loop component we need to check if the loop is still in progress\n\n                    _ChildLoopData = sourceRuntimeData._ChildLoopData; // if the loop is completed, check if the loop component is a nested loop, in which case we pass the parent context to the following component\n                }\n\n                agentRuntime.updateComponent(targetId, { active: true, input: nextInput, sourceId: componentId, status });\n                agentRuntime.updateRuntimeData(targetId, { _ChildLoopData, _LoopData: null });\n                promises.push(idPromise({ id: targetId, name: targetComponent.name, inputs: nextInput }));\n\n                if (status) {\n                    //if status is set, track the component status update\n                    //if not set, it means that the component is active and will be logged upon execution\n                    //this can be considered as a fake log step that help us keep track of the execution tree\n                    const logId = AgentLogger.log(this, null, {\n                        sourceId: componentId,\n                        componentId: targetId,\n                        step: this.agentRuntime.curStep + 1, //we force to next step because the current step order is updated in the next runCycle()\n                        domain: this.domain,\n                        workflowID: this.agentRuntime.workflowReqId,\n                        processID: this.agentRuntime.processID,\n                        input: { __action: 'status_update', __status: status, data: nextInput },\n                        inputTimestamp: new Date().toISOString(),\n                        sessionID: this.callerSessionId,\n                        tags: this.sessionTag,\n                    });\n                }\n            }\n        }\n\n        if (promises.length == 0) {\n            return { id: componentData.id, name: componentData.name, result: output, _is_leaf: true };\n        }\n        const results = await Promise.all(promises);\n\n        //TODO : exclusive components handling\n        //in order to run exclusive components first, we need to run them in current cycle\n        //then we signal to the caller component that one more run cycle is needed\n        return results.length == 1 ? results[0] : results;\n    }\n    private prepareComponentInput(targetId, inputs) {\n        const rData: any = this.agentRuntime.getRuntimeData(targetId);\n        const componentData = this.components[targetId];\n        const rDataInput = rData?.input || {};\n\n        let _input = { ...rDataInput };\n        if (inputs) {\n            // for (let key in inputs) {\n            //     let value = inputs[key];\n            //     //_input[key] = mergeJsonData(_input[key], value);\n\n            //     _input[key] = [...new Set([[rDataInput[key]], [value]].flat(Infinity))].filter((e) => e !== undefined /* && e !== null*/);\n            //     if (_input[key].length == 1) _input[key] = _input[key][0];\n            // }\n\n            //Fix suggested by Sentinel Agent\n            for (let key in inputs) {\n                let value = inputs[key];\n                // Concatenate the existing value with the new input, without using Set to preserve duplicates\n                // _input[key] = [rDataInput[key], value].flat(Infinity).filter((e) => e !== undefined); // ! Deprecated\n                _input[key] = _mergeInputs(rDataInput[key], value).filter((e) => e !== undefined);\n\n                // Simplify the array to a single value if there is only one element after flattening\n                if (_input[key].length == 1) _input[key] = _input[key][0];\n            }\n        }\n\n        const readablePredecessors = this.findReadablePredecessors(targetId);\n        for (let c of readablePredecessors) {\n            if (c) {\n                const predComponentData = this.components[c.id];\n                const value = c.component.readOutput(c.output.name, predComponentData, this);\n                if (value && c.input?.name) {\n                    if (!_input) _input = {};\n                    _input[c.input.name] = value;\n                }\n            }\n        }\n\n        //this.saveRuntimeComponentData(targetId, { input: _input }); //TODO : check if we can use this.agentRuntime.updateRuntimeData instead (need to be carefully tested)\n        this.agentRuntime.updateRuntimeData(targetId, { input: _input });\n\n        for (let input of componentData.inputs) {\n            if (input.defaultVal && _input[input.name] === undefined) {\n                _input[input.name] = TemplateString(input.defaultVal).parse(this.agentVariables).result;\n                //parseTemplate(input.defaultVal, this.agentVariables, { escapeString: false, processUnmatched: false });\n            }\n        }\n        return _input;\n    }\n\n    public getConnectionSource(connection) {\n        return this.components[connection.sourceId].inputs.find((e) => e.index === connection.sourceIndex);\n    }\n\n    public getConnectionTarget(connection) {\n        return this.components[connection.targetId].inputs.find((e) => e.index === connection.targetIndex);\n    }\n\n    private recursiveTagAsyncComponents(component) {\n        const agent = this;\n        for (let output of component.outputs) {\n            if (component.name == 'Async' && output.name === 'JobID') continue; //'JobID' is a special output\n            const connected = agent.connections.filter((c) => c.sourceId === component.id && c.sourceIndex === output.index);\n            if (!connected) continue;\n            for (let con of connected) {\n                const targetComponent = agent.components[con.targetId];\n                if (!targetComponent) continue;\n                targetComponent.async = true;\n                this.recursiveTagAsyncComponents(targetComponent);\n            }\n        }\n    }\n    private tagAsyncComponents() {\n        const agent = this;\n        const componentsList: any[] = Object.values(agent.components);\n        const AsyncComponents: any[] = componentsList.filter((c) => c.name === 'Async');\n        if (!AsyncComponents || AsyncComponents.length == 0) return;\n        for (let AsyncComponent of AsyncComponents) {\n            AsyncComponent.async = true;\n            this.recursiveTagAsyncComponents(AsyncComponent);\n        }\n\n        //AsyncComponents.async = true;\n\n        //this.recursiveTagAsyncComponents(AsyncComponent, agent);\n    }\n}\n\nfunction _mergeInputs(existing, newValue) {\n    if (existing === undefined) {\n        return [newValue];\n    }\n\n    if (!Array.isArray(existing)) {\n        existing = [existing];\n    }\n\n    return [...existing, newValue];\n}\n","import { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL } from '@sre/types/ACL.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\n\nexport interface IStorageRequest {\n    read(resourceId: string): Promise<StorageData>;\n    write(resourceId: string, value: StorageData, acl?: IACL, metadata?: StorageMetadata): Promise<void>;\n    delete(resourceId: string): Promise<void>;\n    exists(resourceId: string): Promise<boolean>;\n    getMetadata(resourceId: string): Promise<StorageMetadata | undefined>;\n    setMetadata(resourceId: string, metadata: StorageMetadata): Promise<void>;\n    getACL(resourceId: string): Promise<ACL | undefined>;\n    setACL(resourceId: string, acl: IACL): Promise<void>;\n}\n\nexport abstract class StorageConnector extends SecureConnector {\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n\n    protected abstract read(acRequest: AccessRequest, resourceId: string): Promise<StorageData>;\n    protected abstract write(acRequest: AccessRequest, resourceId: string, value: StorageData, acl?: IACL, metadata?: StorageMetadata): Promise<void>;\n    protected abstract delete(acRequest: AccessRequest, resourceId: string): Promise<void>;\n    protected abstract exists(acRequest: AccessRequest, resourceId: string): Promise<boolean>;\n\n    protected abstract getMetadata(acRequest: AccessRequest, resourceId: string): Promise<StorageMetadata | undefined>;\n    protected abstract setMetadata(acRequest: AccessRequest, resourceId: string, metadata: StorageMetadata): Promise<void>;\n\n    protected abstract getACL(acRequest: AccessRequest, resourceId: string): Promise<ACL | undefined>;\n    protected abstract setACL(acRequest: AccessRequest, resourceId: string, acl: IACL): Promise<void>;\n\n    public user(candidate: AccessCandidate): IStorageRequest {\n        return {\n            write: async (resourceId: string, value: StorageData, acl?: IACL, metadata?: StorageMetadata) => {\n                return await this.write(candidate.writeRequest, resourceId, value, acl, metadata);\n            },\n            read: async (resourceId: string) => {\n                return await this.read(candidate.readRequest, resourceId);\n            },\n            delete: async (resourceId: string) => {\n                await this.delete(candidate.readRequest, resourceId);\n            },\n            exists: async (resourceId: string) => {\n                return await this.exists(candidate.readRequest, resourceId);\n            },\n            getMetadata: async (resourceId: string) => {\n                return await this.getMetadata(candidate.readRequest, resourceId);\n            },\n            setMetadata: async (resourceId: string, metadata: StorageMetadata) => {\n                await this.setMetadata(candidate.writeRequest, resourceId, metadata);\n            },\n            getACL: async (resourceId: string) => {\n                return await this.getACL(candidate.readRequest, resourceId);\n            },\n            setACL: async (resourceId: string, acl: IACL) => {\n                return await this.setACL(candidate.writeRequest, resourceId, acl);\n            },\n        } as IStorageRequest;\n    }\n}\n","//==[ SRE: S3Storage ]======================\n\n//#region = [Polyfill for CommonJS] =================================\n\n//S3 Methods fail in CommonJS build because they expect a global 'crypto' object with a 'getRandomValues' method\n//getRandomValues is supposed to be for browser environments, but it seems that CommonJS build leaks some browser related code to the packaged AWS-SDK\nimport crypto from 'crypto';\n\nObject.defineProperty(global, 'crypto', {\n    value: {\n        getRandomValues: (arr: any) => crypto.randomBytes(arr.length),\n    },\n});\n//#endregion\n\nimport { DeleteObjectCommand, GetObjectCommand, HeadObjectCommand, PutObjectCommand, S3Client, S3ClientConfig } from '@aws-sdk/client-s3';\n\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { IStorageRequest, StorageConnector } from '@sre/IO/Storage.service/StorageConnector';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { IAccessCandidate, IACL, TAccessLevel, TAccessResult, TAccessRole } from '@sre/types/ACL.types';\nimport { S3Config } from '@sre/types/AWS.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\nimport { streamToBuffer } from '@sre/utils';\nimport type { Readable } from 'stream';\n\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\n\nconst console = Logger('S3Storage');\n\nexport class S3Storage extends StorageConnector {\n    public name = 'S3Storage';\n    private client: S3Client;\n    private bucket: string;\n\n    constructor(config: S3Config & { bucket: string }) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n        this.bucket = config.bucket;\n        const clientConfig: S3ClientConfig = {};\n        if (config.region) clientConfig.region = config.region;\n        if (config.accessKeyId && config.secretAccessKey) {\n            clientConfig.credentials = {\n                accessKeyId: config.accessKeyId,\n                secretAccessKey: config.secretAccessKey,\n            };\n        }\n\n        this.client = new S3Client(clientConfig);\n    }\n\n    /**\n     * Reads an object from the S3 bucket.\n     *\n     * @param {string} resourceId - The key of the object to be read.\n     * @returns {Promise<any>} - A promise that resolves with the object data.\n     */\n\n    @SecureConnector.AccessControl\n    public async read(acRequest: AccessRequest, resourceId: string) {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        const command = new GetObjectCommand({\n            Bucket: this.bucket,\n            Key: resourceId,\n        });\n\n        try {\n            const response = await this.client.send(command);\n            //const metadata = response.Metadata;\n            return await streamToBuffer(response.Body as Readable);\n        } catch (error) {\n            if (error.name === 'NotFound' || error.name === 'NoSuchKey') {\n                return undefined;\n            }\n            console.error(`Error reading object from S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async getMetadata(acRequest: AccessRequest, resourceId: string): Promise<StorageMetadata | undefined> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        try {\n            const s3Metadata = await this.getS3Metadata(resourceId);\n            return s3Metadata as StorageMetadata;\n        } catch (error) {\n            console.error(`Error getting access rights in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async setMetadata(acRequest: AccessRequest, resourceId: string, metadata: StorageMetadata) {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        try {\n            let s3Metadata = await this.getS3Metadata(resourceId);\n            if (!s3Metadata) s3Metadata = {};\n            //s3Metadata['x-amz-meta-data'] = metadata;\n            s3Metadata = { ...s3Metadata, ...metadata };\n            await this.setS3Metadata(resourceId, s3Metadata);\n        } catch (error) {\n            console.error(`Error setting access rights in S3`, error);\n            throw error;\n        }\n    }\n    /**\n     * Writes an object to the S3 bucket.\n     *\n     * @param {string} resourceId - The key of the object to be written.\n     * @param {any} value - The value of the object to be written.\n     * @param {Metadata} metadata - Optional metadata to be associated with the object.\n     * @returns {Promise<void>} - A promise that resolves when the object has been written.\n     */\n    @SecureConnector.AccessControl\n    async write(acRequest: AccessRequest, resourceId: string, value: StorageData, acl?: IACL, metadata?: StorageMetadata): Promise<void> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        const accessCandidate = acRequest.candidate;\n\n        let amzACL = ACL.from(acl).addAccess(accessCandidate.role, accessCandidate.id, TAccessLevel.Owner).ACL;\n        let s3Metadata = {\n            ...metadata,\n            'x-amz-meta-acl': amzACL,\n        };\n\n        const command = new PutObjectCommand({\n            Bucket: this.bucket,\n            Key: resourceId,\n            Body: value,\n            Metadata: this.serializeS3Metadata(s3Metadata),\n            ContentType: s3Metadata['ContentType'],\n        });\n\n        try {\n            const result: any = await this.client.send(command);\n        } catch (error) {\n            console.error(`Error writing object to S3`, error.name, error.message);\n            //console.error(error);\n            throw error;\n        }\n    }\n\n    /**\n     * Deletes an object from the S3 bucket.\n     *\n     * @param {string} resourceId - The key of the object to be deleted.\n     * @returns {Promise<void>} - A promise that resolves when the object has been deleted.\n     */\n    @SecureConnector.AccessControl\n    async delete(acRequest: AccessRequest, resourceId: string): Promise<void> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        const command = new DeleteObjectCommand({\n            Bucket: this.bucket,\n            Key: resourceId,\n        });\n\n        try {\n            await this.client.send(command);\n        } catch (error) {\n            console.error(`Error deleting object from S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async exists(acRequest: AccessRequest, resourceId: string): Promise<boolean> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n        const command = new HeadObjectCommand({\n            Bucket: this.bucket,\n            Key: resourceId,\n        });\n\n        try {\n            await this.client.send(command);\n            return true;\n        } catch (error) {\n            if (error.name === 'NotFound' || error.name === 'NoSuchKey') {\n                return false;\n            }\n\n            console.error(`Error checking object existence in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    //this determines the access rights for the requested resource\n    //the connector should check if the resource exists or not\n    //if the resource exists we read it's ACL and return it\n    //if the resource does not exist we return an write access ACL for the candidate\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate) {\n        const s3Metadata = await this.getS3Metadata(resourceId);\n        const exists = s3Metadata !== undefined; //undefined metadata means the resource does not exist\n        //let acl: ACL = ACL.from(s3Metadata?.['x-amz-meta-acl'] as IACL);\n\n        if (!exists) {\n            //the resource does not exist yet, we grant write access to the candidate in order to allow the resource creation\n            return new ACL().addAccess(candidate.role, candidate.id, TAccessLevel.Owner);\n        }\n        return ACL.from(s3Metadata?.['x-amz-meta-acl'] as IACL);\n    }\n\n    @SecureConnector.AccessControl\n    async getACL(acRequest: AccessRequest, resourceId: string): Promise<ACL | undefined> {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        try {\n            const s3Metadata = await this.getS3Metadata(resourceId);\n            return ACL.from(s3Metadata?.['x-amz-meta-acl'] as IACL);\n        } catch (error) {\n            console.error(`Error getting access rights in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async setACL(acRequest: AccessRequest, resourceId: string, acl: IACL) {\n        // const accessTicket = await this.getAccessTicket(resourceId, acRequest);\n        // if (accessTicket.access !== TAccessResult.Granted) throw new Error('Access Denied');\n\n        try {\n            let s3Metadata = await this.getS3Metadata(resourceId);\n            if (!s3Metadata) s3Metadata = {};\n            //when setting ACL make sure to not lose ownership\n            s3Metadata['x-amz-meta-acl'] = ACL.from(acl).addAccess(acRequest.candidate.role, acRequest.candidate.id, TAccessLevel.Owner).ACL;\n            await this.setS3Metadata(resourceId, s3Metadata);\n        } catch (error) {\n            console.error(`Error setting access rights in S3`, error);\n            throw error;\n        }\n    }\n\n    private migrateMetadata(metadata: Record<string, string>): Record<string, any> {\n        if (!metadata.agentid && !metadata.teamid && !metadata.userid) return metadata as Record<string, any>;\n        else {\n            const convertibleItems = ['agentid', 'teamid', 'userid'];\n            const aclHelper = new ACL();\n\n            for (let key of convertibleItems) {\n                if (!metadata[key]) continue;\n                const role = key === 'agentid' ? TAccessRole.Agent : key === 'teamid' ? TAccessRole.Team : TAccessRole.User;\n                aclHelper.addAccess(role, metadata[key].toString(), [TAccessLevel.Owner, TAccessLevel.Read, TAccessLevel.Write]);\n                delete metadata[key];\n            }\n            aclHelper.migrated = true;\n            const newMetadata: Record<string, any> = {\n                'x-amz-meta-acl': aclHelper.ACL,\n            };\n            //copy remaining metadata\n            for (let key in metadata) {\n                newMetadata[key] = metadata[key];\n            }\n\n            return newMetadata;\n        }\n    }\n\n    private serializeS3Metadata(s3Metadata: Record<string, any>): Record<string, string> {\n        let amzMetadata = {};\n        if (s3Metadata['x-amz-meta-acl']) {\n            //const acl: TACL = s3Metadata['x-amz-meta-acl'];\n            if (s3Metadata['x-amz-meta-acl']) {\n                amzMetadata['x-amz-meta-acl'] =\n                    typeof s3Metadata['x-amz-meta-acl'] == 'string'\n                        ? s3Metadata['x-amz-meta-acl']\n                        : ACL.from(s3Metadata['x-amz-meta-acl']).serializedACL;\n            }\n\n            delete s3Metadata['x-amz-meta-acl'];\n        }\n\n        for (let key in s3Metadata) {\n            if (key == 'ContentType') continue; //skip ContentType as it can only be set when writing the object\n            amzMetadata[key] = typeof s3Metadata[key] === 'string' ? s3Metadata[key] : JSON.stringify(s3Metadata[key]);\n        }\n\n        return amzMetadata;\n    }\n\n    private deserializeS3Metadata(amzMetadata: Record<string, string>): Record<string, any> {\n        let metadata: Record<string, any> = {};\n\n        for (let key in amzMetadata) {\n            if (key === 'x-amz-meta-acl') {\n                metadata[key] = ACL.from(amzMetadata[key]).ACL;\n                continue;\n            }\n\n            try {\n                metadata[key] = JSON.parse(amzMetadata[key]);\n            } catch (error) {\n                metadata[key] = amzMetadata[key];\n            }\n        }\n        //TODO : Remove this migration code after all metadata is migrated\n        //       Context : an old ACL metadata format was used in initial implementation of Smyth Storage\n        //       We need to ensure compatibility with legacy format and seamlessly convert it when reading\n        metadata = this.migrateMetadata(metadata) as Record<string, any>;\n\n        return metadata;\n    }\n\n    private async getS3Metadata(resourceId: string): Promise<Record<string, any> | undefined> {\n        try {\n            const command = new HeadObjectCommand({\n                Bucket: this.bucket,\n                Key: resourceId,\n            });\n            const response = await this.client.send(command);\n            const s3RawMetadata = response.Metadata;\n            if (!s3RawMetadata || Object.keys(s3RawMetadata).length === 0) return {};\n\n            let metadata: Record<string, any> = this.deserializeS3Metadata(s3RawMetadata);\n\n            if (!metadata['ContentType']) metadata['ContentType'] = response.ContentType ? response.ContentType : 'application/octet-stream';\n            return metadata;\n        } catch (error) {\n            if (error.name === 'NotFound' || error.name === 'NoSuchKey') {\n                return undefined;\n            }\n            console.error(`Error reading object metadata from S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    private async setS3Metadata(resourceId: string, metadata: Record<string, any>): Promise<void> {\n        try {\n            // Get the current object content\n            const getObjectCommand = new GetObjectCommand({\n                Bucket: this.bucket,\n                Key: resourceId,\n            });\n            const objectData = await this.client.send(getObjectCommand);\n\n            // Read the object's content\n            const bufferBody = await streamToBuffer(objectData.Body as Readable);\n\n            const amzMetadata = this.serializeS3Metadata(metadata);\n            // Put the object back with the new metadata and the same content\n            const putObjectCommand = new PutObjectCommand({\n                Bucket: this.bucket,\n                Key: resourceId,\n                Body: bufferBody,\n                Metadata: amzMetadata,\n            });\n\n            await this.client.send(putObjectCommand);\n        } catch (error) {\n            console.error(`Error setting object metadata in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n}\n","//==[ SRE: Storage ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { S3Storage } from './connectors/S3Storage.class';\n\nexport class StorageService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.Storage, 'S3', S3Storage);\n    }\n}\n","import Agent from '@sre/AgentManager/Agent.class';\nimport { Connector } from '@sre/Core/Connector.class';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { JSONContent } from '@sre/helpers/JsonContent.helper';\nimport { TLLMParams, TLLMMessageBlock, TLLMToolResultMessageBlock, ToolData, TLLMProvider } from '@sre/types/LLM.types';\nimport EventEmitter from 'events';\nimport { Readable } from 'stream';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport { LLMRegistry } from '@sre/LLMManager/LLMRegistry.class';\nimport { CustomLLMRegistry } from '@sre/LLMManager/CustomLLMRegistry.class';\n\nconst console = Logger('LLMConnector');\n\nexport interface ILLMConnectorRequest {\n    chatRequest(params: any): Promise<any>;\n    visionRequest(prompt, params: any): Promise<any>;\n    multimodalRequest(prompt, params: any): Promise<any>;\n    toolRequest(params: any): Promise<any>;\n    streamToolRequest(params: any): Promise<any>;\n    streamRequest(params: any): Promise<EventEmitter>;\n    imageGenRequest(prompt, params: any): Promise<any>;\n}\n\nexport type LLMChatResponse = {\n    content: string;\n    finishReason: string;\n};\n\nexport type ImagesResponse = {\n    created: number;\n    data: Array<{\n        b64_json?: string;\n        url?: string;\n    }>;\n};\n\nexport class LLMStream extends Readable {\n    private dataQueue: any[];\n    private toolsData: any[];\n    private hasData: boolean;\n    isReading: boolean;\n    constructor(options?) {\n        super(options);\n        this.dataQueue = [];\n        this.toolsData = [];\n        this.isReading = true;\n    }\n\n    _read(size) {\n        if (this.dataQueue.length > 0) {\n            while (this.dataQueue.length > 0) {\n                const chunk = this.dataQueue.shift();\n                if (!this.push(chunk)) {\n                    break;\n                }\n            }\n        } else {\n            this.push(null); // No more data\n        }\n    }\n\n    enqueueData(data) {\n        this.dataQueue.push(data);\n        this.read(0); // Trigger the _read method\n    }\n\n    endStream() {\n        this.isReading = false;\n        this.push(null); // End the stream\n    }\n}\n\nexport abstract class LLMConnector extends Connector {\n    public abstract name: string;\n    //public abstract user(candidate: AccessCandidate): ILLMConnectorRequest;\n    protected abstract chatRequest(acRequest: AccessRequest, params: any): Promise<LLMChatResponse>;\n    protected abstract visionRequest(acRequest: AccessRequest, prompt, params: any, agent: string | Agent): Promise<LLMChatResponse>;\n    protected abstract multimodalRequest(acRequest: AccessRequest, prompt, params: any, agent: string | Agent): Promise<LLMChatResponse>;\n    protected abstract toolRequest(acRequest: AccessRequest, params: any): Promise<any>;\n    protected abstract streamToolRequest(acRequest: AccessRequest, params: any): Promise<any>;\n    protected abstract streamRequest(acRequest: AccessRequest, params: any): Promise<EventEmitter>;\n    protected abstract imageGenRequest(acRequest: AccessRequest, prompt, params: any): Promise<ImagesResponse>;\n\n    public user(candidate: AccessCandidate): ILLMConnectorRequest {\n        if (candidate.role !== 'agent') throw new Error('Only agents can use LLM connector');\n\n        return {\n            chatRequest: async (params: any) => {\n                const _params: TLLMParams = await this.prepareParams(candidate, params);\n\n                return this.chatRequest(candidate.readRequest, _params);\n            },\n            visionRequest: async (prompt, params: any) => {\n                const _params: TLLMParams = await this.prepareParams(candidate, params);\n\n                return this.visionRequest(candidate.readRequest, prompt, _params, candidate.id);\n            },\n            multimodalRequest: async (prompt, params: any) => {\n                const _params: TLLMParams = await this.prepareParams(candidate, params);\n\n                return this.multimodalRequest(candidate.readRequest, prompt, _params, candidate.id);\n            },\n            imageGenRequest: async (prompt, params: any) => {\n                const _params: TLLMParams = await this.prepareParams(candidate, params);\n\n                return this.imageGenRequest(candidate.readRequest, prompt, _params);\n            },\n            toolRequest: async (params: any) => {\n                const _params: TLLMParams = await this.prepareParams(candidate, params);\n\n                return this.toolRequest(candidate.readRequest, _params);\n            },\n            streamToolRequest: async (params: any) => {\n                const _params: TLLMParams = await this.prepareParams(candidate, params);\n\n                return this.streamToolRequest(candidate.readRequest, _params);\n            },\n            streamRequest: async (params: any) => {\n                const _params: TLLMParams = await this.prepareParams(candidate, params);\n\n                return this.streamRequest(candidate.readRequest, _params);\n            },\n        };\n    }\n\n    public enhancePrompt(prompt: string, config: any) {\n        if (!prompt) return prompt;\n        let newPrompt = prompt;\n        const outputs = {};\n\n        if (config?.outputs) {\n            for (let con of config.outputs) {\n                if (con.default) continue;\n                outputs[con.name] = con?.description ? `<${con?.description}>` : '';\n            }\n        }\n\n        const excludedKeys = ['_debug', '_error'];\n        const outputKeys = Object.keys(outputs).filter((key) => !excludedKeys.includes(key));\n\n        if (outputKeys.length > 0) {\n            const outputFormat = {};\n            outputKeys.forEach((key) => (outputFormat[key] = config.name === 'Classifier' ? '<Boolean|String>' : '<value>'));\n\n            newPrompt +=\n                '\\n##\\nExpected output format = ' +\n                JSON.stringify(outputFormat) +\n                '\\nThe output JSON should only use the entries from the output format.';\n\n            //console.debug(` Enhanced prompt \\n`, prompt, '\\n');\n        }\n\n        return newPrompt;\n    }\n\n    public postProcess(response: string) {\n        try {\n            return JSONContent(response).tryParse();\n        } catch (error) {\n            return {\n                error: 'Invalid JSON response',\n                data: response,\n                details: 'The response from the model is not a valid JSON object. Please check the model output and try again.',\n            };\n        }\n    }\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        throw new Error('This model does not support tools');\n    }\n\n    public transformToolMessageBlocks({\n        messageBlock,\n        toolsData,\n    }: {\n        messageBlock: TLLMMessageBlock;\n        toolsData: ToolData[];\n    }): TLLMToolResultMessageBlock[] {\n        throw new Error('This model does not support tools');\n    }\n\n    public getConsistentMessages(messages: TLLMMessageBlock[]) {\n        return messages; // if a LLM connector does not implement this method, the messages will not be modified\n    }\n\n    // TODO [Forhad]: simplify this method\n    private async prepareParams(candidate: AccessCandidate, params: any) {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n        _params.fileSources = params?.fileSources; // Assign fileSource from the original parameters to avoid overwriting the original constructor\n\n        const model = _params.model;\n        const accountConnector: AccountConnector = ConnectorService.getAccountConnector();\n        const vaultConnector = ConnectorService.getVaultConnector();\n\n        if (!accountConnector) throw new Error('Account Connector unavailable, cannot proceed');\n        if (!vaultConnector) throw new Error('Vault Connector unavailable, cannot proceed');\n\n        const isStandardLLM = LLMRegistry.isStandardLLM(model);\n\n        if (isStandardLLM) {\n            const llmProvider = LLMRegistry.getProvider(model);\n\n            _params.credentials = {\n                apiKey: await vaultConnector\n                    .user(candidate)\n                    .get(llmProvider)\n                    .catch(() => ''),\n            };\n\n            if (_params.maxTokens) {\n                _params.maxTokens = LLMRegistry.adjustMaxCompletionTokens(_params.model, _params.maxTokens, !!_params?.credentials?.apiKey);\n            }\n\n            const baseUrl = LLMRegistry.getBaseURL(params.model);\n\n            if (baseUrl) {\n                _params.baseURL = baseUrl;\n            }\n\n            _params.model = LLMRegistry.getModelId(model) || model;\n        } else {\n            const teamId = await accountConnector.getCandidateTeam(candidate);\n            const customLLMRegistry = await CustomLLMRegistry.getInstance(teamId);\n\n            const modelInfo = customLLMRegistry.getModelInfo(model);\n\n            _params.modelInfo = modelInfo;\n\n            const llmProvider = customLLMRegistry.getProvider(model);\n\n            if (llmProvider === TLLMProvider.Bedrock) {\n                const keyIdName = modelInfo.settings?.keyIDName;\n                const secretKeyName = modelInfo.settings?.secretKeyName;\n                const sessionKeyName = modelInfo.settings?.sessionKeyName;\n\n                const [accessKeyId, secretAccessKey, sessionToken] = await Promise.all([\n                    vaultConnector\n                        .user(candidate)\n                        .get(keyIdName)\n                        .catch(() => ''),\n                    vaultConnector\n                        .user(candidate)\n                        .get(secretKeyName)\n                        .catch(() => ''),\n                    vaultConnector\n                        .user(candidate)\n                        .get(sessionKeyName)\n                        .catch(() => ''),\n                ]);\n\n                _params.credentials = {\n                    accessKeyId,\n                    secretAccessKey,\n                };\n\n                if (sessionToken) {\n                    _params.credentials.sessionToken = sessionToken;\n                }\n            } else if (llmProvider === TLLMProvider.VertexAI) {\n                const jsonCredentialsName = modelInfo.settings?.jsonCredentialsName;\n\n                let jsonCredentials = await vaultConnector\n                    .user(candidate)\n                    .get(jsonCredentialsName)\n                    .catch(() => '');\n\n                _params.credentials = JSON.parse(jsonCredentials);\n            }\n\n            if (_params.maxTokens) {\n                _params.maxTokens = customLLMRegistry.adjustMaxCompletionTokens(model, _params.maxTokens);\n            }\n\n            _params.model = customLLMRegistry.getModelId(model) || model;\n        }\n\n        return _params;\n    }\n}\n","import { JSONContent } from '@sre/helpers/JsonContent.helper';\nimport { ImagesResponse, LLMChatResponse, LLMConnector } from '../LLMConnector';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport EventEmitter from 'events';\nimport { Readable } from 'stream';\n\nexport class EchoConnector extends LLMConnector {\n    public name = 'LLM:Echo';\n    protected async chatRequest(acRequest: AccessRequest, params): Promise<LLMChatResponse> {\n        const content = params?.messages?.[0]?.content; // As Echo model only used in PromptGenerator so we can assume the first message is the user message to echo\n        return { content, finishReason: 'stop' } as LLMChatResponse;\n    }\n    protected async visionRequest(acRequest: AccessRequest, prompt, params) {\n        return { content: prompt, finishReason: 'stop' } as LLMChatResponse;\n    }\n    protected async multimodalRequest(acRequest: AccessRequest, prompt, params) {\n        return { content: prompt, finishReason: 'stop' } as LLMChatResponse;\n    }\n    protected async toolRequest(acRequest: AccessRequest, params) {\n        throw new Error('Echo model does not support tool requests');\n    }\n    protected async imageGenRequest(acRequest: AccessRequest, prompt, params: any): Promise<ImagesResponse> {\n        throw new Error('Image generation request is not supported for Echo.');\n    }\n    protected async streamToolRequest(acRequest: AccessRequest, params) {\n        throw new Error('Echo model does not support tool requests');\n    }\n    protected async streamRequest(acRequest: AccessRequest, params: any): Promise<Readable> {\n        throw new Error('Echo model does not support streaming');\n    }\n\n    public enhancePrompt(prompt: string, config: any) {\n        //Echo model does not require enhancements, because we are just echoing the prompt as is.\n        return prompt;\n    }\n\n    public postProcess(response: any) {\n        try {\n            return JSONContent(response).tryFullParse();\n        } catch (error) {\n            return response;\n        }\n    }\n}\n","import { type TLLMMessageBlock, TLLMMessageRole } from '@sre/types/LLM.types';\n\nimport axios from 'axios';\nimport imageSize from 'image-size';\nimport { encode } from 'gpt-tokenizer';\nimport { isBase64FileUrl, isUrl } from '@sre/utils';\n\nexport class LLMHelper {\n    /**\n     * Checks if the given array of messages contains a system message.\n     *\n     * @param {any} messages - The array of messages to check.\n     * @returns {boolean} True if a system message is found, false otherwise.\n     *\n     * @example\n     * const messages = [\n     *   { role: 'user', content: 'Hello' },\n     *   { role: 'system', content: 'You are a helpful assistant' }\n     * ];\n     * const hasSystem = LLMHelper.hasSystemMessage(messages);\n     * console.log(hasSystem); // true\n     */\n    public static hasSystemMessage(messages: any): boolean {\n        if (!Array.isArray(messages)) return false;\n        return messages?.some((message) => message.role === 'system');\n    }\n\n    /**\n     * Separates system messages from other messages in an array of LLM message blocks.\n     *\n     * @param {TLLMMessageBlock[]} messages - The array of message blocks to process.\n     * @returns {Object} An object containing the system message (if any) and an array of other messages.\n     * @property {TLLMMessageBlock | {}} systemMessage - The first system message found, or an empty object if none.\n     * @property {TLLMMessageBlock[]} otherMessages - An array of all non-system messages.\n     *\n     * @example\n     * const messages = [\n     *   { role: 'system', content: 'You are a helpful assistant' },\n     *   { role: 'user', content: 'Hello' },\n     *   { role: 'assistant', content: 'Hi there!' }\n     * ];\n     * const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n     * console.log(systemMessage); // { role: 'system', content: 'You are a helpful assistant' }\n     * console.log(otherMessages); // [{ role: 'user', content: 'Hello' }, { role: 'assistant', content: 'Hi there!' }]\n     */\n    public static separateSystemMessages(messages: TLLMMessageBlock[]): {\n        systemMessage: TLLMMessageBlock | {};\n        otherMessages: TLLMMessageBlock[];\n    } {\n        const systemMessage = messages.find((message) => message.role === 'system') || {};\n        const otherMessages = messages.filter((message) => message.role !== 'system');\n\n        return { systemMessage, otherMessages };\n    }\n\n    /**\n     * Counts the total number of tokens in a vision prompt, including both text and image tokens.\n     *\n     * @param {any} prompt - The vision prompt object containing text and image items.\n     * @returns {Promise<number>} A promise that resolves to the total number of tokens in the prompt.\n     *\n     * @description\n     * This method processes a vision prompt by:\n     * 1. Counting tokens in the text portion of the prompt.\n     * 2. Calculating tokens for each image in the prompt based on its dimensions.\n     * 3. Summing up text and image tokens to get the total token count.\n     *\n     * @example\n     * const prompt = [\n     *   { type: 'text', text: 'Describe this image:' },\n     *   { type: 'image_url', image_url: { url: 'https://example.com/image.jpg' } }\n     * ];\n     * const tokenCount = await countVisionPromptTokens(prompt);\n     * console.log(tokenCount); // e.g., 150\n     */\n    public static async countVisionPromptTokens(prompt: any): Promise<number> {\n        let tokens = 0;\n\n        const textObj = prompt?.filter((item) => item.type === 'text');\n        const textTokens = encode(textObj?.[0]?.text).length;\n\n        const images = prompt?.filter((item) => item.type === 'image_url');\n        let imageTokens = 0;\n\n        for (const image of images) {\n            const imageUrl = image?.image_url?.url;\n            const { width, height } = await this.getImageDimensions(imageUrl);\n            const tokens = this.countImageTokens(width, height);\n            imageTokens += tokens;\n        }\n\n        tokens = textTokens + imageTokens;\n        return tokens;\n    }\n\n    /**\n     * Retrieves the dimensions (width and height) of an image from a given URL or base64 encoded string.\n     *\n     * @param {string} imageUrl - The URL or base64 encoded string of the image.\n     * @returns {Promise<{ width: number; height: number }>} A promise that resolves to an object containing the width and height of the image.\n     * @throws {Error} If the provided imageUrl is invalid or if there's an error retrieving the image dimensions.\n     *\n     * @example\n     * // Using a URL\n     * const dimensions = await getImageDimensions('https://example.com/image.jpg');\n     * console.log(dimensions); // { width: 800, height: 600 }\n     *\n     * @example\n     * // Using a base64 encoded string\n     * const dimensions = await getImageDimensions('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==');\n     * console.log(dimensions); // { width: 1, height: 1 }\n     */\n    public static async getImageDimensions(imageUrl: string): Promise<{ width: number; height: number }> {\n        try {\n            let buffer: Buffer;\n\n            if (isBase64FileUrl(imageUrl)) {\n                const base64Data = imageUrl.replace(/^data:image\\/\\w+;base64,/, '');\n                buffer = Buffer.from(base64Data, 'base64');\n            } else if (isUrl(imageUrl)) {\n                const response = await axios.get(imageUrl, { responseType: 'arraybuffer' });\n                buffer = Buffer.from(response.data);\n            } else {\n                throw new Error('Please provide a valid image url!');\n            }\n\n            const dimensions = imageSize(buffer);\n\n            return {\n                width: dimensions?.width || 0,\n                height: dimensions?.height || 0,\n            };\n        } catch (error) {\n            console.error('Error getting image dimensions', error);\n            throw new Error('Please provide a valid image url!');\n        }\n    }\n\n    /**\n     * Calculates the number of tokens required to process an image based on its dimensions and detail mode.\n     *\n     * @param {number} width - The width of the image in pixels.\n     * @param {number} height - The height of the image in pixels.\n     * @param {string} detailMode - The detail mode for processing the image. Defaults to 'auto'.\n     * @returns {number} The number of tokens required to process the image.\n     *\n     * @description\n     * This method estimates the token count for image processing based on the image dimensions and detail mode.\n     * It uses a tiling approach to calculate the token count, scaling the image if necessary.\n     *\n     * - If detailMode is 'low', it returns a fixed token count of 85.\n     * - For other modes, it calculates based on the image dimensions:\n     *   - Scales down images larger than 2048 pixels in any dimension.\n     *   - Adjusts the scaled dimension to fit within a 768x1024 aspect ratio.\n     *   - Calculates the number of 512x512 tiles needed to cover the image.\n     *   - Returns the total token count based on the number of tiles.\n     *\n     * @example\n     * const tokenCount = countImageTokens(1024, 768);\n     * console.log(tokenCount); // Outputs the calculated token count\n     */\n    public static countImageTokens(width: number, height: number, detailMode: string = 'auto'): number {\n        if (detailMode === 'low') return 85;\n\n        const maxDimension = Math.max(width, height);\n        const minDimension = Math.min(width, height);\n        let scaledMinDimension = minDimension;\n\n        if (maxDimension > 2048) {\n            scaledMinDimension = (2048 / maxDimension) * minDimension;\n        }\n        scaledMinDimension = Math.floor((768 / 1024) * scaledMinDimension);\n\n        let tileSize = 512;\n        let tiles = Math.ceil(scaledMinDimension / tileSize);\n\n        if (minDimension !== scaledMinDimension) {\n            tiles *= Math.ceil((scaledMinDimension * (maxDimension / minDimension)) / tileSize);\n        }\n\n        return tiles * 170 + 85;\n    }\n\n    /**\n     * Removes duplicate user messages from the beginning and end of the messages array.\n     *\n     * This method checks if there are two consecutive user messages at the start or end of the array\n     *\n     * @param {Array<{ role: string; content: string }>} messages - The array of message objects to process.\n     *\n     * @example\n     * const messages = [\n     *   { role: 'user', content: 'Hello' },\n     *   { role: 'user', content: 'Hello' },\n     *   { role: 'assistant', content: 'Hi there!' }\n     * ];\n     * LLMHelper.removeDuplicateUserMessages(messages);\n     * console.log(messages); // [{ role: 'user', content: 'Hello' }, { role: 'assistant', content: 'Hi there!' }]\n     *\n     * @returns {TLLMMessageBlock[]} The modified array of message objects.\n     */\n    public static removeDuplicateUserMessages(messages: TLLMMessageBlock[]): TLLMMessageBlock[] {\n        const _messages = JSON.parse(JSON.stringify(messages));\n\n        // Check for two user messages at the beginning\n        if (_messages.length > 1 && _messages[0].role === TLLMMessageRole.User && _messages[1].role === TLLMMessageRole.User) {\n            _messages.shift(); // Remove the first user message\n        }\n\n        // Check for two user messages at the end\n        if (\n            _messages.length > 1 &&\n            _messages[_messages.length - 1].role === TLLMMessageRole.User &&\n            _messages[_messages.length - 2].role === TLLMMessageRole.User\n        ) {\n            _messages.pop(); // Remove the last user message\n        }\n\n        return _messages;\n    }\n}\n","import EventEmitter from 'events';\nimport OpenAI from 'openai';\nimport { encodeChat } from 'gpt-tokenizer';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { TOOL_USE_DEFAULT_MODEL } from '@sre/constants';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\nimport { LLMRegistry } from '@sre/LLMManager/LLMRegistry.class';\nimport { JSON_RESPONSE_INSTRUCTION } from '@sre/constants';\n\nimport { TLLMParams, ToolData, TLLMMessageBlock, TLLMToolResultMessageBlock, TLLMMessageRole, GenerateImageConfig } from '@sre/types/LLM.types';\n\nimport { ImagesResponse, LLMChatResponse, LLMConnector } from '../LLMConnector';\n\nconst console = Logger('OpenAIConnector');\n\nconst VALID_IMAGE_MIME_TYPES = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp', 'image/gif'];\nconst MODELS_WITH_JSON_RESPONSE = ['gpt-4o-2024-08-06', 'gpt-4o-mini-2024-07-18', 'gpt-4-turbo', 'gpt-3.5-turbo'];\n\nexport class OpenAIConnector extends LLMConnector {\n    public name = 'LLM:OpenAI';\n\n    private validImageMimeTypes = VALID_IMAGE_MIME_TYPES;\n\n    protected async chatRequest(acRequest: AccessRequest, params: TLLMParams): Promise<LLMChatResponse> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n        const messages = _params?.messages || [];\n\n        //#region Handle JSON response format\n        const responseFormat = _params?.responseFormat || '';\n        if (responseFormat === 'json') {\n            // We assume that the system message is first item in messages array\n            if (messages?.[0]?.role === TLLMMessageRole.System) {\n                messages[0].content += JSON_RESPONSE_INSTRUCTION;\n            } else {\n                messages.unshift({ role: TLLMMessageRole.System, content: JSON_RESPONSE_INSTRUCTION });\n            }\n\n            if (MODELS_WITH_JSON_RESPONSE.includes(_params.model)) {\n                _params.responseFormat = { type: 'json_object' };\n            } else {\n                _params.responseFormat = undefined; // We need to reset it, otherwise 'json' will be passed as a parameter to the OpenAI API\n            }\n        }\n        //#endregion Handle JSON response format\n\n        // Check if the team has their own API key, then use it\n        const apiKey = _params?.credentials?.apiKey;\n\n        const openai = new OpenAI({\n            //FIXME: use config.env instead of process.env\n            apiKey: apiKey || process.env.OPENAI_API_KEY, // we provide default API key for OpenAI with limited quota\n            baseURL: _params.baseURL,\n        });\n\n        const chatCompletionArgs: OpenAI.ChatCompletionCreateParams = {\n            model: _params.model,\n            messages,\n        };\n\n        if (_params?.maxTokens !== undefined) chatCompletionArgs.max_tokens = _params.maxTokens;\n        if (_params?.temperature !== undefined) chatCompletionArgs.temperature = _params.temperature;\n        if (_params?.topP !== undefined) chatCompletionArgs.top_p = _params.topP;\n        if (_params?.frequencyPenalty !== undefined) chatCompletionArgs.frequency_penalty = _params.frequencyPenalty;\n        if (_params?.presencePenalty !== undefined) chatCompletionArgs.presence_penalty = _params.presencePenalty;\n        if (_params?.stopSequences?.length) chatCompletionArgs.stop = _params.stopSequences;\n\n        if (_params.responseFormat !== undefined) {\n            chatCompletionArgs.response_format = _params.responseFormat;\n        }\n\n        try {\n            // Validate token limit\n            const promptTokens = encodeChat(messages, 'gpt-4')?.length;\n\n            await LLMRegistry.validateTokensLimit({\n                model: _params?.model,\n                promptTokens,\n                completionTokens: _params?.maxTokens,\n                hasAPIKey: !!apiKey,\n            });\n\n            const response = await openai.chat.completions.create(chatCompletionArgs);\n\n            const content = response?.choices?.[0]?.message.content;\n            const finishReason = response?.choices?.[0]?.finish_reason;\n\n            return { content, finishReason };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async visionRequest(acRequest: AccessRequest, prompt, params: TLLMParams, agent?: string | Agent) {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n        const messages = _params?.messages || [];\n\n        //#region Handle JSON response format\n        const responseFormat = _params?.responseFormat || '';\n        if (responseFormat === 'json') {\n            // We assume that the system message is first item in messages array\n            if (messages?.[0]?.role === TLLMMessageRole.System) {\n                messages[0].content += JSON_RESPONSE_INSTRUCTION;\n            } else {\n                messages.unshift({ role: TLLMMessageRole.System, content: JSON_RESPONSE_INSTRUCTION });\n            }\n\n            if (MODELS_WITH_JSON_RESPONSE.includes(_params.model)) {\n                _params.responseFormat = { type: 'json_object' };\n            }\n        }\n        //#endregion Handle JSON response format\n\n        const agentId = agent instanceof Agent ? agent.id : agent;\n\n        const fileSources: BinaryInput[] = params?.fileSources || []; // Assign fileSource from the original parameters to avoid overwriting the original constructor\n        const validSources = this.getValidImageFileSources(fileSources);\n        const imageData = await this.getImageData(validSources, agentId);\n\n        // Add user message\n        const promptData = [{ type: 'text', text: prompt || '' }, ...imageData];\n\n        messages.push({ role: 'user', content: promptData });\n\n        try {\n            // Check if the team has their own API key, then use it\n            const apiKey = _params?.credentials?.apiKey;\n\n            const openai = new OpenAI({\n                apiKey: apiKey || process.env.OPENAI_API_KEY,\n                baseURL: _params.baseURL,\n            });\n\n            const chatCompletionArgs: OpenAI.ChatCompletionCreateParams = {\n                model: _params.model,\n                messages,\n            };\n\n            if (_params?.maxTokens !== undefined) chatCompletionArgs.max_tokens = _params.maxTokens;\n            if (_params?.temperature !== undefined) chatCompletionArgs.temperature = _params.temperature;\n            if (_params?.topP !== undefined) chatCompletionArgs.top_p = _params.topP;\n            if (_params?.frequencyPenalty !== undefined) chatCompletionArgs.frequency_penalty = _params.frequencyPenalty;\n            if (_params?.presencePenalty !== undefined) chatCompletionArgs.presence_penalty = _params.presencePenalty;\n            if (_params?.responseFormat !== undefined) chatCompletionArgs.response_format = _params.responseFormat;\n            if (_params?.stopSequences?.length) chatCompletionArgs.stop = _params.stopSequences;\n\n            // Validate token limit\n            const promptTokens = await LLMHelper.countVisionPromptTokens(promptData);\n\n            await LLMRegistry.validateTokensLimit({\n                model: _params?.model,\n                promptTokens,\n                completionTokens: _params?.maxTokens,\n                hasAPIKey: !!apiKey,\n            });\n\n            const response: any = await openai.chat.completions.create(chatCompletionArgs);\n\n            const content = response?.choices?.[0]?.message.content;\n\n            return { content, finishReason: response?.choices?.[0]?.finish_reason };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async multimodalRequest(acRequest: AccessRequest, prompt, params: TLLMParams, agent?: string | Agent): Promise<LLMChatResponse> {\n        throw new Error('Multimodal request is not supported for OpenAI.');\n    }\n\n    protected async imageGenRequest(acRequest: AccessRequest, prompt, params: TLLMParams, agent?: string | Agent): Promise<ImagesResponse> {\n        // throw new Error('Image generation request is not supported for OpenAI.');\n        try {\n            const { model, size, quality, n, responseFormat, style } = params;\n            const args: GenerateImageConfig & { prompt: string } = {\n                prompt,\n                model,\n                size,\n                quality,\n                n: n || 1,\n                response_format: responseFormat || 'url',\n            };\n\n            if (style) {\n                args.style = style;\n            }\n\n            const apiKey = params?.credentials?.apiKey;\n\n            if (!apiKey) {\n                throw new Error('OpenAI API key is missing. Please provide a valid API key in the vault to proceed with Image Generation.');\n            }\n\n            const openai = new OpenAI({\n                apiKey: apiKey,\n                baseURL: params?.baseURL,\n            });\n\n            const response = await openai.images.generate(args);\n\n            return response;\n        } catch (error: any) {\n            console.warn('Error generating image(s) with DALLÂ·E: ', error);\n\n            throw error;\n        }\n    }\n\n    protected async toolRequest(acRequest: AccessRequest, params: TLLMParams): Promise<any> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n        const apiKey = _params?.credentials?.apiKey;\n\n        const openai = new OpenAI({\n            apiKey: apiKey || process.env.OPENAI_API_KEY,\n            baseURL: _params.baseURL,\n        });\n\n        const messages = _params?.messages || [];\n\n        let chatCompletionArgs: OpenAI.ChatCompletionCreateParamsNonStreaming = {\n            model: _params.model,\n            messages: messages,\n        };\n\n        if (_params?.maxTokens !== undefined) chatCompletionArgs.max_tokens = _params.maxTokens;\n\n        if (_params?.toolsConfig?.tools && _params?.toolsConfig?.tools?.length > 0) {\n            chatCompletionArgs.tools = _params?.toolsConfig?.tools as OpenAI.ChatCompletionTool[];\n        }\n\n        if (_params?.toolsConfig?.tool_choice) {\n            chatCompletionArgs.tool_choice = _params?.toolsConfig?.tool_choice as OpenAI.ChatCompletionToolChoiceOption;\n        }\n\n        try {\n            const result = await openai.chat.completions.create(chatCompletionArgs);\n            const message = result?.choices?.[0]?.message;\n            const finishReason = result?.choices?.[0]?.finish_reason;\n\n            let toolsData: ToolData[] = [];\n            let useTool = false;\n\n            if (finishReason === 'tool_calls') {\n                toolsData =\n                    message?.tool_calls?.map((tool, index) => ({\n                        index,\n                        id: tool?.id,\n                        type: tool?.type,\n                        name: tool?.function?.name,\n                        arguments: tool?.function?.arguments,\n                        role: 'tool',\n                    })) || [];\n\n                useTool = true;\n            }\n\n            return {\n                data: { useTool, message: message, content: message?.content ?? '', toolsData },\n            };\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    // ! DEPRECATED: will be removed\n    protected async streamToolRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '', baseURL = '' }\n    ): Promise<any> {\n        try {\n            // We provide\n            const openai = new OpenAI({\n                apiKey: apiKey || process.env.OPENAI_API_KEY,\n                baseURL: baseURL,\n            });\n\n            // sanity check\n            if (!Array.isArray(messages) || !messages?.length) {\n                throw new Error('Invalid messages argument for chat completion.');\n            }\n\n            console.debug('model', model);\n            console.debug('messages', messages);\n            let args: OpenAI.ChatCompletionCreateParamsStreaming = {\n                model,\n                messages,\n                stream: true,\n            };\n\n            if (tools && tools.length > 0) args.tools = tools;\n            if (tool_choice) args.tool_choice = tool_choice;\n\n            const stream: any = await openai.chat.completions.create(args);\n\n            // consumed stream will not be available for further use, so we need to clone it\n            const [toolCallsStream, contentStream] = stream.tee();\n\n            let useTool = false;\n            let delta: Record<string, any> = {};\n            let toolsData: ToolData[] = [];\n            let _stream;\n\n            let message = {\n                role: '',\n                content: '',\n                tool_calls: [],\n            };\n\n            for await (const part of toolCallsStream) {\n                delta = part.choices[0].delta;\n\n                message.role += delta?.role || '';\n                message.content += delta?.content || '';\n\n                //if it's not a tools call, stop processing the stream immediately in order to allow streaming the text content\n                //FIXME: OpenAI API returns empty content as first message for content reply, and null content for tool reply,\n                //       this doesn't seem to be a very accurate way but it's the only solution to detect tool calls early enough (without reading the whole stream)\n                if (!delta?.tool_calls && delta?.content === '') {\n                    _stream = contentStream;\n                    break;\n                }\n                //_stream = toolCallsStream;\n                if (delta?.tool_calls) {\n                    const toolCall = delta?.tool_calls?.[0];\n                    const index = toolCall?.index;\n\n                    toolsData[index] = {\n                        index,\n                        role: 'tool',\n                        id: (toolsData?.[index]?.id || '') + (toolCall?.id || ''),\n                        type: (toolsData?.[index]?.type || '') + (toolCall?.type || ''),\n                        name: (toolsData?.[index]?.name || '') + (toolCall?.function?.name || ''),\n                        arguments: (toolsData?.[index]?.arguments || '') + (toolCall?.function?.arguments || ''),\n                    };\n                }\n            }\n\n            if (toolsData?.length > 0) {\n                useTool = true;\n            }\n\n            message.tool_calls = toolsData.map((tool) => {\n                return {\n                    id: tool.id,\n                    type: tool.type,\n                    function: {\n                        name: tool.name,\n                        arguments: tool.arguments,\n                    },\n                };\n            });\n\n            //console.log('result', useTool, message, toolsData);\n\n            return {\n                data: { useTool, message, stream: _stream, toolsData },\n            };\n        } catch (error: any) {\n            console.warn('Error on toolUseLLMRequest: ', error);\n            return { error };\n        }\n    }\n\n    protected async streamRequest(acRequest: AccessRequest, params: TLLMParams): Promise<EventEmitter> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n        const emitter = new EventEmitter();\n        const usage_data = [];\n        const apiKey = _params?.credentials?.apiKey;\n\n        const openai = new OpenAI({\n            apiKey: apiKey || process.env.OPENAI_API_KEY, // we provide default API key for OpenAI with limited quota\n            baseURL: _params.baseURL,\n        });\n\n        //TODO: check token limits for non api key users\n        console.debug('model', _params.model);\n        //console.debug('messages', _params.messages);\n        let chatCompletionArgs: OpenAI.ChatCompletionCreateParamsStreaming = {\n            model: _params.model,\n            messages: _params.messages,\n\n            stream_options: { include_usage: true }, //add usage statis //TODO: @Forhad check this\n            stream: true,\n        };\n\n        if (_params?.maxTokens !== undefined) chatCompletionArgs.max_tokens = _params.maxTokens;\n\n        if (_params?.toolsConfig?.tools && _params?.toolsConfig?.tools?.length > 0) {\n            chatCompletionArgs.tools = _params?.toolsConfig?.tools as OpenAI.ChatCompletionTool[];\n        }\n        if (_params?.toolsConfig?.tool_choice) {\n            chatCompletionArgs.tool_choice = _params?.toolsConfig?.tool_choice as OpenAI.ChatCompletionToolChoiceOption;\n        }\n\n        try {\n            const stream: any = await openai.chat.completions.create(chatCompletionArgs);\n\n            // Process stream asynchronously while as we need to return emitter immediately\n            (async () => {\n                let delta: Record<string, any> = {};\n\n                let toolsData: any = [];\n\n                for await (const part of stream) {\n                    delta = part.choices[0]?.delta;\n                    const usage = part.usage;\n                    if (usage) {\n                        usage_data.push(usage);\n                    }\n                    emitter.emit('data', delta);\n\n                    if (!delta?.tool_calls && delta?.content) {\n                        emitter.emit('content', delta?.content, delta?.role);\n                    }\n                    //_stream = toolCallsStream;\n                    if (delta?.tool_calls) {\n                        const toolCall = delta?.tool_calls?.[0];\n                        const index = toolCall?.index;\n\n                        toolsData[index] = {\n                            index,\n                            role: 'tool',\n                            id: (toolsData?.[index]?.id || '') + (toolCall?.id || ''),\n                            type: (toolsData?.[index]?.type || '') + (toolCall?.type || ''),\n                            name: (toolsData?.[index]?.name || '') + (toolCall?.function?.name || ''),\n                            arguments: (toolsData?.[index]?.arguments || '') + (toolCall?.function?.arguments || ''),\n                        };\n                    }\n                }\n                if (toolsData?.length > 0) {\n                    emitter.emit('toolsData', toolsData);\n                }\n\n                setTimeout(() => {\n                    emitter.emit('end', toolsData, usage_data);\n                }, 100);\n            })();\n            return emitter;\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        let tools: OpenAI.ChatCompletionTool[] = [];\n\n        if (type === 'function') {\n            tools = toolDefinitions.map((tool) => {\n                const { name, description, properties, requiredFields } = tool;\n\n                return {\n                    type: 'function',\n                    function: {\n                        name,\n                        description,\n                        parameters: {\n                            type: 'object',\n                            properties,\n                            required: requiredFields,\n                        },\n                    },\n                };\n            });\n        }\n\n        return tools?.length > 0 ? { tools, tool_choice: toolChoice || 'auto' } : {};\n    }\n\n    public transformToolMessageBlocks({\n        messageBlock,\n        toolsData,\n    }: {\n        messageBlock: TLLMMessageBlock;\n        toolsData: ToolData[];\n    }): TLLMToolResultMessageBlock[] {\n        const messageBlocks: TLLMToolResultMessageBlock[] = [];\n\n        if (messageBlock) {\n            const transformedMessageBlock = {\n                ...messageBlock,\n                content: typeof messageBlock.content === 'object' ? JSON.stringify(messageBlock.content) : messageBlock.content,\n            };\n            if (transformedMessageBlock.tool_calls) {\n                for (let toolCall of transformedMessageBlock.tool_calls) {\n                    toolCall.function.arguments =\n                        typeof toolCall.function.arguments === 'object' ? JSON.stringify(toolCall.function.arguments) : toolCall.function.arguments;\n                }\n            }\n            messageBlocks.push(transformedMessageBlock);\n        }\n\n        const transformedToolsData = toolsData.map((toolData) => ({\n            tool_call_id: toolData.id,\n            role: TLLMMessageRole.Tool, // toolData.role as TLLMMessageRole, //should always be 'tool' for OpenAI\n            name: toolData.name,\n            content: typeof toolData.result === 'string' ? toolData.result : JSON.stringify(toolData.result), // Ensure content is a string\n        }));\n\n        return [...messageBlocks, ...transformedToolsData];\n    }\n\n    public getConsistentMessages(messages) {\n        const _messages = LLMHelper.removeDuplicateUserMessages(messages);\n\n        return _messages.map((message) => {\n            const _message = { ...message };\n            let textContent = '';\n\n            if (message?.parts) {\n                textContent = message.parts.map((textBlock) => textBlock?.text || '').join(' ');\n            } else if (Array.isArray(message?.content)) {\n                textContent = message.content.map((textBlock) => textBlock?.text || '').join(' ');\n            } else if (message?.content) {\n                textContent = message.content;\n            }\n\n            _message.content = textContent;\n\n            return _message;\n        });\n    }\n\n    private getValidImageFileSources(fileSources: BinaryInput[]) {\n        const validSources = [];\n\n        for (let fileSource of fileSources) {\n            if (this.validImageMimeTypes.includes(fileSource?.mimetype)) {\n                validSources.push(fileSource);\n            }\n        }\n\n        if (validSources?.length === 0) {\n            throw new Error(`Unsupported file(s). Please make sure your file is one of the following types: ${this.validImageMimeTypes.join(', ')}`);\n        }\n\n        return validSources;\n    }\n\n    private async getImageData(\n        fileSources: BinaryInput[],\n        agentId: string\n    ): Promise<\n        {\n            type: string;\n            image_url: { url: string };\n        }[]\n    > {\n        try {\n            const imageData = [];\n\n            for (let fileSource of fileSources) {\n                const bufferData = await fileSource.readData(AccessCandidate.agent(agentId));\n                const base64Data = bufferData.toString('base64');\n                const url = `data:${fileSource.mimetype};base64,${base64Data}`;\n\n                imageData.push({\n                    type: 'image_url',\n                    image_url: { url },\n                });\n            }\n\n            return imageData;\n        } catch (error) {\n            throw error;\n        }\n    }\n}\n","import os from 'os';\nimport path from 'path';\nimport EventEmitter from 'events';\nimport fs from 'fs';\n\nimport axios from 'axios';\nimport { GoogleGenerativeAI, ModelParams, GenerationConfig, GenerateContentRequest } from '@google/generative-ai';\nimport { GoogleAIFileManager, FileState } from '@google/generative-ai/server';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { TOOL_USE_DEFAULT_MODEL, JSON_RESPONSE_INSTRUCTION } from '@sre/constants';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { uid } from '@sre/utils';\n\nimport { processWithConcurrencyLimit, isDataUrl, isUrl, getMimeTypeFromUrl, isRawBase64, parseBase64, isValidString } from '@sre/utils';\n\nimport { TLLMParams, TLLMMessageBlock, ToolData, TLLMMessageRole, TLLMToolResultMessageBlock } from '@sre/types/LLM.types';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\nimport { LLMRegistry } from '@sre/LLMManager/LLMRegistry.class';\n\nimport { ImagesResponse, LLMChatResponse, LLMConnector } from '../LLMConnector';\n\nconst console = Logger('GoogleAIConnector');\n\ntype FileObject = {\n    url: string;\n    mimetype: string;\n};\n\nconst DEFAULT_MODEL = 'gemini-1.5-pro';\n\nconst MODELS_SUPPORT_SYSTEM_INSTRUCTION = [\n    'gemini-1.5-pro-exp-0801',\n    'gemini-1.5-pro-latest',\n    'gemini-1.5-pro-latest',\n    'gemini-1.5-pro',\n    'gemini-1.5-pro-001',\n    'gemini-1.5-flash-latest',\n    'gemini-1.5-flash-001',\n    'gemini-1.5-flash',\n];\nconst MODELS_SUPPORT_JSON_RESPONSE = MODELS_SUPPORT_SYSTEM_INSTRUCTION;\n\n// Supported file MIME types for Google AI's Gemini models\nconst VALID_MIME_TYPES = [\n    'video/mp4',\n    'video/mpeg',\n    'video/mov',\n    'video/avi',\n    'video/x-flv',\n    'video/mpg',\n    'video/webm',\n    'video/wmv',\n    'video/3gpp',\n    'image/png',\n    'image/jpeg',\n    'image/jpg',\n    'image/webp',\n    'image/heic',\n    'image/heif',\n    'audio/wav',\n    'audio/mp3',\n    'audio/aiff',\n    'audio/aac',\n    'audio/ogg',\n    'audio/flac',\n    'application/pdf',\n    'application/x-javascript',\n    'application/x-typescript',\n    'application/x-python-code',\n    'application/json',\n    'application/rtf',\n    'text/plain',\n    'text/html',\n    'text/css',\n    'text/javascript',\n    'text/x-typescript',\n    'text/csv',\n    'text/markdown',\n    'text/x-python',\n    'text/xml',\n    'text/rtf',\n];\n\n// Supported image MIME types for Google AI's Gemini models\nconst VALID_IMAGE_MIME_TYPES = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp', 'image/heic', 'image/heif'];\n\nexport class GoogleAIConnector extends LLMConnector {\n    public name = 'LLM:GoogleAI';\n\n    private validMimeTypes = {\n        all: VALID_MIME_TYPES,\n        image: VALID_IMAGE_MIME_TYPES,\n    };\n\n    protected async chatRequest(acRequest: AccessRequest, params): Promise<LLMChatResponse> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n        let prompt = '';\n\n        const model = _params?.model || DEFAULT_MODEL;\n\n        const apiKey = _params?.credentials?.apiKey;\n\n        let messages = _params?.messages || [];\n\n        //#region Separate system message and add JSON response instruction if needed\n        let systemInstruction = '';\n        const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n\n        if ('content' in systemMessage) {\n            systemInstruction = systemMessage.content as string;\n        }\n\n        messages = otherMessages;\n\n        const responseFormat = _params?.responseFormat || '';\n\n        if (responseFormat === 'json') {\n            systemInstruction += JSON_RESPONSE_INSTRUCTION;\n\n            if (MODELS_SUPPORT_JSON_RESPONSE.includes(model)) {\n                _params.responseMimeType = 'application/json';\n            }\n        }\n\n        if (messages?.length > 0) {\n            // Concatenate messages with prompt and remove messages from params as it's not supported\n            prompt += messages.map((message) => message?.parts?.[0]?.text || '').join('\\n');\n        }\n\n        // if the the model does not support system instruction, we will add it to the prompt\n        if (!MODELS_SUPPORT_SYSTEM_INSTRUCTION.includes(model)) {\n            prompt = `${prompt}\\n${systemInstruction}`;\n        }\n        //#endregion Separate system message and add JSON response instruction if needed\n\n        if (!prompt) throw new Error('Prompt is required!');\n\n        // TODO: implement claude specific token counting to validate token limit\n        // this.validateTokenLimit(_params);\n\n        const modelParams: ModelParams = {\n            model,\n        };\n\n        const generationConfig: GenerationConfig = {};\n\n        if (_params.maxTokens !== undefined) generationConfig.maxOutputTokens = _params.maxTokens;\n        if (_params.temperature !== undefined) generationConfig.temperature = _params.temperature;\n        if (_params.topP !== undefined) generationConfig.topP = _params.topP;\n        if (_params.topK !== undefined) generationConfig.topK = _params.topK;\n        if (_params.stopSequences?.length) generationConfig.stopSequences = _params.stopSequences;\n\n        if (systemInstruction) modelParams.systemInstruction = systemInstruction;\n        if (_params.responseMimeType) generationConfig.responseMimeType = _params.responseMimeType;\n\n        if (Object.keys(generationConfig).length > 0) {\n            modelParams.generationConfig = generationConfig;\n        }\n\n        try {\n            const genAI = new GoogleGenerativeAI(apiKey);\n            const $model = genAI.getGenerativeModel(modelParams);\n\n            const { totalTokens: promptTokens } = await $model.countTokens(prompt);\n\n            // * the function will throw an error if the token limit is exceeded\n            await LLMRegistry.validateTokensLimit({\n                model,\n                promptTokens,\n                completionTokens: params?.maxTokens,\n                hasAPIKey: !!apiKey,\n            });\n\n            const result = await $model.generateContent(prompt);\n            const response = await result?.response;\n            const content = response?.text();\n            const finishReason = response.candidates[0].finishReason;\n\n            return { content, finishReason };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async visionRequest(acRequest: AccessRequest, prompt, params, agent?: string | Agent) {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n        const model = _params?.model || 'gemini-pro-vision';\n        const apiKey = _params?.credentials?.apiKey;\n        const fileSources = params?.fileSources || []; // Assign fileSource from the original parameters to avoid overwriting the original constructor\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        let _prompt = prompt;\n\n        const validFiles = this.getValidFileSources(fileSources, 'image');\n\n        const fileUploadingTasks = validFiles.map((fileSource) => async () => {\n            try {\n                const uploadedFile = await this.uploadFile({ fileSource, apiKey, agentId });\n\n                return { url: uploadedFile.url, mimetype: fileSource.mimetype };\n            } catch {\n                return null;\n            }\n        });\n        try {\n            const uploadedFiles = await processWithConcurrencyLimit(fileUploadingTasks);\n\n            // We throw error when there are no valid uploaded files,\n            if (!uploadedFiles || uploadedFiles?.length === 0) {\n                throw new Error(`There is an issue during upload file in Google AI Server!`);\n            }\n\n            const imageData = this.getFileData(uploadedFiles);\n\n            //#region Separate system message and add JSON response instruction if needed\n            let systemInstruction = '';\n\n            const responseFormat = _params?.responseFormat || '';\n\n            if (responseFormat === 'json') {\n                systemInstruction += JSON_RESPONSE_INSTRUCTION;\n\n                if (MODELS_SUPPORT_JSON_RESPONSE.includes(model)) {\n                    _params.responseMimeType = 'application/json';\n                }\n            }\n\n            // if the the model does not support system instruction, we will add it to the prompt\n            if (!MODELS_SUPPORT_SYSTEM_INSTRUCTION.includes(model)) {\n                _prompt = `${_prompt}\\n${systemInstruction}`;\n            }\n            //#endregion Separate system message and add JSON response instruction if needed\n\n            // Adjust input structure handling for multiple image files to accommodate variations.\n            const promptWithFiles = imageData.length === 1 ? [...imageData, { text: _prompt }] : [_prompt, ...imageData];\n\n            const modelParams: ModelParams = {\n                model,\n            };\n\n            const generationConfig: GenerationConfig = {};\n\n            if (_params.maxTokens !== undefined) generationConfig.maxOutputTokens = _params.maxTokens;\n            if (_params.temperature !== undefined) generationConfig.temperature = _params.temperature;\n            if (_params.topP !== undefined) generationConfig.topP = _params.topP;\n            if (_params.topK !== undefined) generationConfig.topK = _params.topK;\n            if (_params.stopSequences?.length) generationConfig.stopSequences = _params.stopSequences;\n\n            if (Object.keys(generationConfig).length > 0) {\n                modelParams.generationConfig = generationConfig;\n            }\n\n            const genAI = new GoogleGenerativeAI(apiKey);\n            const $model = genAI.getGenerativeModel(modelParams);\n\n            // Check token limit\n            const { totalTokens: promptTokens } = await $model.countTokens(promptWithFiles);\n\n            // * the function will throw an error if the token limit is exceeded\n            await LLMRegistry.validateTokensLimit({\n                model,\n                promptTokens,\n                completionTokens: _params?.maxTokens,\n                hasAPIKey: !!apiKey,\n            });\n\n            const result = await $model.generateContent(promptWithFiles);\n            const response = await result?.response;\n            const content = response?.text();\n            const finishReason = response.candidates[0].finishReason;\n\n            return { content, finishReason };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async multimodalRequest(acRequest: AccessRequest, prompt, params, agent: string | Agent) {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n        const model = _params?.model || DEFAULT_MODEL;\n        const apiKey = _params?.credentials?.apiKey;\n        const fileSources = params?.fileSources || []; // Assign fileSource from the original parameters to avoid overwriting the original constructor\n        const agentId = agent instanceof Agent ? agent.id : agent;\n        let _prompt = prompt;\n\n        // If user provide mix of valid and invalid files, we will only process the valid files\n        const validFiles = this.getValidFileSources(fileSources, 'all');\n\n        const hasVideo = validFiles.some((file) => file?.mimetype?.includes('video'));\n\n        // GoogleAI only supports one video file at a time\n        if (hasVideo && validFiles.length > 1) {\n            throw new Error('Only one video file is supported at a time.');\n        }\n\n        const fileUploadingTasks = validFiles.map((fileSource) => async () => {\n            try {\n                const uploadedFile = await this.uploadFile({ fileSource, apiKey, agentId });\n\n                return { url: uploadedFile.url, mimetype: fileSource.mimetype };\n            } catch {\n                return null;\n            }\n        });\n\n        const uploadedFiles = await processWithConcurrencyLimit(fileUploadingTasks);\n\n        // We throw error when there are no valid uploaded files,\n        if (uploadedFiles && uploadedFiles?.length === 0) {\n            throw new Error(`There is an issue during upload file in Google AI Server!`);\n        }\n\n        const fileData = this.getFileData(uploadedFiles);\n\n        //#region Separate system message and add JSON response instruction if needed\n        let systemInstruction = '';\n\n        const responseFormat = _params?.responseFormat || '';\n\n        if (responseFormat === 'json') {\n            systemInstruction += JSON_RESPONSE_INSTRUCTION;\n\n            if (MODELS_SUPPORT_JSON_RESPONSE.includes(model)) {\n                _params.responseMimeType = 'application/json';\n            }\n        }\n\n        // if the the model does not support system instruction, we will add it to the prompt\n        if (!MODELS_SUPPORT_SYSTEM_INSTRUCTION.includes(model)) {\n            _prompt = `${_prompt}\\n${systemInstruction}`;\n        }\n        //#endregion Separate system message and add JSON response instruction if needed\n\n        // Adjust input structure handling for multiple image files to accommodate variations.\n        const promptWithFiles = fileData.length === 1 ? [...fileData, { text: _prompt }] : [_prompt, ...fileData];\n\n        const modelParams: ModelParams = {\n            model,\n        };\n\n        const generationConfig: GenerationConfig = {};\n\n        if (_params.maxTokens !== undefined) generationConfig.maxOutputTokens = _params.maxTokens;\n        if (_params.temperature !== undefined) generationConfig.temperature = _params.temperature;\n        if (_params.topP !== undefined) generationConfig.topP = _params.topP;\n        if (_params.topK !== undefined) generationConfig.topK = _params.topK;\n        if (_params.stopSequences?.length) generationConfig.stopSequences = _params.stopSequences;\n\n        if (Object.keys(generationConfig).length > 0) {\n            modelParams.generationConfig = generationConfig;\n        }\n\n        try {\n            const genAI = new GoogleGenerativeAI(apiKey);\n            const $model = genAI.getGenerativeModel(modelParams);\n\n            // Check token limit\n            const { totalTokens: promptTokens } = await $model.countTokens(promptWithFiles);\n\n            // * the function will throw an error if the token limit is exceeded\n            await LLMRegistry.validateTokensLimit({\n                model,\n                promptTokens,\n                completionTokens: _params?.maxTokens,\n                hasAPIKey: !!apiKey,\n            });\n\n            const result = await $model.generateContent(promptWithFiles);\n\n            const response = await result?.response;\n            const content = response?.text();\n            const finishReason = response.candidates[0].finishReason;\n\n            return { content, finishReason };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async toolRequest(acRequest: AccessRequest, params): Promise<any> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n        try {\n            let systemInstruction = '';\n            let formattedMessages;\n\n            const messages = _params?.messages || [];\n\n            const hasSystemMessage = LLMHelper.hasSystemMessage(messages);\n\n            if (hasSystemMessage) {\n                const separateMessages = LLMHelper.separateSystemMessages(messages);\n                const systemMessageContent = (separateMessages.systemMessage as TLLMMessageBlock)?.content;\n                systemInstruction = typeof systemMessageContent === 'string' ? systemMessageContent : '';\n                formattedMessages = separateMessages.otherMessages;\n            } else {\n                formattedMessages = messages;\n            }\n\n            const apiKey = _params?.credentials?.apiKey;\n\n            const generationConfig: GenerationConfig = {};\n\n            if (_params?.maxTokens) generationConfig.maxOutputTokens = _params.maxTokens;\n\n            const modelParams: ModelParams = {\n                model: _params.model,\n            };\n\n            if (Object.keys(generationConfig).length > 0) {\n                modelParams.generationConfig = generationConfig;\n            }\n\n            const genAI = new GoogleGenerativeAI(apiKey);\n            const $model = genAI.getGenerativeModel(modelParams);\n\n            const toolsPrompt: GenerateContentRequest = {\n                contents: formattedMessages,\n            };\n\n            if (systemInstruction) {\n                toolsPrompt.systemInstruction = systemInstruction;\n            }\n\n            if (_params?.toolsConfig?.tools) toolsPrompt.tools = _params?.toolsConfig?.tools;\n            if (_params?.toolsConfig?.tool_choice)\n                toolsPrompt.toolConfig = {\n                    functionCallingConfig: { mode: _params?.toolsConfig?.tool_choice || 'auto' },\n                };\n\n            const result = await $model.generateContent(toolsPrompt);\n\n            const response = await result.response;\n            const content = response.text();\n            const toolCalls = response.candidates[0]?.content?.parts?.filter((part) => part.functionCall);\n\n            let toolsData: ToolData[] = [];\n            let useTool = false;\n\n            if (toolCalls && toolCalls.length > 0) {\n                toolsData = toolCalls.map((toolCall, index) => ({\n                    index,\n                    id: `tool-${index}`,\n                    type: 'function',\n                    name: toolCall.functionCall.name,\n                    arguments: JSON.stringify(toolCall.functionCall.args),\n                    role: TLLMMessageRole.Assistant,\n                }));\n                useTool = true;\n            }\n\n            return {\n                data: { useTool, message: { content }, content, toolsData },\n            };\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    protected async imageGenRequest(acRequest: AccessRequest, prompt, params: any, agent?: string | Agent): Promise<ImagesResponse> {\n        throw new Error('Image generation request is not supported for GoogleAI.');\n    }\n\n    // ! DEPRECATED: will be removed\n    protected async streamToolRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<any> {\n        throw new Error('streamToolRequest() is Deprecated!');\n    }\n\n    protected async streamRequest(acRequest: AccessRequest, params): Promise<EventEmitter> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n        const emitter = new EventEmitter();\n        const apiKey = _params?.credentials?.apiKey;\n\n        let systemInstruction = '';\n        let formattedMessages;\n        const messages = _params?.messages || [];\n\n        const hasSystemMessage = LLMHelper.hasSystemMessage(messages);\n        if (hasSystemMessage) {\n            const separateMessages = LLMHelper.separateSystemMessages(messages);\n            const systemMessageContent = (separateMessages.systemMessage as TLLMMessageBlock)?.content;\n            systemInstruction = typeof systemMessageContent === 'string' ? systemMessageContent : '';\n            formattedMessages = separateMessages.otherMessages;\n        } else {\n            formattedMessages = messages;\n        }\n\n        const generationConfig: GenerationConfig = {};\n\n        if (_params?.maxTokens) generationConfig.maxOutputTokens = _params.maxTokens;\n\n        const modelParams: ModelParams = {\n            model: _params.model,\n        };\n\n        if (Object.keys(generationConfig).length > 0) {\n            modelParams.generationConfig = generationConfig;\n        }\n\n        const genAI = new GoogleGenerativeAI(apiKey);\n        const $model = genAI.getGenerativeModel(modelParams);\n\n        const toolsPrompt: GenerateContentRequest = {\n            contents: formattedMessages,\n        };\n\n        if (systemInstruction) {\n            toolsPrompt.systemInstruction = systemInstruction;\n        }\n\n        if (_params?.toolsConfig?.tools) toolsPrompt.tools = _params?.toolsConfig?.tools;\n        if (_params?.toolsConfig?.tool_choice)\n            toolsPrompt.toolConfig = {\n                functionCallingConfig: { mode: _params?.toolsConfig?.tool_choice || 'auto' },\n            };\n\n        try {\n            const result = await $model.generateContentStream(toolsPrompt);\n\n            let toolsData: ToolData[] = [];\n\n            // Process stream asynchronously while as we need to return emitter immediately\n            (async () => {\n                for await (const chunk of result.stream) {\n                    const chunkText = chunk.text();\n                    emitter.emit('content', chunkText);\n\n                    if (chunk.candidates[0]?.content?.parts) {\n                        const toolCalls = chunk.candidates[0].content.parts.filter((part) => part.functionCall);\n                        if (toolCalls.length > 0) {\n                            toolsData = toolCalls.map((toolCall, index) => ({\n                                index,\n                                id: `tool-${index}`,\n                                type: 'function',\n                                name: toolCall.functionCall.name,\n                                arguments: JSON.stringify(toolCall.functionCall.args),\n                                role: TLLMMessageRole.Assistant,\n                            }));\n                            emitter.emit('toolsData', toolsData);\n                        }\n                    }\n                }\n\n                setTimeout(() => {\n                    emitter.emit('end', toolsData);\n                }, 100);\n            })();\n\n            return emitter;\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public formatToolsConfig({ toolDefinitions, toolChoice = 'auto' }) {\n        const tools = toolDefinitions.map((tool) => {\n            const { name, description, properties, requiredFields } = tool;\n\n            // Ensure the function name is valid\n            const validName = this.sanitizeFunctionName(name);\n\n            // Ensure properties are non-empty for OBJECT type\n            const validProperties = properties && Object.keys(properties).length > 0 ? properties : { dummy: { type: 'string' } };\n\n            return {\n                functionDeclarations: [\n                    {\n                        name: validName,\n                        description: description || '',\n                        parameters: {\n                            type: 'OBJECT',\n                            properties: validProperties,\n                            required: requiredFields || [],\n                        },\n                    },\n                ],\n            };\n        });\n\n        return {\n            tools,\n            toolChoice: {\n                type: toolChoice,\n            },\n        };\n    }\n\n    public transformToolMessageBlocks({\n        messageBlock,\n        toolsData,\n    }: {\n        messageBlock: TLLMMessageBlock;\n        toolsData: ToolData[];\n    }): TLLMToolResultMessageBlock[] {\n        const messageBlocks: TLLMToolResultMessageBlock[] = [];\n\n        if (messageBlock) {\n            const content = [];\n            if (typeof messageBlock.content === 'string') {\n                content.push({ text: messageBlock.content });\n            } else if (Array.isArray(messageBlock.content)) {\n                content.push(...messageBlock.content);\n            }\n\n            if (messageBlock.parts) {\n                const functionCalls = messageBlock.parts.filter((part) => part.functionCall);\n                if (functionCalls.length > 0) {\n                    content.push(\n                        ...functionCalls.map((call) => ({\n                            functionCall: {\n                                name: call.functionCall.name,\n                                args: JSON.parse(call.functionCall.args),\n                            },\n                        }))\n                    );\n                }\n            }\n\n            messageBlocks.push({\n                role: messageBlock.role,\n                parts: content,\n            });\n        }\n\n        const transformedToolsData = toolsData.map(\n            (toolData): TLLMToolResultMessageBlock => ({\n                role: TLLMMessageRole.Function,\n                parts: [\n                    {\n                        functionResponse: {\n                            name: toolData.name,\n                            response: {\n                                name: toolData.name,\n                                content: typeof toolData.result === 'string' ? toolData.result : JSON.stringify(toolData.result),\n                            },\n                        },\n                    },\n                ],\n            })\n        );\n\n        return [...messageBlocks, ...transformedToolsData];\n    }\n\n    // Add this helper method to sanitize function names\n    private sanitizeFunctionName(name: string): string {\n        // Check if name is undefined or null\n        if (name == null) {\n            return '_unnamed_function';\n        }\n\n        // Remove any characters that are not alphanumeric, underscore, dot, or dash\n        let sanitized = name.replace(/[^a-zA-Z0-9_.-]/g, '');\n\n        // Ensure the name starts with a letter or underscore\n        if (!/^[a-zA-Z_]/.test(sanitized)) {\n            sanitized = '_' + sanitized;\n        }\n\n        // If sanitized is empty after removing invalid characters, use a default name\n        if (sanitized === '') {\n            sanitized = '_unnamed_function';\n        }\n\n        // Truncate to 64 characters if longer\n        sanitized = sanitized.slice(0, 64);\n\n        return sanitized;\n    }\n\n    private async uploadFile({\n        fileSource,\n        apiKey,\n        agentId,\n    }: {\n        fileSource: BinaryInput;\n        apiKey: string;\n        agentId: string;\n    }): Promise<{ url: string }> {\n        try {\n            if (!apiKey || !fileSource?.mimetype) {\n                throw new Error('Missing required parameters to save file for Google AI!');\n            }\n\n            // Create a temporary directory\n            const tempDir = os.tmpdir();\n            const fileName = uid();\n            const tempFilePath = path.join(tempDir, fileName);\n\n            const bufferData = await fileSource.readData(AccessCandidate.agent(agentId));\n\n            // Write buffer data to temp file\n            await fs.promises.writeFile(tempFilePath, bufferData);\n\n            // Upload the file to the Google File Manager\n            const fileManager = new GoogleAIFileManager(apiKey);\n\n            const uploadResponse = await fileManager.uploadFile(tempFilePath, {\n                mimeType: fileSource.mimetype,\n                displayName: fileName,\n            });\n\n            const name = uploadResponse.file.name;\n\n            // Poll getFile() on a set interval (10 seconds here) to check file state.\n            let uploadedFile = await fileManager.getFile(name);\n            while (uploadedFile.state === FileState.PROCESSING) {\n                process.stdout.write('.');\n                // Sleep for 10 seconds\n                await new Promise((resolve) => setTimeout(resolve, 10_000));\n                // Fetch the file from the API again\n                uploadedFile = await fileManager.getFile(name);\n            }\n\n            if (uploadedFile.state === FileState.FAILED) {\n                throw new Error('File processing failed.');\n            }\n\n            // Clean up temp file\n            await fs.promises.unlink(tempFilePath);\n\n            return {\n                url: uploadResponse.file.uri || '',\n            };\n        } catch (error) {\n            throw new Error(`Error uploading file for Google AI: ${error.message}`);\n        }\n    }\n\n    public getConsistentMessages(messages: TLLMMessageBlock[]): TLLMMessageBlock[] {\n        const _messages = LLMHelper.removeDuplicateUserMessages(messages);\n\n        return _messages.map((message) => {\n            const _message = { ...message };\n            let textContent = '';\n\n            // Map roles to valid Google AI roles\n            switch (_message.role) {\n                case TLLMMessageRole.Assistant:\n                case TLLMMessageRole.System:\n                    _message.role = TLLMMessageRole.Model;\n                    break;\n                case TLLMMessageRole.User:\n                    // User role is already valid\n                    break;\n                default:\n                    _message.role = TLLMMessageRole.User; // Default to user for unknown roles\n            }\n\n            if (_message?.parts) {\n                textContent = _message.parts.map((textBlock) => textBlock?.text || '').join(' ');\n            } else if (Array.isArray(_message?.content)) {\n                textContent = _message.content.map((textBlock) => textBlock?.text || '').join(' ');\n            } else if (_message?.content) {\n                textContent = _message.content as string;\n            }\n\n            _message.parts = [{ text: textContent }];\n\n            delete _message.content; // Remove content to avoid error\n\n            return _message;\n        });\n    }\n\n    private getValidFileSources(fileSources: BinaryInput[], type: 'image' | 'all') {\n        const validSources = [];\n\n        for (let fileSource of fileSources) {\n            if (this.validMimeTypes[type].includes(fileSource?.mimetype)) {\n                validSources.push(fileSource);\n            }\n        }\n\n        if (validSources?.length === 0) {\n            throw new Error(`Unsupported file(s). Please make sure your file is one of the following types: ${this.validMimeTypes[type].join(', ')}`);\n        }\n\n        return validSources;\n    }\n\n    private getFileData(\n        fileSources: {\n            url: string;\n            mimetype: string;\n        }[]\n    ): {\n        fileData: {\n            mimeType: string;\n            fileUri: string;\n        };\n    }[] {\n        try {\n            const imageData = [];\n\n            for (let fileSource of fileSources) {\n                imageData.push({\n                    fileData: {\n                        mimeType: fileSource.mimetype,\n                        fileUri: fileSource.url,\n                    },\n                });\n            }\n\n            return imageData;\n        } catch (error) {\n            throw error;\n        }\n    }\n}\n","import EventEmitter from 'events';\nimport Anthropic from '@anthropic-ai/sdk';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { JSON_RESPONSE_INSTRUCTION } from '@sre/constants';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { BinaryInput } from '@sre/helpers/BinaryInput.helper';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { TLLMParams, ToolData, TLLMMessageBlock, TLLMToolResultMessageBlock, TLLMMessageRole } from '@sre/types/LLM.types';\nimport { LLMRegistry } from '@sre/LLMManager/LLMRegistry.class';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\n\nimport { ImagesResponse, LLMChatResponse, LLMConnector } from '../LLMConnector';\nimport { TextBlockParam } from '@anthropic-ai/sdk/resources';\n\nconst console = Logger('AnthropicAIConnector');\n\nconst VALID_IMAGE_MIME_TYPES = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp', 'image/gif'];\nconst PREFILL_TEXT_FOR_JSON_RESPONSE = '{';\nconst TOOL_USE_DEFAULT_MODEL = 'claude-3-5-haiku-latest';\nconst API_KEY_ERROR_MESSAGE = 'Please provide an API key for AnthropicAI';\n\nexport class AnthropicAIConnector extends LLMConnector {\n    public name = 'LLM:AnthropicAI';\n\n    private validImageMimeTypes = VALID_IMAGE_MIME_TYPES;\n\n    protected async chatRequest(acRequest: AccessRequest, params: TLLMParams): Promise<LLMChatResponse> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params object\n\n        let messages = _params?.messages || [];\n\n        //#region Separate system message and add JSON response instruction if needed\n        let systemPrompt = '';\n        const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n        if ('content' in systemMessage) {\n            systemPrompt = systemMessage?.content as string;\n        }\n        messages = otherMessages;\n\n        const responseFormat = _params?.responseFormat || '';\n        if (responseFormat === 'json') {\n            systemPrompt += JSON_RESPONSE_INSTRUCTION;\n\n            messages.push({ role: TLLMMessageRole.Assistant, content: PREFILL_TEXT_FOR_JSON_RESPONSE });\n        }\n        //#endregion Separate system message and add JSON response instruction if needed\n\n        const apiKey = _params?.credentials?.apiKey;\n\n        // We do not provide default API key for claude, so user/team must provide their own API key\n        if (!apiKey) throw new Error(API_KEY_ERROR_MESSAGE);\n\n        const anthropic = new Anthropic({ apiKey });\n\n        // TODO: implement claude specific token counting to validate token limit\n        // this.validateTokenLimit(_params);\n\n        const messageCreateArgs: Anthropic.MessageCreateParamsNonStreaming = {\n            model: _params.model,\n            messages: messages as Anthropic.MessageParam[],\n            max_tokens: _params?.maxTokens || LLMRegistry.getMaxCompletionTokens(_params?.model, !!apiKey), // * max token is required\n        };\n\n        if (systemPrompt) messageCreateArgs.system = systemPrompt;\n\n        if (_params?.temperature !== undefined) messageCreateArgs.temperature = _params.temperature;\n        if (_params?.topP !== undefined) messageCreateArgs.top_p = _params.topP;\n        if (_params?.topK !== undefined) messageCreateArgs.top_k = _params.topK;\n        if (_params?.stopSequences?.length) messageCreateArgs.stop_sequences = _params.stopSequences;\n\n        try {\n            const response = await anthropic.messages.create(messageCreateArgs);\n            let content = (response.content?.[0] as Anthropic.TextBlock)?.text;\n            const finishReason = response?.stop_reason;\n\n            if (responseFormat === 'json') {\n                content = `${PREFILL_TEXT_FOR_JSON_RESPONSE}${content}`;\n            }\n\n            return { content, finishReason };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    // TODO [Forhad]: check if we can get the agent ID from the acRequest.candidate\n    protected async visionRequest(acRequest: AccessRequest, prompt, params: TLLMParams, agent?: string | Agent) {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params object\n\n        let messages = _params?.messages || [];\n\n        const agentId = agent instanceof Agent ? agent.id : agent;\n\n        const fileSources: BinaryInput[] = params?.fileSources || []; // Assign fileSource from the original parameters to avoid overwriting the original constructor\n        const validSources = this.getValidImageFileSources(fileSources);\n        const imageData = await this.getImageData(validSources, agentId);\n\n        const content = [{ type: 'text', text: prompt }, ...imageData];\n        messages.push({ role: TLLMMessageRole.User, content });\n\n        //#region Separate system message and add JSON response instruction if needed\n        let systemPrompt;\n        const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n        if ('content' in systemMessage) {\n            systemPrompt = (systemMessage as TLLMMessageBlock)?.content;\n        }\n        messages = otherMessages;\n\n        const responseFormat = _params?.responseFormat || '';\n        if (responseFormat === 'json') {\n            systemPrompt += JSON_RESPONSE_INSTRUCTION;\n            messages.push({ role: TLLMMessageRole.Assistant, content: PREFILL_TEXT_FOR_JSON_RESPONSE });\n        }\n        //#endregion Separate system message and add JSON response instruction if needed\n\n        const apiKey = _params?.credentials?.apiKey;\n\n        // We do not provide default API key for claude, so user/team must provide their own API key\n        if (!apiKey) throw new Error(API_KEY_ERROR_MESSAGE);\n\n        const anthropic = new Anthropic({ apiKey });\n\n        // TODO (Forhad): implement claude specific token counting properly\n        // this.validateTokenLimit(params);\n\n        const messageCreateArgs: Anthropic.MessageCreateParamsNonStreaming = {\n            model: _params.model,\n            messages,\n            max_tokens: _params?.maxTokens || LLMRegistry.getMaxCompletionTokens(_params?.model, !!apiKey), // * max token is required\n        };\n\n        if (_params?.temperature !== undefined) messageCreateArgs.temperature = _params.temperature;\n        if (_params?.topP !== undefined) messageCreateArgs.top_p = _params.topP;\n        if (_params?.topK !== undefined) messageCreateArgs.top_k = _params.topK;\n        if (_params?.stopSequences?.length) messageCreateArgs.stop_sequences = _params.stopSequences;\n\n        try {\n            const response = await anthropic.messages.create(messageCreateArgs);\n            let content = (response?.content?.[0] as Anthropic.TextBlock)?.text;\n            const finishReason = response?.stop_reason;\n\n            return { content, finishReason };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async multimodalRequest(acRequest: AccessRequest, prompt, params: TLLMParams, agent?: string | Agent): Promise<LLMChatResponse> {\n        throw new Error('Multimodal request is not supported for OpenAI.');\n    }\n\n    protected async toolRequest(acRequest: AccessRequest, params: TLLMParams): Promise<any> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n        try {\n            const apiKey = _params?.credentials?.apiKey;\n\n            // We do not provide default API key for claude, so user/team must provide their own API key\n            if (!apiKey) throw new Error(API_KEY_ERROR_MESSAGE);\n\n            const anthropic = new Anthropic({ apiKey });\n\n            const messageCreateArgs: Anthropic.MessageCreateParamsNonStreaming = {\n                model: _params?.model,\n                messages: [],\n                max_tokens: _params?.maxTokens || LLMRegistry.getMaxCompletionTokens(_params?.model, !!apiKey), // * max token is required\n            };\n\n            let messages = _params?.messages || [];\n\n            const hasSystemMessage = LLMHelper.hasSystemMessage(messages);\n            if (hasSystemMessage) {\n                // in AnthropicAI we need to provide system message separately\n                const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n\n                messageCreateArgs.system = ((systemMessage as TLLMMessageBlock)?.content as string) || '';\n\n                messages = otherMessages as Anthropic.MessageParam[];\n            }\n\n            messageCreateArgs.messages = messages;\n\n            if (_params?.toolsConfig?.tools && _params?.toolsConfig?.tools.length > 0) {\n                messageCreateArgs.tools = _params?.toolsConfig?.tools as Anthropic.Tool[];\n            }\n\n            // TODO (Forhad): implement claude specific token counting properly\n            // this.validateTokenLimit(params);\n\n            const result = await anthropic.messages.create(messageCreateArgs);\n            const message = {\n                role: result?.role || TLLMMessageRole.User,\n                content: result?.content || '',\n            };\n            const stopReason = result?.stop_reason;\n\n            let toolsData: ToolData[] = [];\n            let useTool = false;\n\n            if ((stopReason as 'tool_use') === 'tool_use') {\n                const toolUseContentBlocks = result?.content?.filter((c) => (c.type as 'tool_use') === 'tool_use');\n\n                if (toolUseContentBlocks?.length === 0) return;\n\n                message.content = toolUseContentBlocks;\n\n                toolUseContentBlocks.forEach((toolUseBlock: Anthropic.Messages.ToolUseBlock, index) => {\n                    toolsData.push({\n                        index,\n                        id: toolUseBlock?.id,\n                        type: 'function', // We call API only when the tool type is 'function' in `src/helpers/Conversation.helper.ts`. Even though Anthropic AI returns the type as 'tool_use', it should be interpreted as 'function'.\n                        name: toolUseBlock?.name,\n                        arguments: toolUseBlock?.input,\n                        role: result?.role,\n                    });\n                });\n\n                useTool = true;\n            }\n\n            const content = (result?.content?.[0] as Anthropic.TextBlock)?.text;\n\n            return {\n                data: {\n                    useTool,\n                    message,\n                    content,\n                    toolsData,\n                },\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async imageGenRequest(acRequest: AccessRequest, prompt, params: TLLMParams, agent?: string | Agent): Promise<ImagesResponse> {\n        throw new Error('Image generation request is not supported for AnthropicAI.');\n    }\n\n    // ! DEPRECATED METHOD\n    protected async streamToolRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<any> {\n        throw new Error('streamToolRequest() is Deprecated!');\n    }\n\n    protected async streamRequest(acRequest: AccessRequest, params: TLLMParams): Promise<EventEmitter> {\n        const _params: any = { ...params };\n        try {\n            const emitter = new EventEmitter();\n            const usage_data = [];\n\n            const apiKey = _params?.credentials?.apiKey;\n\n            // We do not provide default API key for claude, so user/team must provide their own API key\n            if (!apiKey) throw new Error(API_KEY_ERROR_MESSAGE);\n\n            const anthropic = new Anthropic({ apiKey });\n\n            const messageCreateArgs: Anthropic.Messages.MessageStreamParams = {\n                model: _params?.model,\n                messages: [],\n                max_tokens: _params?.maxTokens || LLMRegistry.getMaxCompletionTokens(_params?.model, !!apiKey), // * max token is required\n            };\n\n            console.debug('Using Model', _params?.model, 'Max Tokens=', _params?.maxTokens);\n            let messages = _params?.messages || [];\n\n            const hasSystemMessage = LLMHelper.hasSystemMessage(messages);\n            if (hasSystemMessage) {\n                // in Anthropic AI we need to provide system message separately\n                const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n\n                messageCreateArgs.system = ((systemMessage as TLLMMessageBlock)?.content as string | Array<TextBlockParam>) || '';\n                if (typeof messageCreateArgs.system === 'string') {\n                    messageCreateArgs.system = [\n                        {\n                            type: 'text',\n                            text: messageCreateArgs.system,\n                            //cache_control: { type: 'ephemeral' }, //TODO: @Forhad check this\n                        },\n                    ];\n                }\n\n                messageCreateArgs.system.unshift({\n                    type: 'text',\n                    text: 'If you need to call a function, Do NOT inform the user that you are about to do so, and do not thank the user after you get the response. Just say something like \"Give me a moment...\", then when you get the response, Just continue answering the user without saying anything about the function you just called',\n                });\n\n                if (_params?.cache) {\n                    messageCreateArgs.system[messageCreateArgs.system.length - 1]['cache_control'] = { type: 'ephemeral' };\n                }\n\n                messages = otherMessages as Anthropic.MessageParam[];\n            }\n\n            messageCreateArgs.messages = messages;\n\n            if (_params?.toolsConfig?.tools && _params?.toolsConfig?.tools.length > 0) {\n                messageCreateArgs.tools = JSON.parse(JSON.stringify(_params?.toolsConfig?.tools)) as Anthropic.Tool[];\n                if (_params?.cache) {\n                    messageCreateArgs.tools[messageCreateArgs.tools.length - 1]['cache_control'] = { type: 'ephemeral' };\n                }\n            }\n            if (_params?.toolsConfig?.tool_choice) {\n                messageCreateArgs.tool_choice = _params?.toolsConfig?.tool_choice;\n            }\n\n            let stream;\n            if (_params?.cache) {\n                stream = anthropic.beta.promptCaching.messages.stream(messageCreateArgs, {\n                    headers: { 'anthropic-beta': 'prompt-caching-2024-07-31' },\n                });\n            } else {\n                stream = anthropic.messages.stream(messageCreateArgs);\n            }\n\n            stream.on('streamEvent', (event: any) => {\n                if (event.message?.usage) {\n                    //console.log('usage', event.message?.usage);\n                }\n            });\n\n            let toolsData: ToolData[] = [];\n\n            stream.on('error', (error) => {\n                //console.log('error', error);\n\n                emitter.emit('error', error);\n            });\n            stream.on('text', (text: string) => {\n                emitter.emit('content', text);\n            });\n\n            const finalMessage = _params?.cache ? 'finalPromptCachingBetaMessage' : 'finalMessage';\n            stream.on(finalMessage, (finalMessage) => {\n                //console.log('finalMessage', finalMessage);\n                const toolUseContentBlocks = finalMessage?.content?.filter((c) => (c.type as 'tool_use') === 'tool_use');\n\n                if (toolUseContentBlocks?.length > 0) {\n                    toolUseContentBlocks.forEach((toolUseBlock: Anthropic.Messages.ToolUseBlock, index) => {\n                        toolsData.push({\n                            index,\n                            id: toolUseBlock?.id,\n                            type: 'function', // We call API only when the tool type is 'function' in `src/helpers/Conversation.helper.ts`. Even though Anthropic AI returns the type as 'tool_use', it should be interpreted as 'function'.\n                            name: toolUseBlock?.name,\n                            arguments: toolUseBlock?.input,\n                            role: finalMessage?.role,\n                        });\n                    });\n\n                    emitter.emit('toolsData', toolsData);\n                }\n\n                if (finalMessage?.usage) {\n                    const usage = finalMessage.usage;\n                    usage_data.push({\n                        prompt_tokens: usage.input_tokens + usage.cache_creation_input_tokens + usage.cache_read_input_tokens,\n                        completion_tokens: usage.output_tokens,\n                        total_tokens: usage.input_tokens + usage.output_tokens + usage.cache_read_input_tokens + usage.cache_creation_input_tokens,\n                        prompt_tokens_details: { cached_tokens: usage.cache_read_input_tokens },\n                        completion_tokens_details: { reasoning_tokens: 0 },\n                    });\n                }\n                //only emit end event after processing the final message\n                setTimeout(() => {\n                    emitter.emit('end', toolsData, usage_data);\n                }, 100);\n            });\n\n            return emitter;\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        let tools: {\n            name: string;\n            description: string;\n            input_schema: {\n                type: 'object';\n                properties: Record<string, unknown>;\n                required: string[];\n            };\n        }[] = [];\n\n        if (type === 'function') {\n            tools = toolDefinitions.map((tool) => {\n                const { name, description, properties, requiredFields } = tool;\n\n                return {\n                    name,\n                    description,\n                    input_schema: {\n                        type: 'object',\n                        properties,\n                        required: requiredFields,\n                    },\n                };\n            });\n        }\n\n        return tools?.length > 0 ? { tools } : {};\n    }\n\n    public transformToolMessageBlocks({\n        messageBlock,\n        toolsData,\n    }: {\n        messageBlock: TLLMMessageBlock;\n        toolsData: ToolData[];\n    }): TLLMToolResultMessageBlock[] {\n        const messageBlocks: TLLMToolResultMessageBlock[] = [];\n\n        if (messageBlock) {\n            const content: any[] = []; // TODO: set proper type for content\n            if (Array.isArray(messageBlock.content)) {\n                content.push(...messageBlock.content);\n            } else {\n                content.push({ type: 'text', text: messageBlock.content });\n            }\n            if (messageBlock.tool_calls) {\n                const calls = messageBlock.tool_calls.map((toolCall: any) => ({\n                    type: 'tool_use',\n                    id: toolCall.id,\n                    name: toolCall?.function?.name,\n                    input: toolCall?.function?.arguments,\n                }));\n\n                content.push(...calls);\n            }\n\n            messageBlocks.push({\n                role: messageBlock?.role,\n                content: content,\n            });\n        }\n\n        // Combine all tool results into a single user message\n        const toolResultsContent = toolsData.map((toolData): any => ({\n            type: 'tool_result',\n            tool_use_id: toolData.id,\n            content: toolData.result,\n        }));\n\n        if (toolResultsContent.length > 0) {\n            messageBlocks.push({\n                role: TLLMMessageRole.User,\n                content: toolResultsContent,\n            });\n        }\n\n        return messageBlocks;\n    }\n\n    // TODO [Forhad]: This method is quite lengthy and complex. Consider breaking it down into smaller, more manageable functions for better readability and maintainability.\n    public getConsistentMessages(messages) {\n        let _messages = JSON.parse(JSON.stringify(messages));\n\n        // Extract the system message from the beginning as we have logic that checks 'user' for the first message\n        let systemMessage = null;\n        if (_messages[0]?.role === TLLMMessageRole.System) {\n            systemMessage = _messages.shift();\n        }\n\n        _messages = LLMHelper.removeDuplicateUserMessages(_messages);\n\n        _messages = _messages.map((message) => {\n            let content;\n\n            if (message?.parts) {\n                content = message.parts.map((textBlock) => textBlock?.text || '').join(' ');\n            } else if (Array.isArray(message?.content)) {\n                if (Array.isArray(message.content)) {\n                    const toolBlocks = message.content.filter(\n                        (item) => typeof item === 'object' && 'type' in item && (item.type === 'tool_use' || item.type === 'tool_result')\n                    );\n\n                    if (toolBlocks?.length > 0) {\n                        content = message.content.map((item) => {\n                            if (item.type === 'text' && (!item.text || item.text.trim() === '')) {\n                                return { ...item, text: '...' }; // empty text causes error that's why we added '...'\n                            }\n                            return item;\n                        });\n                    } else {\n                        content = message.content\n                            .map((block) => block?.text || '')\n                            .join(' ')\n                            .trim();\n                    }\n                } else {\n                    content = message.content;\n                }\n            } else if (message?.content) {\n                content = message.content as string;\n            }\n\n            message.content = content || '...'; // empty content causes error that's why we added '...'\n\n            return message;\n        });\n\n        //[FIXED] - `tool_result` block(s) provided when previous message does not contain any `tool_use` blocks\" (handler)\n        if (_messages[0]?.role === TLLMMessageRole.User && Array.isArray(_messages[0].content)) {\n            const hasToolResult = _messages[0].content.find((content) => 'type' in content && content.type === 'tool_result');\n\n            //we found a tool result in the first message, so we need to remove the user message\n            if (hasToolResult) {\n                _messages.shift();\n            }\n        }\n\n        // - Error: 400 {\"type\":\"error\",\"error\":{\"type\":\"invalid_request_error\",\"message\":\"messages: first message must use the \\\"user\\\" role\"}}\n        if (_messages[0]?.role !== TLLMMessageRole.User) {\n            _messages.unshift({ role: TLLMMessageRole.User, content: 'continue' }); //add an empty user message to keep the consistency\n        }\n\n        // Add the system message back to the beginning\n        if (systemMessage) {\n            _messages.unshift(systemMessage);\n        }\n\n        return _messages;\n    }\n\n    private getValidImageFileSources(fileSources: BinaryInput[]) {\n        const validSources = [];\n\n        for (let fileSource of fileSources) {\n            if (this.validImageMimeTypes.includes(fileSource?.mimetype)) {\n                validSources.push(fileSource);\n            }\n        }\n\n        if (validSources?.length === 0) {\n            throw new Error(`Unsupported file(s). Please make sure your file is one of the following types: ${this.validImageMimeTypes.join(', ')}`);\n        }\n\n        return validSources;\n    }\n\n    private async getImageData(\n        fileSources: BinaryInput[],\n        agentId: string\n    ): Promise<\n        {\n            type: string;\n            source: { type: 'base64'; data: string; media_type: string };\n        }[]\n    > {\n        try {\n            const imageData = [];\n\n            for (let fileSource of fileSources) {\n                const bufferData = await fileSource.readData(AccessCandidate.agent(agentId));\n                const base64Data = bufferData.toString('base64');\n\n                imageData.push({\n                    type: 'image',\n                    source: {\n                        type: 'base64',\n                        data: base64Data,\n                        media_type: fileSource.mimetype,\n                    },\n                });\n            }\n\n            return imageData;\n        } catch (error) {\n            throw error;\n        }\n    }\n}\n","import Groq from 'groq-sdk';\nimport EventEmitter from 'events';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { TOOL_USE_DEFAULT_MODEL, JSON_RESPONSE_INSTRUCTION } from '@sre/constants';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { TLLMParams, TLLMMessageBlock, ToolData, TLLMMessageRole } from '@sre/types/LLM.types';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\n\nimport { ImagesResponse, LLMChatResponse, LLMConnector } from '../LLMConnector';\n\nconst console = Logger('GroqConnector');\n\ntype ChatCompletionCreateParams = {\n    model: string;\n    messages: any;\n    max_tokens?: number;\n    temperature?: number;\n    stop?: string[];\n    top_p?: number;\n    tools?: any;\n    tool_choice?: string;\n    stream?: boolean;\n};\n\ntype ToolRequestParams = {\n    model: string;\n    messages: TLLMMessageBlock[];\n    toolsConfig: { tools: ToolData[]; tool_choice: string };\n    credentials: { apiKey: string };\n};\n\n// TODO [Forhad]: Apply proper types at for function params and return value\n\nexport class GroqConnector extends LLMConnector {\n    public name = 'LLM:Groq';\n\n    protected async chatRequest(acRequest: AccessRequest, params: TLLMParams): Promise<LLMChatResponse> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n        let messages = _params?.messages || [];\n\n        //#region Handle JSON response format\n        const responseFormat = _params?.responseFormat || '';\n        if (responseFormat === 'json') {\n            if (messages?.[0]?.role === 'system') {\n                messages[0].content += JSON_RESPONSE_INSTRUCTION;\n            } else {\n                messages.unshift({ role: 'system', content: JSON_RESPONSE_INSTRUCTION });\n            }\n        }\n        //#endregion Handle JSON response format\n\n        const apiKey = _params?.credentials?.apiKey;\n        if (!apiKey) throw new Error('Please provide an API key for Groq');\n\n        const groq = new Groq({ apiKey });\n\n        // TODO: implement groq specific token counting\n        // this.validateTokensLimit(_params);\n\n        const chatCompletionArgs: {\n            model: string;\n            messages: any; // TODO [Forhad]: apply proper typing\n            max_tokens?: number;\n            temperature?: number;\n            top_p?: number;\n            stop?: string[];\n        } = {\n            model: _params.model,\n            messages,\n        };\n\n        if (_params.maxTokens !== undefined) chatCompletionArgs.max_tokens = _params.maxTokens;\n        if (_params.temperature !== undefined) chatCompletionArgs.temperature = _params.temperature;\n        if (_params.topP !== undefined) chatCompletionArgs.top_p = _params.topP;\n        if (_params.stopSequences?.length) chatCompletionArgs.stop = _params.stopSequences;\n\n        try {\n            const response: any = await groq.chat.completions.create(chatCompletionArgs);\n            const content = response.choices[0]?.message?.content;\n            const finishReason = response.choices[0]?.finish_reason;\n\n            return { content, finishReason };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async visionRequest(acRequest: AccessRequest, prompt, params: TLLMParams, agent?: string | Agent): Promise<LLMChatResponse> {\n        throw new Error('Vision requests are not supported by Groq');\n    }\n\n    protected async multimodalRequest(acRequest: AccessRequest, prompt, params: TLLMParams, agent?: string | Agent): Promise<LLMChatResponse> {\n        throw new Error('Multimodal request is not supported for OpenAI.');\n    }\n\n    protected async toolRequest(acRequest: AccessRequest, params: TLLMParams): Promise<any> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n        try {\n            const apiKey = _params?.credentials?.apiKey;\n\n            const groq = new Groq({ apiKey });\n\n            const messages = _params?.messages || [];\n\n            let chatCompletionArgs: ChatCompletionCreateParams = {\n                model: _params.model,\n                messages,\n            };\n\n            if (_params.maxTokens) chatCompletionArgs.max_tokens = _params.maxTokens;\n\n            if (_params?.toolsConfig?.tools) chatCompletionArgs.tools = _params?.toolsConfig?.tools;\n            if (_params?.toolsConfig?.tool_choice) chatCompletionArgs.tool_choice = _params?.toolsConfig?.tool_choice as any; // TODO [Forhad]: apply proper typing\n\n            const result = await groq.chat.completions.create(chatCompletionArgs as any); // TODO [Forhad]: apply proper typing\n            const message = result?.choices?.[0]?.message;\n            const toolCalls = message?.tool_calls;\n\n            let toolsData: ToolData[] = [];\n            let useTool = false;\n\n            if (toolCalls) {\n                toolsData = toolCalls.map((tool, index) => ({\n                    index,\n                    id: tool.id,\n                    type: tool.type,\n                    name: tool.function.name,\n                    arguments: tool.function.arguments,\n                    role: TLLMMessageRole.Assistant,\n                }));\n                useTool = true;\n            }\n\n            return {\n                data: { useTool, message, content: message?.content ?? '', toolsData },\n            };\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    protected async imageGenRequest(acRequest: AccessRequest, prompt, params: TLLMParams, agent?: string | Agent): Promise<ImagesResponse> {\n        throw new Error('Image generation request is not supported for Groq.');\n    }\n\n    // ! DEPRECATED METHOD\n    protected async streamToolRequest(\n        acRequest: AccessRequest,\n        { model = TOOL_USE_DEFAULT_MODEL, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }\n    ): Promise<any> {\n        throw new Error('streamToolRequest() is Deprecated!');\n    }\n\n    protected async streamRequest(acRequest: AccessRequest, params: TLLMParams): Promise<EventEmitter> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n        const emitter = new EventEmitter();\n        const apiKey = _params?.credentials?.apiKey;\n\n        const groq = new Groq({ apiKey });\n\n        const messages = _params?.messages || [];\n\n        let chatCompletionArgs: {\n            model: string;\n            messages: any; // TODO [Forhad]: apply proper typing\n            max_tokens?: number;\n            tools?: any; // TODO [Forhad]: apply proper typing\n            tool_choice?: any; // TODO [Forhad]: apply proper typing\n            stream?: boolean;\n        } = {\n            model: _params.model,\n            messages,\n            stream: true,\n        };\n\n        if (_params?.maxTokens !== undefined) chatCompletionArgs.max_tokens = _params.maxTokens;\n\n        if (_params.toolsConfig?.tools) chatCompletionArgs.tools = _params.toolsConfig?.tools;\n        if (_params.toolsConfig?.tool_choice) chatCompletionArgs.tool_choice = _params.toolsConfig?.tool_choice;\n\n        try {\n            const stream = await groq.chat.completions.create(chatCompletionArgs);\n\n            let toolsData: ToolData[] = [];\n\n            (async () => {\n                for await (const chunk of stream as any) {\n                    const delta = chunk.choices[0]?.delta;\n                    emitter.emit('data', delta);\n\n                    if (delta?.content) {\n                        emitter.emit('content', delta.content);\n                    }\n\n                    if (delta?.tool_calls) {\n                        delta.tool_calls.forEach((toolCall, index) => {\n                            if (!toolsData[index]) {\n                                toolsData[index] = {\n                                    index,\n                                    id: toolCall.id,\n                                    type: toolCall.type,\n                                    name: toolCall.function?.name,\n                                    arguments: toolCall.function?.arguments,\n                                    role: 'assistant',\n                                };\n                            } else {\n                                toolsData[index].arguments += toolCall.function?.arguments || '';\n                            }\n                        });\n                    }\n                }\n\n                if (toolsData.length > 0) {\n                    emitter.emit('toolsData', toolsData);\n                }\n\n                setTimeout(() => {\n                    emitter.emit('end', toolsData);\n                }, 100);\n            })();\n\n            return emitter;\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        let tools = [];\n\n        if (type === 'function') {\n            tools = toolDefinitions.map((tool) => {\n                const { name, description, properties, requiredFields } = tool;\n\n                return {\n                    type: 'function',\n                    function: {\n                        name,\n                        description,\n                        parameters: {\n                            type: 'object',\n                            properties,\n                            required: requiredFields,\n                        },\n                    },\n                };\n            });\n        }\n\n        return tools?.length > 0 ? { tools, tool_choice: toolChoice } : {};\n    }\n\n    public getConsistentMessages(messages: TLLMMessageBlock[]): TLLMMessageBlock[] {\n        const _messages = LLMHelper.removeDuplicateUserMessages(messages);\n\n        return _messages.map((message) => {\n            const _message = { ...message };\n            let textContent = '';\n\n            if (message?.parts) {\n                textContent = message.parts.map((textBlock) => textBlock?.text || '').join(' ');\n            } else if (Array.isArray(message?.content)) {\n                textContent = message.content.map((textBlock) => textBlock?.text || '').join(' ');\n            } else if (message?.content) {\n                textContent = message.content as string;\n            }\n\n            _message.content = textContent;\n\n            return _message;\n        });\n    }\n}\n","import {\n    BedrockRuntimeClient,\n    ConverseCommand,\n    ConverseCommandInput,\n    ConverseStreamCommandInput,\n    ConverseStreamCommand,\n    ConverseStreamCommandOutput,\n} from '@aws-sdk/client-bedrock-runtime';\nimport EventEmitter from 'events';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { JSON_RESPONSE_INSTRUCTION } from '@sre/constants';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { TLLMParams, ToolData, TLLMMessageBlock, TLLMToolResultMessageBlock, TLLMMessageRole, GenerateImageConfig } from '@sre/types/LLM.types';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\nimport { customModels } from '@sre/LLMManager/custom-models';\nimport { isJSONString } from '@sre/utils/general.utils';\n\nimport { ImagesResponse, LLMChatResponse, LLMConnector } from '../LLMConnector';\n\nconst console = Logger('BedrockConnector');\n\ntype InferenceConfig = {\n    maxTokens?: number;\n    temperature?: number;\n    stopSequences?: string[];\n    topP?: number;\n};\n\n// TODO: Need to adjust some type definitions\n\nexport class BedrockConnector extends LLMConnector {\n    public name = 'LLM:Bedrock';\n\n    protected async chatRequest(acRequest: AccessRequest, params: TLLMParams): Promise<LLMChatResponse> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n        let messages = _params?.messages || [];\n\n        //#region Separate system message and add JSON response instruction if needed\n        let systemPrompt;\n        const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n\n        if ('content' in systemMessage) {\n            systemPrompt = systemMessage.content;\n        }\n\n        messages = otherMessages;\n\n        const responseFormat = _params?.responseFormat || '';\n        if (responseFormat === 'json') {\n            systemPrompt = [{ text: JSON_RESPONSE_INSTRUCTION }];\n        }\n\n        const modelInfo = _params.modelInfo;\n        const supportsSystemPrompt = customModels[modelInfo?.settings?.foundationModel]?.supportsSystemPrompt;\n\n        if (!supportsSystemPrompt) {\n            messages[0].content?.push(systemPrompt[0]);\n            systemPrompt = undefined; // Reset system prompt if it's not supported\n        }\n\n        //#endregion Separate system message and add JSON response instruction if needed\n\n        const modelId = modelInfo.settings?.customModel || modelInfo.settings?.foundationModel;\n\n        const inferenceConfig: InferenceConfig = {};\n        if (_params?.maxTokens !== undefined) inferenceConfig.maxTokens = _params.maxTokens;\n        if (_params?.temperature !== undefined) inferenceConfig.temperature = _params.temperature;\n        if (_params?.topP !== undefined) inferenceConfig.topP = _params.topP;\n        if (_params?.stopSequences?.length) inferenceConfig.stopSequences = _params.stopSequences;\n\n        const converseCommandInput: any = {\n            modelId,\n            messages,\n        };\n\n        if (Object.keys(inferenceConfig).length > 0) {\n            converseCommandInput.inferenceConfig = inferenceConfig;\n        }\n\n        if (systemPrompt) {\n            converseCommandInput.system = systemPrompt;\n        }\n\n        const command = new ConverseCommand(converseCommandInput);\n\n        try {\n            const client = new BedrockRuntimeClient({\n                region: modelInfo.settings.region,\n                credentials: _params?.credentials,\n            });\n\n            const response = await client.send(command);\n            const content = response.output?.message?.content?.[0]?.text;\n\n            return { content, finishReason: 'stop' };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async streamToolRequest(acRequest: AccessRequest, { model, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }): Promise<any> {\n        throw new Error('streamToolRequest() is Deprecated!');\n    }\n\n    protected async visionRequest(acRequest: AccessRequest, prompt, params, agent?: string | Agent): Promise<LLMChatResponse> {\n        throw new Error('Vision requests are not supported by Bedrock');\n    }\n\n    protected async multimodalRequest(acRequest: AccessRequest, prompt, params: any, agent?: string | Agent): Promise<LLMChatResponse> {\n        throw new Error('Multimodal request is not supported for Bedrock.');\n    }\n\n    protected async toolRequest(acRequest: AccessRequest, params): Promise<any> {\n        try {\n            const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n            const customModelInfo = _params.modelInfo;\n\n            const client = new BedrockRuntimeClient({\n                region: customModelInfo.settings.region,\n                credentials: _params?.credentials,\n            });\n\n            let systemPrompt;\n            let messages = _params?.messages || [];\n\n            const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n\n            if ('content' in systemMessage) {\n                systemPrompt = [{ text: systemMessage?.content }];\n            }\n\n            messages = otherMessages;\n\n            const converseCommandInput: ConverseCommandInput = {\n                modelId: customModelInfo.settings?.customModel || customModelInfo.settings?.foundationModel,\n                messages,\n            };\n\n            if (systemPrompt) {\n                converseCommandInput.system = systemPrompt;\n            }\n\n            if (_params?.toolsConfig?.tools?.length > 0) {\n                converseCommandInput.toolConfig = {\n                    tools: _params?.toolsConfig?.tools,\n                    ...(_params?.toolsConfig?.tool_choice && { toolChoice: _params?.toolsConfig?.tool_choice }),\n                };\n            }\n\n            const command = new ConverseCommand(converseCommandInput);\n            const response = await client.send(command);\n\n            const message = response.output?.message;\n            const finishReason = response.stopReason;\n\n            let toolsInfo: ToolData[] = [];\n            let useTool = false;\n\n            if (finishReason === 'tool_use') {\n                const toolUseBlocks = message?.content?.filter((block) => block?.toolUse) || [];\n\n                toolsInfo = toolUseBlocks.map((block, index) => ({\n                    index,\n                    id: block.toolUse?.toolUseId as string,\n                    type: 'function', // We call API only when the tool type is 'function' in src/services/LLMHelper/ToolExecutor.class.ts`. Even though Claude returns the type as 'tool_use', it should be interpreted as 'function'.,\n                    name: _deserializeToolName(block.toolUse?.name as string),\n                    arguments: block.toolUse?.input as Record<string, any>,\n                    role: 'tool',\n                }));\n                useTool = true;\n            }\n\n            return {\n                data: {\n                    useTool,\n                    message,\n                    content: message?.content || '',\n                    toolsInfo,\n                },\n            };\n        } catch (error: any) {\n            throw error?.error || error;\n        }\n    }\n\n    protected async imageGenRequest(acRequest: AccessRequest, prompt, params: any, agent?: string | Agent): Promise<ImagesResponse> {\n        throw new Error('Image generation request is not supported for Bedrock.');\n    }\n\n    protected async streamRequest(acRequest: AccessRequest, params): Promise<EventEmitter> {\n        const emitter = new EventEmitter();\n\n        try {\n            const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n\n            const customModelInfo = _params.modelInfo;\n\n            const client = new BedrockRuntimeClient({\n                region: customModelInfo.settings.region,\n                credentials: _params?.credentials,\n            });\n\n            let systemPrompt;\n            let messages = _params?.messages || [];\n\n            // Handle system message separation\n            const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n\n            if ('content' in systemMessage) {\n                systemPrompt = [{ text: systemMessage?.content }];\n            }\n\n            messages = otherMessages;\n\n            const converseCommandInput: ConverseStreamCommandInput = {\n                modelId: customModelInfo.settings?.customModel || customModelInfo.settings?.foundationModel,\n                messages,\n            };\n\n            if (systemPrompt) {\n                converseCommandInput.system = systemPrompt;\n            }\n\n            if (_params?.toolsConfig?.tools?.length > 0) {\n                converseCommandInput.toolConfig = {\n                    tools: _params?.toolsConfig?.tools,\n                    ...(_params?.toolsConfig?.tool_choice && { toolChoice: _params?.toolsConfig?.tool_choice }),\n                };\n            }\n\n            const command = new ConverseStreamCommand(converseCommandInput);\n            const response: ConverseStreamCommandOutput = await client.send(command);\n            const stream = response.stream;\n\n            if (stream) {\n                (async () => {\n                    let currentMessage = {\n                        role: '',\n                        content: '',\n                        toolCalls: [] as any[],\n                        currentToolCall: null as any,\n                        currentToolInput: '' as string,\n                    };\n\n                    for await (const chunk of stream) {\n                        // Handle message start\n                        if (chunk.messageStart) {\n                            currentMessage.role = chunk.messageStart.role || '';\n                            emitter.emit('data', { role: currentMessage.role });\n                        }\n\n                        // Handle content deltas\n                        if (chunk.contentBlockDelta?.delta?.text) {\n                            currentMessage.content += chunk.contentBlockDelta.delta.text;\n                            emitter.emit('data', chunk.contentBlockDelta.delta.text);\n                            emitter.emit('content', chunk.contentBlockDelta.delta.text, currentMessage.role);\n                        }\n\n                        // Handle tool use start\n                        if (chunk.contentBlockStart?.start?.toolUse) {\n                            const toolUse = chunk.contentBlockStart.start.toolUse;\n                            if (toolUse.toolUseId && toolUse.name) {\n                                currentMessage.currentToolCall = {\n                                    index: currentMessage.toolCalls.length,\n                                    id: toolUse.toolUseId,\n                                    type: 'function',\n                                    name: _deserializeToolName(toolUse.name),\n                                    arguments: '',\n                                    role: 'tool',\n                                };\n                                currentMessage.currentToolInput = '';\n                            }\n                        }\n\n                        // Handle tool use input deltas\n                        if (chunk.contentBlockDelta?.delta?.toolUse?.input && currentMessage.currentToolCall) {\n                            currentMessage.currentToolInput += chunk.contentBlockDelta.delta.toolUse.input;\n                            currentMessage.currentToolCall.arguments = currentMessage.currentToolInput;\n                        }\n\n                        // Handle tool use block completion\n                        if (chunk.contentBlockStop && currentMessage.currentToolCall) {\n                            // Parse JSON arguments if possible\n                            if (\n                                typeof currentMessage.currentToolCall.arguments === 'string' &&\n                                isJSONString(currentMessage.currentToolCall.arguments)\n                            ) {\n                                currentMessage.currentToolCall.arguments = JSON.parse(currentMessage.currentToolCall.arguments);\n                            }\n\n                            currentMessage.toolCalls.push(currentMessage.currentToolCall);\n                            emitter.emit('toolsData', currentMessage.toolCalls);\n                            currentMessage.currentToolCall = null;\n                            currentMessage.currentToolInput = '';\n                        }\n\n                        // Handle message completion\n                        if (chunk.messageStop) {\n                            emitter.emit('end', currentMessage.toolCalls);\n                        }\n                    }\n                })();\n            }\n\n            return emitter;\n        } catch (error: unknown) {\n            const typedError = error as Error;\n            emitter.emit('error', typedError?.['error'] || typedError);\n            return emitter;\n        }\n    }\n\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        let tools: any[] = [];\n\n        if (type === 'function') {\n            tools = toolDefinitions.map((tool) => {\n                const { name, description, properties, requiredFields } = tool;\n\n                return {\n                    toolSpec: {\n                        name: _serializeToolName(name),\n                        description,\n                        inputSchema: {\n                            json: {\n                                type: 'object',\n                                properties,\n                                required: requiredFields,\n                            },\n                        },\n                    },\n                };\n            });\n        }\n\n        return tools?.length > 0 ? { tools, toolChoice: toolChoice || 'auto' } : {};\n    }\n\n    public transformToolMessageBlocks({\n        messageBlock,\n        toolsData,\n    }: {\n        messageBlock: TLLMMessageBlock;\n        toolsData: ToolData[];\n    }): TLLMToolResultMessageBlock[] {\n        const messageBlocks: any[] = [];\n\n        if (messageBlock) {\n            const content: any[] = []; // TODO: set proper type for content\n\n            if (typeof messageBlock.content === 'string') {\n                content.push({ text: messageBlock.content });\n            } else if (Array.isArray(messageBlock.content)) {\n                content.push(...messageBlock.content);\n            }\n\n            if (messageBlock.tool_calls?.length) {\n                messageBlock.tool_calls.forEach((toolCall: Record<string, any>) => {\n                    content.push({\n                        toolUse: {\n                            toolUseId: toolCall.id,\n                            name: _serializeToolName(toolCall?.function?.name),\n                            input: toolCall?.function?.arguments || {},\n                        },\n                    });\n                });\n            }\n\n            messageBlocks.push({\n                role: messageBlock?.role,\n                content,\n            });\n        }\n\n        // Add tool results as user message\n        if (toolsData?.length) {\n            const toolResultsContent = toolsData\n                .filter((tool) => tool.id && (tool.result || tool.error))\n                .map((tool) => {\n                    let content;\n\n                    // * Note: We also have two other types of results: image and document. - https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/bedrock-runtime/command/ConverseStreamCommand/\n                    if (typeof tool?.result === 'string') {\n                        content = [{ text: tool.result as string }];\n                    } else if (typeof tool?.result === 'object') {\n                        content = [{ json: tool.result }];\n                    }\n\n                    return {\n                        toolResult: {\n                            toolUseId: tool.id,\n                            content: content,\n                            ...(tool.error && { status: 'error' }),\n                        },\n                    };\n                });\n\n            if (toolResultsContent.length > 0) {\n                messageBlocks.push({\n                    role: TLLMMessageRole.User,\n                    content: toolResultsContent,\n                });\n            }\n        }\n\n        return messageBlocks;\n    }\n\n    public getConsistentMessages(messages: TLLMMessageBlock[]): TLLMMessageBlock[] {\n        const _messages = LLMHelper.removeDuplicateUserMessages(messages);\n\n        return _messages.map((message) => {\n            let textBlock = [];\n\n            if (message?.parts) {\n                textBlock = message.parts;\n            } else if (message?.content) {\n                textBlock = Array.isArray(message.content) ? message.content : [{ text: message.content as string }];\n            }\n\n            return {\n                role: message.role,\n                content: textBlock,\n            };\n        });\n    }\n}\n\n/**\n * Serializes a name by converting dashes to double underscores for Bedrock compatibility\n * @param name - The original name containing dashes\n * @returns The serialized name with dashes replaced by double underscores\n */\nfunction _serializeToolName(name: string): string {\n    return name?.replace(/-/g, '__');\n}\n\n/**\n * Deserializes a Bedrock Tool name by converting double underscores back to dashes\n * @param name - The serialized name containing double underscores\n * @returns The deserialized name with double underscores replaced by dashes\n */\nfunction _deserializeToolName(name: string): string {\n    return name?.replace(/__/g, '-');\n}\n","import { VertexAI, type ModelParams, type GenerationConfig, type Content } from '@google-cloud/vertexai';\nimport EventEmitter from 'events';\n\nimport Agent from '@sre/AgentManager/Agent.class';\nimport { JSON_RESPONSE_INSTRUCTION } from '@sre/constants';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { TLLMParams, TLLMMessageBlock, TLLMMessageRole, TVertexAIModel } from '@sre/types/LLM.types';\nimport { VaultHelper } from '@sre/Security/Vault.service/Vault.helper';\nimport { LLMHelper } from '@sre/LLMManager/LLM.helper';\n\nimport { ImagesResponse, LLMChatResponse, LLMConnector } from '../LLMConnector';\n\nconst console = Logger('VertexAIConnector');\n\nexport class VertexAIConnector extends LLMConnector {\n    public name = 'LLM:VertexAI';\n\n    protected async chatRequest(acRequest: AccessRequest, params: TLLMParams): Promise<LLMChatResponse> {\n        const _params = JSON.parse(JSON.stringify(params)); // Avoid mutation of the original params\n        let messages = _params?.messages || [];\n\n        //#region Separate system message and add JSON response instruction if needed\n        let systemInstruction;\n        const { systemMessage, otherMessages } = LLMHelper.separateSystemMessages(messages);\n\n        if ('content' in systemMessage) {\n            systemInstruction = systemMessage.content;\n        }\n\n        messages = otherMessages;\n\n        const responseFormat = _params?.responseFormat || '';\n        if (responseFormat === 'json') {\n            systemInstruction = JSON_RESPONSE_INSTRUCTION;\n        }\n        //#endregion Separate system message and add JSON response instruction if needed\n\n        const modelInfo = _params.modelInfo as TVertexAIModel;\n\n        const generationConfig: GenerationConfig = {};\n        if (_params?.maxTokens !== undefined) generationConfig.maxOutputTokens = _params.maxTokens;\n        if (_params?.temperature !== undefined) generationConfig.temperature = _params.temperature;\n        if (_params?.topP !== undefined) generationConfig.topP = _params.topP;\n        if (_params?.topK !== undefined) generationConfig.topK = _params.topK;\n        if (_params?.stopSequences?.length) generationConfig.stopSequences = _params.stopSequences;\n\n        const modelParams: ModelParams = {\n            model: modelInfo?.settings?.customModel || modelInfo?.settings?.foundationModel,\n        };\n\n        if (systemInstruction) {\n            modelParams.systemInstruction = systemInstruction;\n        }\n\n        if (Object.keys(generationConfig).length > 0) {\n            modelParams.generationConfig = generationConfig;\n        }\n\n        try {\n            const client = new VertexAI({\n                project: modelInfo.settings.projectId,\n                location: modelInfo?.settings?.region,\n                googleAuthOptions: {\n                    credentials: _params.credentials as any, // TODO [Forhad]: apply proper typing\n                },\n                apiEndpoint: `${modelInfo?.settings?.region}-aiplatform.googleapis.com`,\n            });\n            const generativeModel = client.getGenerativeModel(modelParams);\n\n            const result = await generativeModel.generateContent({ contents: messages });\n            const content = result?.response?.candidates?.[0]?.content?.parts?.[0]?.text;\n\n            return { content, finishReason: 'stop' };\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    protected async streamToolRequest(acRequest: AccessRequest, { model, messages, toolsConfig: { tools, tool_choice }, apiKey = '' }): Promise<any> {\n        throw new Error('streamToolRequest() is not supported by Vertex AI');\n    }\n\n    protected async visionRequest(acRequest: AccessRequest, prompt, params, agent?: string | Agent): Promise<LLMChatResponse> {\n        throw new Error('Vision requests are not currently implemented for Vertex AI');\n    }\n\n    protected async multimodalRequest(acRequest: AccessRequest, prompt, params: any, agent?: string | Agent): Promise<LLMChatResponse> {\n        throw new Error('Multimodal request is not currently implemented for Vertex AI');\n    }\n\n    protected async toolRequest(acRequest: AccessRequest, params): Promise<any> {\n        throw new Error('Tool requests are not currently implemented for Vertex AI');\n    }\n\n    protected async imageGenRequest(acRequest: AccessRequest, prompt, params: any, agent?: string | Agent): Promise<ImagesResponse> {\n        throw new Error('Image generation request is not currently implemented for Vertex AI');\n    }\n\n    protected async streamRequest(acRequest: AccessRequest, params): Promise<EventEmitter> {\n        throw new Error('Streaming is not currently implemented for Vertex AI');\n    }\n\n    public formatToolsConfig({ type = 'function', toolDefinitions, toolChoice = 'auto' }) {\n        throw new Error('Tool configuration is not currently implemented for Vertex AI');\n    }\n\n    public getConsistentMessages(messages) {\n        const _messages = LLMHelper.removeDuplicateUserMessages(messages);\n\n        return _messages.map((message) => {\n            let textBlock = [];\n\n            if (message?.parts) {\n                textBlock = message.parts;\n            } else if (message?.content) {\n                textBlock = Array.isArray(message.content) ? message.content : [{ text: message.content as string }];\n            }\n\n            return {\n                role: message.role,\n                parts: textBlock,\n            };\n        });\n    }\n}\n","//==[ SRE: LLM ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { EchoConnector } from './connectors/Echo.class';\nimport { OpenAIConnector } from './connectors/OpenAI.class';\nimport { GoogleAIConnector } from './connectors/GoogleAI.class';\nimport { AnthropicAIConnector } from './connectors/AnthropicAI.class';\nimport { GroqConnector } from './connectors/Groq.class';\nimport { BedrockConnector } from './connectors/Bedrock.class';\nimport { VertexAIConnector } from './connectors/VertexAI.class';\n\nexport class LLMService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.LLM, 'Echo', EchoConnector);\n        ConnectorService.register(TConnectorService.LLM, 'OpenAI', OpenAIConnector);\n        ConnectorService.register(TConnectorService.LLM, 'DeepSeek', OpenAIConnector);\n        ConnectorService.register(TConnectorService.LLM, 'GoogleAI', GoogleAIConnector);\n        ConnectorService.register(TConnectorService.LLM, 'AnthropicAI', AnthropicAIConnector);\n        ConnectorService.register(TConnectorService.LLM, 'Groq', GroqConnector);\n        ConnectorService.register(TConnectorService.LLM, 'TogetherAI', OpenAIConnector);\n        ConnectorService.register(TConnectorService.LLM, 'Bedrock', BedrockConnector);\n        ConnectorService.register(TConnectorService.LLM, 'VertexAI', VertexAIConnector);\n    }\n\n    public init() {\n        //auto initialize builting models\n        ConnectorService.init(TConnectorService.LLM, 'Echo');\n        ConnectorService.init(TConnectorService.LLM, 'OpenAI');\n        ConnectorService.init(TConnectorService.LLM, 'DeepSeek');\n        ConnectorService.init(TConnectorService.LLM, 'GoogleAI');\n        ConnectorService.init(TConnectorService.LLM, 'AnthropicAI');\n        ConnectorService.init(TConnectorService.LLM, 'Groq');\n        ConnectorService.init(TConnectorService.LLM, 'TogetherAI');\n        ConnectorService.init(TConnectorService.LLM, 'Bedrock');\n        ConnectorService.init(TConnectorService.LLM, 'VertexAI');\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IACL, IAccessCandidate, IAccessRequest } from '@sre/types/ACL.types';\nimport { CacheMetadata } from '@sre/types/Cache.types';\n\nexport interface ICacheRequest {\n    get: (key: string) => Promise<any>;\n\n    /**\n     * Set a value in the cache\n     * @param key\n     * @param data\n     * @param acl\n     * @param metadata\n     * @param ttl Cache time to live in seconds\n     * @returns\n     */\n    set: (key: string, data: any, acl?: IACL, metadata?: CacheMetadata, ttl?: number) => Promise<boolean>;\n    delete: (key: string) => Promise<void>;\n    exists: (key: string) => Promise<boolean>;\n\n    getMetadata: (key: string) => Promise<CacheMetadata | undefined>;\n    setMetadata: (key: string, metadata: CacheMetadata) => Promise<void>;\n\n    updateTTL: (key: string, ttl?: number) => Promise<void>;\n    getTTL: (key: string) => Promise<number>;\n\n    getACL: (key: string) => Promise<IACL | undefined>;\n    setACL: (key: string, acl: IACL) => Promise<void>;\n}\n\nexport abstract class CacheConnector extends SecureConnector {\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n    public user(candidate: AccessCandidate): ICacheRequest {\n        return {\n            get: async (key: string) => {\n                return await this.get(candidate.readRequest, key);\n            },\n            set: async (key: string, data: any, acl?: IACL, metadata?: CacheMetadata, ttl?: number) => {\n                return await this.set(candidate.writeRequest, key, data, acl, metadata, ttl);\n            },\n            delete: async (key: string) => {\n                await this.delete(candidate.writeRequest, key);\n            },\n            exists: async (key: string) => {\n                return await this.exists(candidate.readRequest, key);\n            },\n\n            getMetadata: async (key: string) => {\n                return await this.getMetadata(candidate.readRequest, key);\n            },\n            setMetadata: async (key: string, metadata: CacheMetadata) => {\n                await this.setMetadata(candidate.writeRequest, key, metadata);\n            },\n            updateTTL: async (key: string, ttl?: number) => {\n                await this.updateTTL(candidate.writeRequest, key, ttl);\n            },\n            getTTL: async (key: string) => {\n                return await this.getTTL(candidate.readRequest, key);\n            },\n            getACL: async (key: string) => {\n                return await this.getACL(candidate.readRequest, key);\n            },\n            setACL: async (key: string, acl: IACL) => {\n                await this.setACL(candidate.writeRequest, key, acl);\n            },\n        };\n    }\n\n    abstract get(acRequest: AccessRequest, key: string): Promise<any>;\n    abstract set(acRequest: AccessRequest, key: string, data: any, acl?: IACL, metadata?: CacheMetadata, ttl?: number): Promise<boolean>;\n    abstract delete(acRequest: AccessRequest, key: string): Promise<void>;\n    abstract exists(acRequest: AccessRequest, key: string): Promise<boolean>;\n\n    abstract getMetadata(acRequest: AccessRequest, key: string): Promise<CacheMetadata | undefined>;\n    abstract setMetadata(acRequest: AccessRequest, key: string, metadata: CacheMetadata): Promise<void>;\n\n    abstract updateTTL(acRequest: AccessRequest, key: string, ttl?: number): Promise<void>;\n    abstract getTTL(acRequest: AccessRequest, key: string): Promise<number>;\n\n    abstract getACL(acRequest: AccessRequest, key: string): Promise<IACL | undefined>;\n    abstract setACL(acRequest: AccessRequest, key: string, acl: IACL): Promise<void>;\n}\n","import { Logger } from '@sre/helpers/Log.helper';\nimport { IAccessCandidate, IACL, TAccessLevel } from '@sre/types/ACL.types';\nimport { CacheMetadata } from '@sre/types/Cache.types';\nimport IORedis from 'ioredis';\nimport { CacheConnector } from '../CacheConnector';\n\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { RedisConfig } from '@sre/types/Redis.types';\n\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\n\nconst console = Logger('RedisCache');\n\nexport class RedisCache extends CacheConnector {\n    public name: string = 'RedisCache';\n    private redis: IORedis;\n    private _prefix: string = 'smyth:cache';\n    private _mdPrefix: string = 'smyth:metadata';\n\n    constructor(settings: RedisConfig) {\n        super();\n        const sentinels = parseSentinelHosts(settings.hosts);\n\n        this.redis = new IORedis({\n            sentinels,\n            name: settings.name,\n            password: settings.password,\n        });\n\n        this.redis.on('error', (error) => {\n            console.error('Redis Error:', error);\n        });\n\n        this.redis.on('connect', () => {\n            console.log('Redis connected!');\n        });\n    }\n\n    public get client() {\n        return this.redis;\n    }\n\n    public get prefix() {\n        return this._prefix;\n    }\n\n    public get mdPrefix() {\n        return this._mdPrefix;\n    }\n\n    @SecureConnector.AccessControl\n    public async get(acRequest: AccessRequest, key: string): Promise<string | null> {\n        const value = await this.redis.get(`${this._prefix}:${key}`);\n        return value;\n    }\n\n    @SecureConnector.AccessControl\n    public async set(acRequest: AccessRequest, key: string, data: any, acl?: IACL, metadata?: CacheMetadata, ttl?: number): Promise<boolean> {\n        const accessCandidate = acRequest.candidate;\n        const promises: any[] = [];\n\n        promises.push(this.redis.set(`${this._prefix}:${key}`, data));\n\n        const newMetadata: CacheMetadata = metadata || {};\n        newMetadata.acl = ACL.from(acl).addAccess(accessCandidate.role, accessCandidate.id, TAccessLevel.Owner).ACL;\n        promises.push(this.setMetadata(acRequest, key, newMetadata));\n\n        if (ttl) {\n            promises.push(this.updateTTL(acRequest, key, ttl));\n        }\n\n        await Promise.all(promises);\n        return true;\n    }\n\n    @SecureConnector.AccessControl\n    public async delete(acRequest: AccessRequest, key: string): Promise<void> {\n        //delete both the key and its metadata\n        await Promise.all([this.redis.del(`${this._prefix}:${key}`), this.redis.del(`${this._mdPrefix}:${key}`)]);\n    }\n\n    @SecureConnector.AccessControl\n    public async exists(acRequest: AccessRequest, key: string): Promise<boolean> {\n        return !!(await this.redis.exists(`${this._prefix}:${key}`));\n    }\n\n    @SecureConnector.AccessControl\n    public async getMetadata(acRequest: AccessRequest, key: string): Promise<CacheMetadata> {\n        if (!this.exists(acRequest, key)) return undefined;\n        try {\n            const metadata = await this.redis.get(`${this._mdPrefix}:${key}`);\n            return metadata ? (this.deserializeRedisMetadata(metadata) as CacheMetadata) : {};\n        } catch (error) {\n            return {};\n        }\n    }\n\n    @SecureConnector.AccessControl\n    public async setMetadata(acRequest: AccessRequest, key: string, metadata: CacheMetadata): Promise<void> {\n        await this.redis.set(`${this._mdPrefix}:${key}`, this.serializeRedisMetadata(metadata));\n    }\n\n    @SecureConnector.AccessControl\n    public async updateTTL(acRequest: AccessRequest, key: string, ttl?: number): Promise<void> {\n        if (ttl) {\n            await Promise.all([this.redis.expire(`${this._prefix}:${key}`, ttl), this.redis.expire(`${this._mdPrefix}:${key}`, ttl)]);\n        }\n    }\n\n    @SecureConnector.AccessControl\n    public async getTTL(acRequest: AccessRequest, key: string): Promise<number> {\n        return this.redis.ttl(`${this._prefix}:${key}`);\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL> {\n        const _metadata: any = await this.redis.get(`${this._mdPrefix}:${resourceId}`).catch((error) => {});\n        const exists = _metadata !== undefined && _metadata !== null; //null or undefined metadata means the resource does not exist\n        const metadata = exists ? this.deserializeRedisMetadata(_metadata) : {};\n\n        if (!exists) {\n            //the resource does not exist yet, we grant write access to the candidate in order to allow the resource creation\n            return new ACL().addAccess(candidate.role, candidate.id, TAccessLevel.Owner);\n        }\n        return ACL.from(metadata?.acl as IACL);\n    }\n\n    // async hasAccess(request: IAccessRequest): Promise<boolean> {\n    //     try {\n    //         const metadata = await this.getMetadata(request.resourceId);\n    //         const acl: IACL = metadata?.acl as IACL;\n    //         return ACL.from(acl).checkExactAccess(request);\n    //     } catch (error) {\n    //         if (error.name === 'NotFound') {\n    //             return false;\n    //         }\n    //         console.error(`Error checking access rights in S3`, error.name, error.message);\n    //         throw error;\n    //     }\n    // }\n\n    @SecureConnector.AccessControl\n    async getACL(acRequest: AccessRequest, key: string): Promise<IACL> {\n        try {\n            const metadata = await this.getMetadata(acRequest, key);\n            return (metadata?.acl as IACL) || {};\n        } catch (error) {\n            console.error(`Error getting access rights in S3`, error.name, error.message);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    async setACL(acRequest: AccessRequest, key: string, acl: IACL) {\n        try {\n            let metadata = await this.getMetadata(acRequest, key);\n            if (!metadata) metadata = {};\n            //when setting ACL make sure to not lose ownership\n            metadata.acl = ACL.from(acl).addAccess(acRequest.candidate.role, acRequest.candidate.id, TAccessLevel.Owner).ACL;\n            await this.setMetadata(acRequest, key, metadata);\n        } catch (error) {\n            console.error(`Error setting access rights in S3`, error);\n            throw error;\n        }\n    }\n\n    private serializeRedisMetadata(redisMetadata: Record<string, any> | undefined): string {\n        if (!redisMetadata) return '';\n        if (redisMetadata.acl) {\n            const acl: IACL = redisMetadata.acl;\n            if (acl) {\n                redisMetadata.acl = ACL.from(acl).serializedACL;\n            }\n        }\n\n        return JSON.stringify(redisMetadata);\n    }\n\n    private deserializeRedisMetadata(strMetadata: string): Record<string, any> {\n        try {\n            const redisMetadata = JSON.parse(strMetadata);\n            if (redisMetadata.acl) {\n                const acl: IACL = ACL.from(redisMetadata.acl).ACL;\n                redisMetadata.acl = acl;\n            }\n\n            return redisMetadata;\n        } catch (error) {\n            console.warn(`Error deserializing metadata`, strMetadata);\n            return {};\n        }\n    }\n\n    public async stop() {\n        super.stop();\n        await this.redis.quit();\n    }\n}\n\n/**\n * hosts can take any of the following formats:\n * 1. A string with comma-separated host:port pairs\n * 2. An array of strings with host:port pairs\n * 3. An array of objects with host and port properties\n * @param hosts\n */\nfunction parseSentinelHosts(hosts: string | string[] | any[]) {\n    //handle all possible formats of hosts\n    if (typeof hosts === 'string') {\n        return hosts.split(',').map((host) => {\n            const [hostName, port] = host.split(':');\n            return {\n                host: hostName,\n                port: Number(port),\n            };\n        });\n    } else if (Array.isArray(hosts)) {\n        return hosts.map((host) => {\n            if (typeof host === 'string') {\n                const [hostName, port] = host.split(':');\n                return {\n                    host: hostName,\n                    port: Number(port),\n                };\n            } else {\n                return host;\n            }\n        });\n    } else {\n        return [];\n    }\n}\n","//==[ SRE: Cache ]======================\nexport * from './CacheConnector';\nimport { ConnectorServiceProvider, ConnectorService } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { RedisCache } from './connectors/RedisCache.class';\n\nexport class CacheService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.Cache, 'Redis', RedisCache);\n    }\n}\n","import { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL } from '@sre/types/ACL.types';\n\nexport interface IVaultRequest {\n    get(keyId: string): Promise<string>;\n    exists(keyId: string): Promise<boolean>;\n}\n\nexport abstract class VaultConnector extends SecureConnector {\n    user(candidate: AccessCandidate): IVaultRequest {\n        return {\n            get: async (keyId: string) => this.get(candidate.readRequest, keyId),\n            exists: async (keyId: string) => this.exists(candidate.readRequest, keyId),\n        };\n    }\n\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n    protected abstract get(acRequest: AccessRequest, keyId: string): Promise<string>;\n    protected abstract exists(acRequest: AccessRequest, keyId: string): Promise<boolean>;\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { JSONFileVaultConfig } from '@sre/types/Security.types';\nimport { IVaultRequest, VaultConnector } from '../VaultConnector';\nimport crypto from 'crypto';\nimport fs from 'fs';\n\nconst console = Logger('JSONFileVault');\nexport class JSONFileVault extends VaultConnector {\n    public name: string = 'JSONFileVault';\n    private vaultData: any;\n    private index: any;\n\n    constructor(private config: JSONFileVaultConfig) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n\n        if (fs.existsSync(config.file)) {\n            try {\n                if (config.fileKey && fs.existsSync(config.fileKey)) {\n                    try {\n                        const privateKey = fs.readFileSync(config.fileKey, 'utf8');\n                        const encryptedVault = fs.readFileSync(config.file, 'utf8').toString();\n                        const decryptedBuffer = crypto.privateDecrypt({\n                            key: privateKey,\n                            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n                        }, Buffer.from(encryptedVault, 'base64'));\n                        this.vaultData = JSON.parse(decryptedBuffer.toString('utf8'));\n                    } catch (error) {\n                        throw new Error('Failed to decrypt vault');\n                    }\n                } else {\n                    this.vaultData = JSON.parse(fs.readFileSync(config.file).toString());\n                }\n            } catch (e) {\n                this.vaultData = {};\n            }\n\n            for (let teamId in this.vaultData) {\n                for (let resourceId in this.vaultData[teamId]) {\n                    if (!this.index) this.index = {};\n                    if (!this.index[resourceId]) this.index[resourceId] = {};\n                    const value = this.vaultData[teamId][resourceId];\n                    this.index[resourceId][teamId] = value;\n                }\n            }\n        }\n    }\n\n    @SecureConnector.AccessControl\n    protected async get(acRequest: AccessRequest, keyId: string) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n\n        return this.vaultData?.[teamId]?.[keyId];\n    }\n\n    @SecureConnector.AccessControl\n    protected async exists(acRequest: AccessRequest, keyId: string) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n        return !!this.vaultData?.[teamId]?.[keyId];\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(candidate);\n\n        const acl = new ACL();\n\n        if (typeof this.vaultData?.[teamId]?.[resourceId] !== 'string') return acl;\n\n        acl.addAccess(TAccessRole.Team, teamId, TAccessLevel.Owner)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Read)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Write);\n\n        return acl;\n    }\n}\n","import axios from 'axios';\nimport qs from 'qs';\n\nexport async function getM2MToken(configs: {\n    oauthAppId: string;\n    oauthAppSecret: string;\n    resource: string;\n    scope: string;\n    baseUrl: string;\n}): Promise<string> {\n    return new Promise((resolve, reject) => {\n\n        const base64Credentials = Buffer.from(\n            `${configs.oauthAppId}:${configs.oauthAppSecret}`,\n            'utf8',\n        ).toString('base64');\n\n        const body = {\n            grant_type: 'client_credentials',\n            resource: configs.resource,\n            scope: configs.scope || '',\n        };\n        axios({\n            method: 'post',\n            // url: `${config.env.LOGTO_SERVER}/oidc/token`,\n            url: configs.baseUrl,\n            headers: {\n                Authorization: 'Basic ' + base64Credentials,\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: qs.stringify(body),\n        })\n            .then((response) => {\n                resolve(response.data.access_token);\n            })\n            .catch((error) => {\n                reject({ error: error.response.data });\n            });\n    });\n}","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { OAuthConfig, SmythVaultConfig } from '@sre/types/Security.types';\nimport { IVaultRequest, VaultConnector } from '../VaultConnector';\nimport { getM2MToken } from '@sre/utils/oauth.utils';\nimport axios, { AxiosInstance } from 'axios';\n\nconst console = Logger('SmythVault');\nexport class SmythVault extends VaultConnector {\n    public name: string = 'SmythVault';\n    private oAuthAppId: string;\n    private oAuthAppSecret: string;\n    private oAuthBaseUrl: string;\n    private oAuthResource?: string;\n    private oAuthScope?: string;\n    private vaultAPI: AxiosInstance;\n\n    constructor(private config: SmythVaultConfig & OAuthConfig) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n\n        this.oAuthAppId = config.oAuthAppID;\n        this.oAuthAppSecret = config.oAuthAppSecret;\n        this.oAuthBaseUrl = config.oAuthBaseUrl;\n        this.oAuthResource = config.oAuthResource || '';\n        this.oAuthScope = config.oAuthScope || '';\n        this.vaultAPI = axios.create({\n            baseURL: `${config.vaultAPIBaseUrl}/v1/api`,\n        });\n    }\n\n    @SecureConnector.AccessControl\n    protected async get(acRequest: AccessRequest, keyId: string) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n        const vaultAPIHeaders = await this.getVaultRequestHeaders();\n        const vaultResponse = await this.vaultAPI.get(`/vault/${teamId}/secrets/${keyId}`, { headers: vaultAPIHeaders });\n        let key = vaultResponse?.data?.secret?.value || null;\n\n        if (!key) {\n            const vaultResponse = await this.vaultAPI.get(`/vault/${teamId}/secrets/name/${keyId}`, { headers: vaultAPIHeaders });\n\n            key = vaultResponse?.data?.secret?.value || null;\n        }\n\n        if (!key) {\n            // * Note: Adjustment for legacy global vault keys, we can remove it after migrating all keys in Hashicorp Vault with proper key ID such as 'googleai' -> 'GoogleAI'\n            const legacyGlobalVaultKey = keyId.toLowerCase();\n            const globalVaultKey = legacyGlobalVaultKey === 'anthropicai' ? 'claude' : legacyGlobalVaultKey; // Ensure backward compatibility: In SaaS the key was stored under 'claude';\n            const vaultResponse = await this.vaultAPI.get(`/vault/${teamId}/secrets/${globalVaultKey}`, { headers: vaultAPIHeaders });\n\n            return vaultResponse?.data?.secret?.value;\n        }\n\n        return key || null;\n    }\n\n    @SecureConnector.AccessControl\n    protected async exists(acRequest: AccessRequest, keyId: string) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n        const vaultAPIHeaders = await this.getVaultRequestHeaders();\n        const vaultResponse = await this.vaultAPI.get(`/vault/${teamId}/secrets/${keyId}`, { headers: vaultAPIHeaders });\n        return vaultResponse?.data?.secret ? true : false;\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(candidate);\n\n        const acl = new ACL();\n\n        acl.addAccess(TAccessRole.Team, teamId, TAccessLevel.Owner)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Read)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Write);\n\n        return acl;\n    }\n\n    private async getVaultRequestHeaders() {\n        return {\n            Authorization: `Bearer ${await getM2MToken({\n                baseUrl: this.oAuthBaseUrl,\n                oauthAppId: this.oAuthAppId,\n                oauthAppSecret: this.oAuthAppSecret,\n                resource: this.oAuthResource,\n                scope: this.oAuthScope,\n            })}`,\n        };\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { SecretsManagerConfig } from '@sre/types/Security.types';\nimport { IVaultRequest, VaultConnector } from '../VaultConnector';\nimport { SecretsManagerClient, GetSecretValueCommand, PutSecretValueCommand } from '@aws-sdk/client-secrets-manager';\n\nconst console = Logger('SecretsManager');\nexport class SecretsManager extends VaultConnector {\n    public name: string = 'SecretsManager';\n    private secretsManager: SecretsManagerClient;\n\n    constructor(private config: SecretsManagerConfig) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n\n        this.secretsManager = new SecretsManagerClient({\n            region: config.region,\n            ...(config.awsAccessKeyId && config.awsSecretAccessKey\n                ? {\n                      accessKeyId: config.awsAccessKeyId,\n                      secretAccessKey: config.awsSecretAccessKey,\n                  }\n                : {}),\n        });\n    }\n\n    @SecureConnector.AccessControl\n    protected async get(acRequest: AccessRequest, secretId: string) {\n        try {\n            const accountConnector = ConnectorService.getAccountConnector();\n            const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n            const secret = await this.secretsManager.send(new GetSecretValueCommand({ SecretId: `${teamId}/${secretId}` }));\n            return secret.SecretString;\n        } catch (error) {\n            console.error(error);\n            throw error;\n        }\n    }\n\n    @SecureConnector.AccessControl\n    protected async exists(acRequest: AccessRequest, keyId: string) {\n        const secret = await this.get(acRequest, keyId);\n        return !!secret;\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(candidate);\n\n        const acl = new ACL();\n\n        acl.addAccess(TAccessRole.Team, teamId, TAccessLevel.Owner)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Read)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Write);\n\n        return acl;\n    }\n}\n","import { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { JSONFileVault } from './connectors/JSONFileVault.class';\nimport { SmythVault } from './connectors/SmythVault.class';\nimport { SecretsManager } from './connectors/SecretsManager.class';\n\nexport class VaultService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.Vault, 'JSONFileVault', JSONFileVault);\n        ConnectorService.register(TConnectorService.Vault, 'SmythVault', SmythVault);\n        ConnectorService.register(TConnectorService.Vault, 'SecretsManager', SecretsManager);\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { IAccessCandidate } from '@sre/types/ACL.types';\nimport { AccessCandidate } from '../AccessControl/AccessCandidate.class';\nimport { KeyValueObject } from '@sre/types/Common.types';\nimport { ACL } from '../AccessControl/ACL.class';\n\nexport interface ISmythAccountRequest {\n    isTeamMember(teamId: string): Promise<boolean>;\n    getCandidateTeam(): Promise<string | undefined>;\n    getAllTeamSettings(): Promise<KeyValueObject>;\n    getAllUserSettings(): Promise<KeyValueObject>;\n    getTeamSetting(settingKey: string): Promise<string>;\n    getUserSetting(settingKey: string): Promise<string>;\n}\n\nexport abstract class AccountConnector extends Connector {\n    public user(candidate: AccessCandidate): ISmythAccountRequest {\n        return {\n            getAllUserSettings: async () => this.getAllUserSettings(candidate.readRequest, candidate.id),\n            getUserSetting: async (settingKey: string) => this.getUserSetting(candidate.readRequest, candidate.id, settingKey),\n            getAllTeamSettings: async () => this.getAllTeamSettings(candidate.readRequest, candidate.id),\n            getTeamSetting: async (settingKey: string) => this.getTeamSetting(candidate.readRequest, candidate.id, settingKey),\n            isTeamMember: async (teamId: string) => this.isTeamMember(teamId, candidate),\n            getCandidateTeam: async () => this.getCandidateTeam(candidate),\n        };\n    }\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n\n    public abstract isTeamMember(teamId: string, candidate: IAccessCandidate): Promise<boolean>;\n    public abstract getCandidateTeam(candidate: IAccessCandidate): Promise<string | undefined>;\n    public abstract getAllTeamSettings(acRequest: AccessRequest, teamId: string): Promise<KeyValueObject>;\n    public abstract getAllUserSettings(acRequest: AccessRequest, accountId: string): Promise<KeyValueObject>;\n    public abstract getTeamSetting(acRequest: AccessRequest, teamId: string, settingKey: string): Promise<string>;\n    public abstract getUserSetting(acRequest: AccessRequest, accountId: string, settingKey: string): Promise<string>;\n}\n","import { Logger } from '@sre/helpers/Log.helper';\nimport { ISmythAccountRequest, AccountConnector } from '../AccountConnector';\nimport { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { OAuthConfig, SmythConfigs } from '@sre/types/Security.types';\nimport axios, { AxiosInstance } from 'axios';\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { getM2MToken } from '@sre/utils/oauth.utils';\nimport { KeyValueObject } from '@sre/types/Common.types';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\n\nconst console = Logger('SmythAccount');\nexport class SmythAccount extends AccountConnector {\n    public name: string = 'SmythAccount';\n    private oAuthAppId: string;\n    private oAuthAppSecret: string;\n    private oAuthBaseUrl: string;\n    private oAuthResource?: string;\n    private oAuthScope?: string;\n    private smythAPI: AxiosInstance;\n\n    constructor(private config: SmythConfigs & OAuthConfig) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n\n        this.oAuthAppId = config.oAuthAppID;\n        this.oAuthAppSecret = config.oAuthAppSecret;\n        this.oAuthBaseUrl = config.oAuthBaseUrl;\n        this.oAuthResource = config.oAuthResource || '';\n        this.oAuthScope = config.oAuthScope || '';\n        this.smythAPI = axios.create({\n            baseURL: `${config.smythAPIBaseUrl}`,\n        });\n    }\n\n    public async isTeamMember(teamId: string, candidate: IAccessCandidate): Promise<boolean> {\n        try {\n            const candidateTeamId = await this.getCandidateTeam(candidate);\n            if (teamId === candidateTeamId) {\n                return true;\n            }\n            return false;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    public async getCandidateTeam(candidate: IAccessCandidate): Promise<string | undefined> {\n        if (candidate.role === TAccessRole.Team) {\n            return candidate.id;\n        }\n        if (candidate.role === TAccessRole.User) {\n            const response = await this.smythAPI.get(`/v1/user/${candidate.id}`, { headers: await this.getSmythRequestHeaders() });\n            return response?.data?.user?.teamId;\n        }\n        if (candidate.role === TAccessRole.Agent) {\n            const response = await this.smythAPI.get(`/v1/ai-agent/${candidate.id}`, { headers: await this.getSmythRequestHeaders() });\n            return response?.data?.agent?.teamId;\n        }\n        return null;\n    }\n\n    public async getAllTeamSettings(acRequest: AccessRequest, teamId: string): Promise<KeyValueObject | null> {\n        try {\n            const response = await this.smythAPI.get(`/v1/teams/${teamId}/settings`, { headers: await this.getSmythRequestHeaders() });\n\n            if (response?.data?.settings?.length > 0) {\n                const settingsObject: KeyValueObject = {};\n                response?.data?.settings?.forEach((setting: KeyValueObject) => {\n                    settingsObject[setting?.settingKey] = setting?.settingValue;\n                });\n                return settingsObject;\n            }\n            return null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    public async getAllUserSettings(acRequest: AccessRequest, accountId: string): Promise<KeyValueObject | null> {\n        try {\n            const response = await this.smythAPI.get(`/v1/user/${accountId}/settings`, { headers: await this.getSmythRequestHeaders() });\n\n            if (response?.data?.settings?.length > 0) {\n                const settingsObject: KeyValueObject = {};\n                response?.data?.settings?.forEach((setting: KeyValueObject) => {\n                    settingsObject[setting?.settingKey] = setting?.settingValue;\n                });\n                return settingsObject;\n            }\n            return null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    public async getTeamSetting(acRequest: AccessRequest, teamId: string, settingKey: string): Promise<string> {\n        try {\n            const response = await this.smythAPI.get(`/v1/teams/${teamId}/settings/${settingKey}`, { headers: await this.getSmythRequestHeaders() });\n            return response?.data?.setting?.settingValue || null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    public async getUserSetting(acRequest: AccessRequest, accountId: string, settingKey: string): Promise<string> {\n        try {\n            const response = await this.smythAPI.get(`/v1/user/${accountId}/settings/${settingKey}`, {\n                headers: await this.getSmythRequestHeaders(),\n            });\n            return response?.data?.setting?.settingValue || null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate) {\n        const accountConnector = ConnectorService.getAccountConnector('SmythAccount');\n        const teamId = await accountConnector.getCandidateTeam(candidate);\n\n        const acl = new ACL();\n\n        acl.addAccess(TAccessRole.Team, teamId, TAccessLevel.Owner)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Read)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Write);\n\n        return acl;\n    }\n\n    private async getSmythRequestHeaders() {\n        return {\n            Authorization: `Bearer ${await getM2MToken({\n                baseUrl: this.oAuthBaseUrl,\n                oauthAppId: this.oAuthAppId,\n                oauthAppSecret: this.oAuthAppSecret,\n                resource: this.oAuthResource,\n                scope: this.oAuthScope,\n            })}`,\n        };\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL, TAccessRole } from '@sre/types/ACL.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\nimport { AccountConnector } from '../AccountConnector';\nimport { KeyValueObject } from '@sre/types/Common.types';\n\nexport class DummyAccount extends AccountConnector {\n    public name = 'DummyAccount';\n    public isTeamMember(team: string, candidate: IAccessCandidate): Promise<boolean> {\n        return Promise.resolve(true);\n    }\n    public getCandidateTeam(candidate: IAccessCandidate): Promise<string | undefined> {\n        if (candidate.role === TAccessRole.Team) {\n            return Promise.resolve(candidate.id);\n        }\n\n        return Promise.resolve('default');\n    }\n\n    public getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL> {\n        throw new Error('getResourceACL Method not implemented.');\n    }\n    public getAllTeamSettings(acRequest: AccessRequest, teamId: string): Promise<KeyValueObject[]> {\n        throw new Error('getAllTeamSettings Method not implemented.');\n    }\n    public getAllUserSettings(acRequest: AccessRequest, accountId: string): Promise<KeyValueObject[]> {\n        throw new Error('getAllUserSettings Method not implemented.');\n    }\n    public getTeamSetting(acRequest: AccessRequest, teamId: string, settingKey: string): Promise<string> {\n        throw new Error('getTeamSetting Method not implemented.');\n    }\n    public getUserSetting(acRequest: AccessRequest, accountId: string, settingKey: string): Promise<string> {\n        throw new Error('getUserSetting Method not implemented.');\n    }\n}\n","import mysql from 'mysql2/promise';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { IAccessCandidate, IACL, TAccessRole } from '@sre/types/ACL.types';\nimport { AccountConnector } from '../AccountConnector';\nimport { KeyValueObject } from '@sre/types/Common.types';\n\n\nexport class AWSAccount extends AccountConnector {\n    public name = 'AWSAccount';\n\n    private pool: mysql.Pool;\n\n    constructor(private config: any) {\n        super();\n\n        this.pool = mysql.createPool({\n            host: config.host,\n            database: config.database || 'app',\n            user: config.user || 'app',\n            password: config.password,\n            connectionLimit: 10\n        });\n    }\n\n    public isTeamMember(team: string, candidate: IAccessCandidate): Promise<boolean> {\n        return Promise.resolve(true);\n    }\n\n    public getCandidateTeam(candidate: IAccessCandidate): Promise<string | undefined> {\n        if (candidate.role === TAccessRole.Team) {\n            return Promise.resolve(candidate.id);\n        }\n\n        return Promise.resolve('default');\n    }\n\n\n    public async getAllTeamSettings(acRequest: AccessRequest, teamId: string): Promise<KeyValueObject[]> {\n        try {\n            const [rows] = await this.pool.execute(\"SELECT `key`, `value` FROM TeamSettings\");\n            const settings: KeyValueObject[] = [];\n            if (Array.isArray(rows) && rows.length > 0) {\n                settings.push(...rows.map((row) => ({ key: row.key, value: row.value })));\n            }\n            return settings;\n        } catch (error) {\n            console.error('Error in getTeamSetting:', error);\n            return [] as KeyValueObject[];\n        }\n    }\n\n    public async getTeamSetting(acRequest: AccessRequest, teamId: string, settingKey: string): Promise<string> {\n        try {\n            const [rows] = await this.pool.execute(\"SELECT `value` FROM TeamSettings WHERE settingKey = ? LIMIT 1\", [settingKey]);\n            if (Array.isArray(rows) && rows.length > 0 && 'value' in rows[0]) return rows[0].value;\n            return '';\n        } catch (error) {\n            console.error('Error in getTeamSetting:', error);\n            return '';\n        }\n    }\n\n    // TODO: Implement this\n    public getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL> {\n        throw new Error('getResourceACL Method not implemented.');\n    }\n    public getAllUserSettings(acRequest: AccessRequest, accountId: string): Promise<KeyValueObject[]> {\n        throw new Error('getAllUserSettings Method not implemented.');\n    }\n    public getUserSetting(acRequest: AccessRequest, accountId: string, settingKey: string): Promise<string> {\n        throw new Error('getUserSetting Method not implemented.');\n    }\n}\n","//==[ SRE: LLM ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { SmythAccount } from './connectors/SmythAccount.class';\nimport { DummyAccount } from './connectors/DummyAccount.class';\nimport { AWSAccount } from './connectors/AWSAccount.class';\n\nexport class AccountService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.Account, 'SmythAccount', SmythAccount);\n        ConnectorService.register(TConnectorService.Account, 'AWSAccount', AWSAccount);\n        ConnectorService.register(TConnectorService.Account, 'DummyAccount', DummyAccount);\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { IAccessCandidate } from '@sre/types/ACL.types';\nimport config from '@sre/config';\nimport { escapeString, TemplateString } from '@sre/helpers/TemplateString.helper';\n\nexport interface IAgentDataConnector {\n    getAgentData(agentId: string, version?: string): Promise<any>;\n    getAgentIdByDomain(domain: string): Promise<string>;\n    getAgentSettings(agentId: string, version?: string): Promise<any>;\n}\n\nconst openapiTemplate = JSON.stringify({\n    openapi: '3.0.1',\n    info: {\n        title: '{{model_name}}',\n        description: '{{model_description}}',\n        version: '{{version}}',\n    },\n    servers: [\n        {\n            url: '{{server_url}}',\n        },\n    ],\n    paths: {},\n    components: {\n        schemas: {},\n    },\n});\n\nconst openapiEndpointTemplate = JSON.stringify({\n    summary: '{{summary}}',\n    operationId: '{{operationId}}',\n    'x-openai-isConsequential': false,\n    requestBody: {\n        required: true,\n        content: {},\n    },\n    responses: {\n        '200': {\n            description: 'response',\n            content: {\n                'text/plain': {\n                    schema: {\n                        type: 'string',\n                    },\n                },\n            },\n        },\n    },\n});\nexport abstract class AgentDataConnector extends Connector implements IAgentDataConnector {\n    public name = 'AgentDataConnector';\n    public abstract getAgentData(agentId: string, version?: string): Promise<any>;\n    public abstract getAgentIdByDomain(domain: string): Promise<string>;\n    public abstract getAgentSettings(agentId: string, version?: string): Promise<{ [key: string]: any }>;\n    public abstract isDeployed(agentId: string): Promise<boolean>;\n\n    /**\n     * Loads openAPI JSON for the agent\n     * @param source this represents either the agentId or the agent data\n     * @param domain\n     * @param version\n     * @param aiOnly\n     * @returns\n     */\n    public async getOpenAPIJSON(source: string | Record<string, any>, server_url, version, aiOnly: boolean = false) {\n        if (!source) {\n            throw new Error('Agent not found');\n        }\n\n        const apiBasePath = version && version != 'latest' ? `/v${version}/api` : '/api';\n\n        const agentData: any = typeof source === 'object' ? source : await this.getAgentData(source, version);\n        const name = agentData.name;\n\n        let description = aiOnly ? agentData.data.behavior : agentData.data.shortDescription;\n        if (!description) description = agentData.data.description; //data.description is deprecated, we just use it as a fallback for now\n\n        const _version = agentData.data.version || '1.0.0';\n        //replace all non printable characters with spaces\n        //description = description.replace(/[^\\x20-\\x7E]+/g, ' ');\n        //const version = '1.0.0';\n\n        // const server_url_scheme =\n        //     config.env.NODE_ENV === 'DEV' && config.env.AGENT_DOMAIN_PORT && domain.includes(config.env.AGENT_DOMAIN) ? 'http' : 'https';\n        // const server_url_port =\n        //     config.env.NODE_ENV === 'DEV' && config.env.AGENT_DOMAIN_PORT && domain.includes(config.env.AGENT_DOMAIN)\n        //         ? `:${config.env.AGENT_DOMAIN_PORT}`\n        //         : '';\n        // const server_url = `${server_url_scheme}://${domain}${server_url_port}`;\n\n        const openAPITpl = TemplateString(openapiTemplate)\n            .parse({\n                model_name: escapeString(name),\n                model_description: escapeString(description),\n                server_url,\n                version: _version,\n            })\n            .clean().result;\n        const openAPIObj = JSON.parse(openAPITpl);\n\n        const components = agentData.data.components.filter((component: any) => component.name === 'APIEndpoint');\n        for (let component of components) {\n            const ai_exposed = component.data.ai_exposed || typeof component.data.ai_exposed === 'undefined';\n            if (aiOnly && !ai_exposed) continue;\n            let method = (component.data.method || 'post').toLowerCase();\n            let summary = aiOnly ? component.data.description || component.data.doc : component.data.doc || component.data.description;\n\n            const openAPIEntry = JSON.parse(\n                TemplateString(openapiEndpointTemplate)\n                    .parse({\n                        summary,\n                        operationId: component.data.endpoint,\n                    })\n                    .clean().result\n            );\n            if (!openAPIObj.paths[apiBasePath + '/' + component.data.endpoint]) openAPIObj.paths[apiBasePath + '/' + component.data.endpoint] = {};\n            //const componentsSchemas = openAPIObj.components.schemas;\n\n            openAPIObj.paths[apiBasePath + '/' + component.data.endpoint][method] = openAPIEntry;\n\n            if (component.inputs.length > 0) {\n                if (method === 'get') {\n                    delete openAPIEntry.requestBody;\n\n                    openAPIEntry.parameters = [];\n\n                    for (let input of component.inputs) {\n                        const parameter: {\n                            name: string;\n                            in: string;\n                            description: string;\n                            required: boolean;\n                            schema: { type: string };\n                            style?: string;\n                            explode?: boolean;\n                        } = {\n                            name: input.name,\n                            in: 'query',\n                            description: input.description,\n                            required: !input.optional,\n                            schema: getOpenAPIInputSchema(input.type),\n                        };\n\n                        // for array and object types\n                        const { style, explode } = getOpenAPIParameterStyle(input.type);\n                        if (style) {\n                            parameter.style = style;\n                            parameter.explode = explode;\n                        }\n\n                        openAPIEntry.parameters.push(parameter);\n                    }\n                } else {\n                    const requiredProps: any = [];\n\n                    const hasBinaryType = !aiOnly && component.inputs.some((input) => input.type.toLowerCase().trim() === 'binary');\n                    //if it's an AI format, we force application/json format, becauwe we want to receive binary data as a url\n                    const mimetype = hasBinaryType ? 'multipart/form-data' : 'application/json';\n                    openAPIEntry.requestBody.content[mimetype] = {};\n                    for (let input of component.inputs) {\n                        if (!input.optional) requiredProps.push(input.name);\n\n                        if (!openAPIEntry.requestBody.content[mimetype].schema)\n                            openAPIEntry.requestBody.content[mimetype].schema = { type: 'object' };\n\n                        const schema: any = openAPIEntry.requestBody.content[mimetype].schema || {\n                            type: 'object',\n                        };\n\n                        if (!schema.properties) schema.properties = {};\n                        schema.properties[input.name] = {\n                            ...getOpenAPIInputSchema(input.type),\n                            format: !aiOnly && input.type.toLowerCase().trim() === 'binary' ? 'binary' : undefined,\n                            description: input.description,\n                            default: input.defaultVal,\n                        };\n                        schema.required = requiredProps;\n\n                        if (!openAPIEntry.requestBody.content[mimetype].schema) openAPIEntry.requestBody.content['application/json'].schema = schema;\n                    }\n                }\n            } else {\n                delete openAPIEntry.requestBody;\n            }\n        }\n\n        return openAPIObj;\n    }\n}\n\nfunction getOpenAPIInputSchema(input_type) {\n    switch (input_type?.toLowerCase()) {\n        case 'binary':\n        case 'string':\n        case 'any':\n            return { type: 'string' };\n        case 'number':\n        case 'float':\n            return { type: 'number' };\n        case 'integer':\n            return { type: 'integer' };\n        case 'boolean':\n            return { type: 'boolean' };\n        case 'array':\n            return { type: 'array', items: {} };\n        case 'object':\n            return { type: 'object', additionalProperties: {} };\n        default:\n            return { type: 'string' };\n    }\n}\n\nfunction getOpenAPIParameterStyle(input_type) {\n    switch (input_type.toLowerCase()) {\n        case 'array':\n            return {\n                style: 'form',\n                explode: false, // results in `ids=1,2,3`\n            };\n        case 'object':\n            return {\n                style: 'deepObject',\n                explode: true, // results in `lat=value1&long=value2`\n            };\n        default:\n            return { style: '', explode: false };\n    }\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { CLIConnector } from '@sre/IO/CLI.service/CLIConnector';\nimport fs from 'fs';\nimport path from 'path';\nimport { AgentDataConnector } from '../AgentDataConnector';\n\ntype TArgs = { args: Record<string, any> };\nexport class CLIAgentDataConnector extends AgentDataConnector {\n    public name: string = 'CLIAgentDataConnector';\n    private argv;\n    constructor(settings: TArgs) {\n        super();\n        this.argv = settings.args || process.argv;\n    }\n    public async getAgentData(agentId: string, version?: string) {\n        const cliConnector: CLIConnector = ConnectorService.getCLIConnector();\n\n        const params: any = cliConnector.get('agent');\n\n        //get current directory\n        const __dirname = fs.realpathSync(process.cwd());\n        const filePath = path.join(__dirname, params.agent);\n\n        if (fs.existsSync(filePath)) {\n            const data = fs.readFileSync(filePath, 'utf8');\n\n            return { data: JSON.parse(data), version: version || '1.0' };\n        }\n    }\n\n    public getAgentIdByDomain(domain: string): Promise<string> {\n        return Promise.resolve('');\n    }\n    public async getAgentSettings(agentId: string, version?: string) {\n        const cliConnector: CLIConnector = ConnectorService.getCLIConnector();\n\n        const params: any = cliConnector.get('settings');\n        let settings: any;\n\n        if (typeof params.settings === 'string') {\n            if (fs.existsSync(params.settings)) {\n                settings = JSON.parse(fs.readFileSync(params.settings, 'utf8'));\n            }\n        } else {\n            settings = params.settings;\n        }\n        return settings;\n    }\n    public async isDeployed(agentId: string): Promise<boolean> {\n        return true;\n    }\n}\n","import fs from 'fs';\nimport path from 'path';\nimport { AgentDataConnector } from '../AgentDataConnector';\nimport { uid } from '@sre/utils/general.utils';\n\nexport type LocalAgentDataSettings = { devDir: string; prodDir: string };\n\n/**\n * This connector loads Agent data and settings from a provided directory, it then indexes the loaded agents and settings by agent IDs.\n * Agent data files should be in JSON format and contain an 'id' field with the agent ID and at least a 'components' field.\n * Settings files should be in JSON format and contain an 'id' field with the agent ID and the settings in a 'settings' field.\n *     'settings' field is a key-value object with the Agent settings.\n */\nexport class LocalAgentDataConnector extends AgentDataConnector {\n    public name: string = 'LocalAgentDataConnector';\n    private devDir;\n    private prodDir;\n    private agentsData = { dev: {}, prod: {} };\n    private agentSettings = { dev: {}, prod: {} };\n\n    constructor(settings: LocalAgentDataSettings) {\n        super();\n        this.devDir = settings.devDir;\n        this.prodDir = settings.prodDir;\n    }\n\n    private indexDir(dir: string) {\n        const agents = fs.readdirSync(dir);\n\n        const agentsData = {};\n        const agentSettings = {};\n        for (const agent of agents) {\n            const agentData = fs.readFileSync(path.join(dir, agent), 'utf8');\n            let jsonData;\n            try {\n                jsonData = JSON.parse(agentData);\n\n                if (!jsonData.id) {\n                    console.warn(`Agent data for ${agent} does not contain an id, generating one...`);\n                    jsonData.id = 'tmp-' + uid();\n                }\n            } catch (e) {\n                console.warn(`Error parsing agent data for ${agent}: ${e.message}`);\n            }\n\n            //is this an agent data file?\n            if (jsonData.components) agentsData[jsonData.id] = jsonData;\n\n            //does this file contain settings?\n            if (jsonData.settings) agentSettings[jsonData.id] = jsonData.settings;\n        }\n\n        return { agentsData, agentSettings };\n    }\n    private indexAgentsData() {\n        const { agentsData: devAgentsData, agentSettings: devAgentSettings } = this.indexDir(this.devDir);\n        const { agentsData: prodAgentsData, agentSettings: prodAgentSettings } = this.indexDir(this.prodDir);\n        this.agentsData = { dev: devAgentsData, prod: prodAgentsData };\n        this.agentSettings = { dev: devAgentSettings, prod: prodAgentSettings };\n    }\n\n    public async start() {\n        super.start();\n        this.started = false;\n        this.indexAgentsData();\n        this.started = true;\n    }\n\n    /**\n     * returns the agent data for the provided agent ID\n     * if the version is not provided, it defaults to the dev version\n     * otherwise it loads the corresponding prod version\n     * @param agentId\n     * @param version\n     * @returns\n     */\n    public async getAgentData(agentId: string, version?: string) {\n        const ready = await this.ready();\n        if (!ready) {\n            throw new Error('Connector not ready');\n        }\n\n        const data = version ? this.agentsData.prod[agentId] : this.agentsData.dev[agentId];\n\n        if (data) {\n            return { data, version: version || '1.0' };\n        } else {\n            throw new Error(`Agent with id ${agentId} not found`);\n        }\n    }\n\n    public getAgentIdByDomain(domain: string): Promise<string> {\n        return Promise.resolve('');\n    }\n\n    /**\n     * returns the agent settings for the provided agent ID\n     * if the version is not provided, it defaults to the dev version\n     * otherwise it loads the corresponding prod version\n     * @param agentId\n     * @param version\n     * @returns\n     */\n    public async getAgentSettings(agentId: string, version?: string) {\n        const ready = await this.ready();\n        if (!ready) {\n            throw new Error('Connector not ready');\n        }\n\n        const settings = version ? this.agentSettings.prod[agentId] : this.agentSettings.dev[agentId];\n\n        if (settings) {\n            return settings;\n        } else {\n            throw new Error(`Settings for agent with id ${agentId} not found`);\n        }\n    }\n\n    public async isDeployed(agentId: string): Promise<boolean> {\n        return !!this.agentsData.prod[agentId];\n    }\n}\n","import { AgentDataConnector } from '../AgentDataConnector';\nimport { OAuthConfig, SmythConfigs } from '@sre/types/Security.types';\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AxiosInstance } from 'axios';\nimport axios from 'axios';\nimport { getM2MToken } from '@sre/utils/oauth.utils';\n\nexport class SmythAgentDataConnector extends AgentDataConnector {\n    public name: string = 'SmythAgentData';\n    private oAuthAppId: string;\n    private oAuthAppSecret: string;\n    private oAuthBaseUrl: string;\n    private oAuthResource?: string;\n    private oAuthScope?: string;\n    private smythAPI: AxiosInstance;\n    private agentStageDomain: string;\n    private agentProdDomain: string;\n\n    constructor(private config: SmythConfigs & OAuthConfig & { agentStageDomain: string; agentProdDomain: string }) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n        this.oAuthAppId = config.oAuthAppID;\n        this.oAuthAppSecret = config.oAuthAppSecret;\n        this.oAuthBaseUrl = config.oAuthBaseUrl;\n        this.oAuthResource = config.oAuthResource || '';\n        this.oAuthScope = config.oAuthScope || '';\n        this.smythAPI = axios.create({\n            baseURL: `${config.smythAPIBaseUrl}`,\n        });\n        this.agentStageDomain = config.agentStageDomain;\n        this.agentProdDomain = config.agentProdDomain;\n    }\n\n    public async getAgentData(agentId: string, version?: string): Promise<any> {\n        try {\n            let agentObj;\n\n            //FIXME : once we have the agent name in deployment api response, we can skip this call\n            // const response = await mwSysAPI.get(`/ai-agent/${agentID}?include=team.subscription`, includeAuth(token));\n            const response = await this.smythAPI.get(`/v1/ai-agent/${agentId}?include=team.subscription`, {\n                headers: await this.getSmythRequestHeaders(),\n            });\n            agentObj = response.data.agent;\n            const authData = agentObj.data.auth; //use most up to date auth data\n\n            // const tasksResponse = await mwSysAPI.get(`/quota/team/${agentObj.teamId}/tasks/subscription`, includeAuth(token));\n            const tasksResponse = await this.smythAPI.get(`/v1/quota/team/${agentObj.teamId}/tasks/subscription`, {\n                headers: await this.getSmythRequestHeaders(),\n            });\n            agentObj.taskData = tasksResponse.data;\n\n            agentObj.data.debugSessionEnabled = agentObj?.data?.debugSessionEnabled && agentObj?.isLocked; //disable debug session if agent is not locked (locked agent means that it's open in the Agent builder)\n\n            if (version) {\n                // const deploymentsList = await mwSysAPI.get(`/ai-agent/${agentID}/deployments`, includeAuth(token));\n                const deploymentsList = await this.smythAPI.get(`/v1/ai-agent/${agentId}/deployments`, {\n                    headers: await this.getSmythRequestHeaders(),\n                });\n                const deployment =\n                    version == 'latest'\n                        ? deploymentsList?.data?.deployments[0]\n                        : deploymentsList?.data?.deployments?.find((deployment) => deployment.version === version);\n                if (deployment) {\n                    // const deployResponse = await mwSysAPI.get(`/ai-agent/deployments/${deployment.id}`, includeAuth(token));\n                    const deployResponse = await this.smythAPI.get(`/v1/ai-agent/deployments/${deployment.id}`, {\n                        headers: await this.getSmythRequestHeaders(),\n                    });\n                    agentObj.data = deployResponse?.data?.deployment?.aiAgentData;\n                    agentObj.data.debugSessionEnabled = false; //never enable debug session when using a deployed version\n                    agentObj.data.agentVersion = deployment.version;\n                    agentObj.version = deployment.version;\n                } else {\n                    //if (version !== 'latest') {\n                    throw new Error(`Requested Deploy Version not found: ${version}`);\n                    //} // if version == 'latest' but no deployment is found we just fallback to the agent live data\n                }\n            }\n\n            //TODO: Also include team and subscription info\n\n            //agentObj.data.auth = authData;\n            if (!agentObj?.data?.auth?.method || agentObj?.data?.auth?.method == 'none') agentObj.data.auth = authData;\n\n            agentObj.data = this.migrateAgentData(agentObj.data);\n\n            return agentObj;\n        } catch (error: any) {\n            console.error(error.response?.data, error.message);\n            console.log(`Error getting agent data for agentId=${agentId}: ${error?.message}`);\n            throw new Error(`Error getting agent data for agentId=${agentId}: ${error?.message}`);\n        }\n    }\n\n    public async getAgentIdByDomain(domain: string): Promise<string> {\n        let agentId;\n        //first check if this is the internal wildcard agents domain\n        const isStageWildcardDomain = domain.includes(this.agentStageDomain);\n        const isProdWildcardDomain = domain.includes(this.agentProdDomain);\n        if (isStageWildcardDomain || isProdWildcardDomain) {\n            //console.log('Internal agent domain detected', domain);\n            agentId = domain.split('.')[0];\n            //sanity check\n            if (`${agentId}.${this.agentStageDomain}` !== domain && `${agentId}.${this.agentProdDomain}` !== domain) {\n                throw new Error(`Invalid agent domain: ${domain}`);\n            }\n\n            //if this is a stage domain, no more check, return the agentId\n            if (isStageWildcardDomain) return agentId;\n        }\n\n        // const result: any = await mwSysAPI.get('/domains?verified=true', { headers: { Authorization } }).catch((error) => ({ error }));\n        const result: any = await this.smythAPI\n            .get(`/v1/domains?verified=true`, { headers: await this.getSmythRequestHeaders() })\n            .catch((error) => ({ error }));\n\n        if (result.error) {\n            throw new Error('Error getting domain info');\n        }\n\n        //we have an agentId from the wildcard domain, if this domain is already associated with\n        if (agentId) {\n            const hasDomain = result.data.domains.find((domainEntry: any) => domainEntry?.aiAgent?.id === agentId);\n            if (hasDomain) {\n                throw new Error('Wrong domain');\n            }\n        } else {\n            agentId = result.data.domains.find((domainEntry: any) => domainEntry.name === domain)?.aiAgent?.id;\n        }\n\n        //if a custom domain is found, use it, otherwise use the agentId from the wildcard domain\n\n        return agentId;\n    }\n\n    public async getAgentSettings(agentId: string, version?: string): Promise<any> {\n        try {\n            // If no matching deployment found or no deployments at all, return the current live settings\n            const response = await this.smythAPI.get(`/v1/ai-agent/${agentId}/settings`, {\n                headers: await this.getSmythRequestHeaders(),\n            });\n            const formattedSettings = response.data.settings.reduce((acc, setting) => ({ ...acc, [setting.key]: setting.value }), {});\n\n            return formattedSettings;\n        } catch (error) {\n            console.error(`Error getting agent settings for agentId=${agentId}: ${error?.message}`);\n            throw new Error(`Error getting agent settings for agentId=${agentId}: ${error?.message}`);\n        }\n    }\n\n    public async isDeployed(agentId: string): Promise<boolean> {\n        try {\n            const deploymentsList = await this.smythAPI.get(`/v1/ai-agent/${agentId}/deployments`, {\n                headers: await this.getSmythRequestHeaders(),\n            });\n            return deploymentsList?.data?.deployments?.length > 0;\n        } catch (error) {\n            console.error(error);\n            return false;\n        }\n    }\n\n    private async getSmythRequestHeaders() {\n        return {\n            Authorization: `Bearer ${await getM2MToken({\n                baseUrl: this.oAuthBaseUrl,\n                oauthAppId: this.oAuthAppId,\n                oauthAppSecret: this.oAuthAppSecret,\n                resource: this.oAuthResource,\n                scope: this.oAuthScope,\n            })}`,\n        };\n    }\n\n    private migrateAgentData(data) {\n        if (!data.version) {\n            console.log(`Agent [${data.name}] has an old schema. Migrating to latest version...`);\n            // version 0  ===> migrate from receptors/connectors to inputs/outputs\n            const newData = JSON.parse(JSON.stringify(data));\n            for (let component of newData.components) {\n                component.outputs = component.connectors;\n                component.inputs = component.receptors;\n                component.outputProps = component.connectorProps;\n                component.inputProps = component.receptorProps;\n                delete component.connectors;\n                delete component.receptors;\n                delete component.connectorProps;\n                delete component.receptorProps;\n            }\n            return newData;\n        }\n\n        if (data.version === '1.0.0') {\n            //migrate .description to .behavior\n            if (data.description && !data.behavior) {\n                data.behavior = data.description;\n                //delete newConfig.description;\n            }\n        }\n\n        return data;\n    }\n}\n","//==[ SRE: LLM ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { CLIAgentDataConnector } from './connectors/CLIAgentDataConnector.class';\nimport { AgentDataConnector } from './AgentDataConnector';\nimport { LocalAgentDataConnector } from './connectors/LocalAgentDataConnector.class';\nimport { SmythAgentDataConnector } from './connectors/SmythAgentDataConnector.class';\n\nexport class AgentDataService extends ConnectorServiceProvider {\n    public register() {\n        //FIXME : register an actual account connector, not the abstract one\n        ConnectorService.register(TConnectorService.AgentData, 'AgentData', AgentDataConnector);\n        ConnectorService.register(TConnectorService.AgentData, 'CLI', CLIAgentDataConnector);\n        ConnectorService.register(TConnectorService.AgentData, 'Local', LocalAgentDataConnector);\n        ConnectorService.register(TConnectorService.AgentData, 'Smyth', SmythAgentDataConnector);\n    }\n}\n","//==[ SRE: S3Storage ]======================\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { IAccessCandidate, IACL, TAccessLevel } from '@sre/types/ACL.types';\n\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IVectorDBRequest, VectorDBConnector } from '../VectorDBConnector';\nimport {\n    DatasourceDto,\n    IStorageVectorDataSource,\n    IStorageVectorNamespace,\n    IVectorDataSourceDto,\n    QueryOptions,\n    Source,\n    StorageVectorNamespaceMetadata,\n    VectorsResultData,\n} from '@sre/types/VectorDB.types';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { OpenAIEmbeddings } from '@langchain/openai';\nimport { VectorsHelper } from '../Vectors.helper';\nimport { isUrl } from '@sre/utils/data.utils';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport { NKVConnector } from '@sre/IO/NKV.service/NKVConnector';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport { JSONContentHelper } from '@sre/helpers/JsonContent.helper';\nimport { CacheConnector } from '@sre/MemoryManager/Cache.service';\nimport { OAuthConfig, SmythConfigs } from '@sre/types/Security.types';\nimport axios, { AxiosError } from 'axios';\nimport { AxiosInstance } from 'axios';\nimport { getM2MToken } from '@sre/utils/oauth.utils';\nimport { jsonrepair } from 'jsonrepair';\nimport crypto from 'crypto';\n\nconst console = Logger('Smyth Managed VectorDB');\n\nexport class SmythManagedVectorDB extends VectorDBConnector {\n    public name = 'SmythManagedVectorDB';\n    public id = 'smyth-managed';\n    private oAuthAppId: string;\n    private oAuthAppSecret: string;\n    private oAuthBaseUrl: string;\n    private oAuthResource?: string;\n    private oAuthScope?: string;\n    private smythAPI: AxiosInstance;\n    private accountConnector: AccountConnector;\n    private redisCache: CacheConnector;\n    private openaiApiKey: string;\n\n    private isCustomStorageInstance: boolean;\n\n    constructor(private config: SmythConfigs & OAuthConfig & { openaiApiKey?: string; isCustomStorageInstance?: boolean }) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n        this.oAuthAppId = config.oAuthAppID;\n        this.oAuthAppSecret = config.oAuthAppSecret;\n        this.oAuthBaseUrl = config.oAuthBaseUrl;\n        this.oAuthResource = config.oAuthResource || '';\n        this.oAuthScope = config.oAuthScope || '';\n        this.smythAPI = axios.create({\n            baseURL: `${config.smythAPIBaseUrl}`,\n        });\n        this.accountConnector = ConnectorService.getAccountConnector();\n        this.redisCache = ConnectorService.getCacheConnector('Redis');\n        this.openaiApiKey = config.openaiApiKey || process.env.OPENAI_API_KEY;\n        this.isCustomStorageInstance = config.isCustomStorageInstance || false;\n    }\n\n    @SecureConnector.AccessControl\n    protected async createDatasource(\n        acRequest: AccessRequest,\n        namespace: string,\n        datasource: DatasourceDto\n    ): Promise<{ id: string; vectorIds: string[] }> {\n        try {\n            const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n            const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n            const res = await this.smythAPI.post<{ dataSourceId: string }>(\n                '/v1/vectors/datasources/text',\n                {\n                    id: datasource.id || crypto.randomUUID(),\n                    name: datasource.label || 'Indexer Datasource',\n                    text: datasource.text,\n                    namespaceId: preparedNs,\n                    metadata: datasource.metadata ? JSON.stringify(datasource.metadata) : null,\n                    teamId,\n                },\n                { headers: await this.getSmythRequestHeaders() }\n            );\n\n            return {\n                id: res.data.dataSourceId,\n                vectorIds: [],\n            };\n        } catch (err: any) {\n            const errorMessage = err.response?.data?.message || err.message || 'Unknown error';\n            throw new Error('Failed to create datasource with error: ' + errorMessage);\n        }\n    }\n\n    @SecureConnector.AccessControl\n    protected async deleteDatasource(acRequest: AccessRequest, namespace: string, datasourceId: string): Promise<void> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n\n        try {\n            await this.smythAPI.delete(`/v1/vectors/datasources/${datasourceId}`, {\n                headers: await this.getSmythRequestHeaders(),\n            });\n        } catch (err: any) {\n            const errorMessage = err.response?.data?.message || err.message || 'Unknown error';\n            throw new Error('Failed to delete datasource with error: ' + errorMessage);\n        }\n    }\n\n    @SecureConnector.AccessControl\n    protected async listDatasources(acRequest: AccessRequest, namespace: string): Promise<{ id: string; data: IStorageVectorDataSource }[]> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n        try {\n            const res = await this.smythAPI.get<{ datasources: any[] }>(`/v1/vectors/datasources?namespaceId=${preparedNs}`, {\n                headers: await this.getSmythRequestHeaders(),\n            });\n            return res.data.datasources.map((d) => {\n                return {\n                    id: d.id,\n                    data: {\n                        name: d.name,\n                        namespaceId: d.namespaceId,\n                        teamId,\n                        embeddingIds: null,\n                        text: null,\n                        metadata: JSON.stringify({}),\n                    },\n                };\n            });\n        } catch (err: any) {\n            const errorMessage = err.response?.data?.message || err.message || 'Unknown error';\n            throw new Error('Failed to list datasources with error: ' + errorMessage);\n        }\n    }\n\n    @SecureConnector.AccessControl\n    protected async getDatasource(acRequest: AccessRequest, namespace: string, datasourceId: string): Promise<IStorageVectorDataSource> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n        try {\n            const res = await this.smythAPI\n                .get<{ dataSource: any }>(`/v1/vectors/datasources/${datasourceId}`, {\n                    headers: await this.getSmythRequestHeaders(),\n                })\n                .catch((e: AxiosError) => {\n                    if (e.response?.status === 404) {\n                        return undefined; // not found\n                    }\n                    throw e;\n                });\n            const ds = res?.data?.dataSource;\n            return ds\n                ? {\n                      name: ds.name,\n                      embeddingIds: null,\n                      metadata: JSON.stringify({}),\n                      namespaceId: ds.namespaceId,\n                      teamId,\n                      text: null,\n                  }\n                : undefined;\n        } catch (err: any) {\n            const errorMessage = err.response?.data?.message || err.message || 'Unknown error';\n            throw new Error('Failed to get datasource with error: ' + errorMessage);\n        }\n    }\n\n    @SecureConnector.AccessControl\n    protected async createNamespace(acRequest: AccessRequest, namespace: string, metadata?: { [key: string]: any }): Promise<void> {\n        // save namespace for listing\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n\n        try {\n            const res = await this.smythAPI.post(\n                '/v1/vectors/namespaces',\n                {\n                    name: namespace,\n                    teamId,\n                    useCustomVectorStorage: this.isCustomStorageInstance,\n                },\n                { headers: await this.getSmythRequestHeaders() }\n            );\n        } catch (err: any) {\n            const errorMessage = err.response?.data?.message || err.message || 'Unknown error';\n            throw new Error('Failed to create namespace with error: ' + errorMessage);\n        }\n\n        return new Promise<void>((resolve) => resolve());\n    }\n\n    @SecureConnector.AccessControl\n    protected async namespaceExists(acRequest: AccessRequest, namespace: string): Promise<boolean> {\n        const namespaceRecord = await this.getNamespace(acRequest, namespace);\n        return !!namespaceRecord;\n    }\n\n    @SecureConnector.AccessControl\n    protected async getNamespace(acRequest: AccessRequest, namespace: string): Promise<IStorageVectorNamespace> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n\n        const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n        try {\n            const res = await this.smythAPI\n                .get<{ namespace: any }>(`/v1/vectors/namespaces/${preparedNs}`, {\n                    headers: await this.getSmythRequestHeaders(),\n                })\n                .catch((e: AxiosError) => {\n                    if (e.response.status === 404) {\n                        return undefined; // not found\n                    }\n                    throw e;\n                });\n            const namespaceRecord = res?.data?.namespace;\n            if (!namespaceRecord) return undefined;\n            return {\n                displayName: namespaceRecord.name,\n                teamId,\n                namespace: namespaceRecord.id,\n                metadata: {\n                    indexName: namespaceRecord.indexName,\n                    isOnCustomStorage: namespaceRecord.isOnCustomStorage,\n                },\n            };\n        } catch (err: any) {\n            const errorMessage = err.response?.data?.message || err.message || 'Unknown error';\n            throw new Error('Failed to get namespace with error: ' + errorMessage);\n        }\n    }\n\n    protected async listNamespaces(acRequest: AccessRequest): Promise<IStorageVectorNamespace[]> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        try {\n            const response = await this.smythAPI.get<{\n                namespaces: {\n                    name: string;\n                    createdAt: string;\n                    id: string;\n                    isOnCustomStorage: boolean;\n                    indexName?: string;\n                }[];\n            }>(`/v1/vectors/namespaces?teamId=${teamId}`, { headers: await this.getSmythRequestHeaders() });\n\n            return response.data.namespaces.map((n) => {\n                return {\n                    displayName: n.name,\n                    namespace: n.id,\n                    metadata: {\n                        indexName: n.indexName,\n                        isOnCustomStorage: n.isOnCustomStorage,\n                    },\n                    teamId,\n                };\n            });\n        } catch (err: any) {\n            const errorMessage = err.response?.data?.message || err.message || 'Unknown error';\n            throw new Error('Failed to list namespaces with error: ' + errorMessage);\n        }\n    }\n\n    @SecureConnector.AccessControl\n    protected async deleteNamespace(acRequest: AccessRequest, namespace: string): Promise<void> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n\n        try {\n            const response = await this.smythAPI.delete(`/v1/vectors/namespaces/${preparedNs}`, { headers: await this.getSmythRequestHeaders() });\n        } catch (err: any) {\n            const errorMessage = err.response?.data?.message || err.message || 'Unknown error';\n            throw new Error('Failed to delete namespace with error: ' + errorMessage);\n        }\n    }\n\n    @SecureConnector.AccessControl\n    protected async search(\n        acRequest: AccessRequest,\n        namespace: string,\n        query: string | number[],\n        options: QueryOptions = {}\n    ): Promise<VectorsResultData> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        const preparedNs = VectorDBConnector.constructNsName(teamId, namespace);\n        if (typeof query !== 'string') {\n            throw new Error('Smyth Managed VectorDB only supports string queries');\n        }\n\n        try {\n            const response = await this.smythAPI.get<{ results: { pageContent: string; metadata: any }[] }>(\n                `/v1/vectors/namespaces/search?query=${query}&topK=${options?.topK}&namespaceId=${preparedNs}&raw=true`,\n                { headers: await this.getSmythRequestHeaders() }\n            );\n\n            return response.data.results.map((result) => {\n                let userMetadata = {};\n                try {\n                    userMetadata = JSON.parse(jsonrepair(result.metadata?.metadata));\n                } catch (err) {\n                    userMetadata = result.metadata?.metadata;\n                }\n                return {\n                    id: null,\n                    values: [],\n                    metadata: {\n                        text: result.pageContent,\n                        user: userMetadata,\n                    },\n                };\n            });\n        } catch (err: any) {\n            const errorMessage = err.response?.data?.message || err.message || 'Unknown error';\n            throw new Error('Failed to search with error: ' + errorMessage);\n        }\n    }\n\n    @SecureConnector.AccessControl\n    protected async insert(\n        acRequest: AccessRequest,\n        namespace: string,\n        sourceWrapper: IVectorDataSourceDto | IVectorDataSourceDto[]\n    ): Promise<string[]> {\n        throw new Error('Smyth Managed VectorDB does not support direct insertion by vector id(s)');\n    }\n\n    @SecureConnector.AccessControl\n    protected async delete(acRequest: AccessRequest, namespace: string, id: string | string[]): Promise<void> {\n        throw new Error('Smyth Managed VectorDB does not support direct deletion by vector id(s)');\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL> {\n        const teamId = await this.accountConnector.getCandidateTeam(AccessCandidate.clone(candidate));\n        const preparedNs = VectorDBConnector.constructNsName(teamId, resourceId);\n        const nsRecord = await this.smythAPI\n            .get(`/v1/vectors/namespaces/${preparedNs}`, { headers: await this.getSmythRequestHeaders() })\n            .catch((e: AxiosError) => {\n                if (e.response?.status === 404) {\n                    return null; // not found\n                }\n                throw e;\n            });\n        const exists = !!nsRecord;\n\n        if (!exists) {\n            //the resource does not exist yet, we grant write access to the candidate in order to allow the resource creation\n            return new ACL().addAccess(candidate.role, candidate.id, TAccessLevel.Owner);\n        }\n        return new ACL().addAccess(candidate.role, candidate.id, TAccessLevel.Owner);\n    }\n\n    private async getSmythRequestHeaders() {\n        return {\n            Authorization: `Bearer ${await getM2MToken({\n                baseUrl: this.oAuthBaseUrl,\n                oauthAppId: this.oAuthAppId,\n                oauthAppSecret: this.oAuthAppSecret,\n                resource: this.oAuthResource,\n                scope: this.oAuthScope,\n            })}`,\n        };\n    }\n}\n","//==[ SRE: Storage ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { PineconeVectorDB } from './connectors/PineconeVectorDB.class';\nimport { SmythManagedVectorDB } from './connectors/SmythManagedVectorDB.class';\n\nexport class VectorDBService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.VectorDB, 'Pinecone', PineconeVectorDB);\n        ConnectorService.register(TConnectorService.VectorDB, 'SmythManaged', SmythManagedVectorDB);\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { getMainArgs, parseCLIArgs } from '@sre/utils/cli.utils';\n\nexport class CLIConnector extends Connector {\n    public name = 'CLI';\n    public params: any;\n    constructor() {\n        super();\n        this.params = this.parse(process.argv);\n    }\n\n    /**\n     * Parses the command line arguments, and returns the parsed arguments object\n     * if args is provided, it will only parse the provided args\n     * @param argv The command line arguments, usually process.argv\n     * @param args The arguments to parse\n     * @returns\n     */\n    public parse(argv: string[], args?: string | string[]) {\n        let _keys = args;\n        if (_keys && !Array.isArray(_keys)) _keys = [_keys];\n\n        const argsList = _keys || getMainArgs(argv);\n        const params = parseCLIArgs(argsList, argv);\n\n        return params;\n    }\n\n    /**\n     * Get the parsed arguments as an object\n     * @param args The arguments to get\n     * @returns\n     */\n    public get(args: string | string[]) {\n        let _keys = args;\n        if (!Array.isArray(_keys)) _keys = [_keys];\n\n        const result = {};\n        _keys.forEach((key) => {\n            if (this.params[key]) {\n                result[key] = this.params[key];\n            }\n        });\n\n        return result;\n    }\n}\n","import { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { CLIConnector } from './CLIConnector';\n\nexport class CLIService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.CLI, 'CLI', CLIConnector);\n    }\n}\n","import { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL } from '@sre/types/ACL.types';\nimport { StorageData, StorageMetadata } from '@sre/types/Storage.types';\n\nexport interface INKVRequest {\n    get(namespace: string, key: string): Promise<StorageData>;\n    set(namespace: string, key: string, value: StorageData): Promise<void>;\n    delete(namespace: string, key: string): Promise<void>;\n    exists(namespace: string, key: string): Promise<boolean>;\n    deleteAll(namespace: string): Promise<void>;\n    list(namespace: string): Promise<{ key: string; data: StorageData }[]>;\n}\n\n/**\n * NKV = Namespace-Key-Value Connector\n */\nexport abstract class NKVConnector extends SecureConnector {\n    public user(candidate: AccessCandidate): INKVRequest {\n        return {\n            get: async (namespace: string, key: string) => this.get(candidate.readRequest, namespace, key),\n            set: async (namespace: string, key: string, value: StorageData) => this.set(candidate.writeRequest, namespace, key, value),\n            delete: async (namespace: string, key: string) => this.delete(candidate.writeRequest, namespace, key),\n            exists: async (namespace: string, key: string) => this.exists(candidate.readRequest, namespace, key),\n            deleteAll: async (namespace: string) => this.deleteAll(candidate.writeRequest, namespace),\n            list: async (namespace: string) => this.list(candidate.readRequest, namespace),\n        };\n    }\n\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n\n    protected abstract get(acRequest: AccessRequest, namespace: string, key: string): Promise<StorageData>;\n    protected abstract set(acRequest: AccessRequest, namespace: string, key: string, value: StorageData): Promise<void>;\n\n    protected abstract delete(acRequest: AccessRequest, namespace: string, key: string): Promise<void>;\n    protected abstract exists(acRequest: AccessRequest, namespace: string, key: string): Promise<boolean>;\n    protected abstract deleteAll(acRequest: AccessRequest, namespace: string): Promise<void>;\n    protected abstract list(acRequest: AccessRequest, namespace: string): Promise<{ key: string; data: StorageData }[]>;\n}\n","import { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { INKVRequest, NKVConnector } from '../NKVConnector';\nimport { ACLAccessDeniedError, IAccessCandidate, TAccessLevel, TAccessResult } from '@sre/types/ACL.types';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { CacheConnector } from '@sre/MemoryManager/Cache.service/CacheConnector';\nimport { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { StorageData } from '@sre/types/Storage.types';\nimport { RedisCache } from '@sre/MemoryManager/Cache.service/connectors/RedisCache.class';\nimport { AccountConnector } from '@sre/Security/Account.service/AccountConnector';\nimport Joi from 'joi';\n\nexport class NKVRedis extends NKVConnector {\n    public name = 'Redis';\n    private redisCacheConnector: RedisCache;\n    private accountConnector: AccountConnector;\n    constructor() {\n        super();\n        this.redisCacheConnector = ConnectorService.getCacheConnector('Redis') as RedisCache;\n        this.accountConnector = ConnectorService.getAccountConnector();\n    }\n\n    public key(...parts: string[]) {\n        return parts.join(':');\n    }\n\n    public mdKey(...parts: string[]) {\n        return parts.join(':');\n    }\n\n    @NKVRedis.Validate\n    @NKVRedis.NamespaceAccessControl\n    protected async get(acRequest: AccessRequest, namespace: string, key: string): Promise<StorageData> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        return await this.redisCacheConnector.user(AccessCandidate.team(teamId)).get(this.key(`team_${teamId}`, namespace, key));\n    }\n\n    @NKVRedis.Validate\n    @NKVRedis.NamespaceAccessControl\n    protected async set(acRequest: AccessRequest, namespace: string, key: string, value: any) {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n\n        const setKey = this.key(`team_${teamId}`, namespace, key);\n        await this.redisCacheConnector.user(AccessCandidate.team(teamId)).set(setKey, value);\n        // to set namespace ownership\n        const isNewNs = !(await this.redisCacheConnector.user(AccessCandidate.team(teamId)).exists(namespace));\n        if (isNewNs) {\n            await this.redisCacheConnector.user(AccessCandidate.team(teamId)).set(this.key(`team_${teamId}`, namespace), '', undefined, { ns: true });\n        }\n    }\n\n    @NKVRedis.Validate\n    @NKVRedis.NamespaceAccessControl\n    protected async delete(acRequest: AccessRequest, namespace: string, key: string): Promise<void> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        await this.redisCacheConnector.user(AccessCandidate.team(teamId)).delete(this.key(`team_${teamId}`, namespace, key));\n    }\n\n    @NKVRedis.Validate\n    @NKVRedis.NamespaceAccessControl\n    protected async exists(acRequest: AccessRequest, namespace: string, key: string): Promise<boolean> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        return await this.redisCacheConnector.user(AccessCandidate.team(teamId)).exists(this.key(`team_${teamId}`, namespace, key));\n    }\n\n    @NKVRedis.NamespaceAccessControl\n    public async list(acRequest: AccessRequest, namespace: string): Promise<{ key: string; data: StorageData }[]> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        let keys = await this.fetchKeysByPrefix(this.key(this.redisCacheConnector.prefix, `team_${teamId}`, namespace));\n\n        // filter out metadata keys & namespace sentinel keys\n        keys = keys.filter(\n            (key) => key !== this.key(this.redisCacheConnector.prefix, `team_${teamId}`, namespace) // if not the namespace sentinel key\n        );\n\n        if (keys.length <= 0) return [];\n        // Start a transaction\n        const pipeline = this.redisCacheConnector.client.pipeline();\n\n        // Add get commands for all keys to the transaction\n        keys.forEach((key) => {\n            pipeline.get(key);\n        });\n\n        // Execute the transaction\n        const results = await pipeline.exec();\n\n        // Combine the keys and their corresponding values\n        return keys.map((key, index) => {\n            return {\n                key: key.replace(`${this.key(this.redisCacheConnector.prefix, `team_${teamId}`, namespace)}:`, ''),\n                data: results[index][1] as StorageData,\n            };\n        });\n    }\n\n    @NKVRedis.NamespaceAccessControl\n    public async deleteAll(acRequest: AccessRequest, namespace: string): Promise<void> {\n        const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n        let keys = await this.fetchKeysByPrefix(this.key(this.redisCacheConnector.prefix, `team_${teamId}`, namespace));\n        // filter out namespace sentinel key + namespace metadata key metadata key\n        keys = keys.filter((key) => {\n            return ![this.key(this.redisCacheConnector.prefix, `team_${teamId}`, namespace)].includes(key);\n        });\n        await this.redisCacheConnector.client.del(keys);\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL> {\n        return this.redisCacheConnector.getResourceACL(resourceId, candidate);\n    }\n\n    private async fetchKeysByPrefix(prefix: string): Promise<string[]> {\n        let cursor = '0';\n        const keys = [];\n\n        do {\n            // SCAN with match for the prefix and count for batch size (optional)\n            const result = await this.redisCacheConnector.client.scan(cursor, 'MATCH', `${prefix}*`, 'COUNT', 10000);\n            cursor = result[0];\n            keys.push(...result[1]);\n        } while (cursor !== '0');\n\n        return keys;\n    }\n\n    static NamespaceAccessControl(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        // Store the original method in a variable\n        const originalMethod = descriptor.value;\n\n        // Modify the descriptor's value to wrap the original method\n        descriptor.value = async function (...args: any[]) {\n            // Extract the method arguments\n            let [acRequest, namespace, key] = args;\n            const isNamespaceSearch = key === undefined;\n\n            // Inject the access control logic\n            const teamId = await this.accountConnector.getCandidateTeam(acRequest.candidate);\n            const resourceId = isNamespaceSearch ? namespace : `${namespace}:${key}`;\n            const finalKey = this.key(this.redisCacheConnector.prefix, `team_${teamId}`, resourceId);\n            const accessTicket = await this.getAccessTicket(finalKey, acRequest);\n\n            if (accessTicket.access !== TAccessResult.Granted) throw new ACLAccessDeniedError('Access Denied');\n\n            // Call the original method with the original arguments\n            return originalMethod.apply(this, args);\n        };\n\n        // Return the modified descriptor\n        return descriptor;\n    }\n\n    static Validate(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        // Store the original method in a variable\n        const originalMethod = descriptor.value;\n\n        // Modify the descriptor's value to wrap the original method\n        descriptor.value = async function (...args: any[]) {\n            // Extract the method arguments\n            let [acRequest, namespace, key] = args;\n\n            // Validate the arguments\n            const schemaValidator = Joi.object().keys({\n                namespace: Joi.string().min(1).required(),\n                key: Joi.string().min(1).required(),\n            });\n            const validationResult = schemaValidator.validate({ namespace, key });\n\n            if (validationResult.error) {\n                throw new Error(`Validation Error: ${validationResult.error.message}`);\n            }\n\n            // Call the original method with the original arguments\n            return originalMethod.apply(this, args);\n        };\n\n        // Return the modified descriptor\n        return descriptor;\n    }\n}\n","//==[ SRE: Storage ]======================\n\nimport { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { NKVRedis } from './connectors/NKVRedis.class';\n\nexport class NKVService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.NKV, 'Redis', NKVRedis);\n    }\n}\n","import { Connector } from '@sre/Core/Connector.class';\nimport { SmythFS } from '../Storage.service/SmythFS.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\n\nexport type GenericRequestHandler = (...args: any[]) => void | Promise<void>;\n\n/*\nThis Connector is highly discouraged to be used because by design, SRE should not handle any kind of HTTP requests\nCurrently it is only used to serve the temp files for external services to retrieve them.\n*/\n\nexport abstract class RouterConnector extends Connector {\n    public abstract baseUrl: string;\n\n    abstract get(path: string, ...handlers: GenericRequestHandler[]): this;\n    abstract post(path: string, ...handlers: GenericRequestHandler[]): this;\n    abstract put(path: string, ...handlers: GenericRequestHandler[]): this;\n    abstract delete(path: string, ...handlers: GenericRequestHandler[]): this;\n    abstract useFn(...handlers: GenericRequestHandler[]): this;\n    abstract use(path: string, ...handlers: GenericRequestHandler[]): this;\n}\n","import { Router } from 'express';\nimport { RouterConnector, GenericRequestHandler } from '../RouterConnector';\nimport { SmythFS } from '@sre/IO/Storage.service/SmythFS.class';\n\nexport class ExpressRouter extends RouterConnector {\n    private router: Router;\n    public baseUrl: string;\n\n    constructor(config: { router: Router; baseUrl: string }) {\n        super(config);\n        this.name = 'ExpressRouter';\n        this.router = config.router;\n        this.baseUrl = config.baseUrl;\n    }\n\n    get(path: string, ...handlers: GenericRequestHandler[]): this {\n        this.router.get(path, ...handlers);\n        return this;\n    }\n\n    post(path: string, ...handlers: GenericRequestHandler[]): this {\n        this.router.post(path, ...handlers);\n        return this;\n    }\n\n    put(path: string, ...handlers: GenericRequestHandler[]): this {\n        this.router.put(path, ...handlers);\n        return this;\n    }\n\n    delete(path: string, ...handlers: GenericRequestHandler[]): this {\n        this.router.delete(path, ...handlers);\n        return this;\n    }\n\n    useFn(...handlers: GenericRequestHandler[]): this {\n        this.router.use(...handlers);\n        return this;\n    }\n\n    use(path: string, ...handlers: GenericRequestHandler[]): this {\n        this.router.use(path, ...handlers);\n        return this;\n    }\n\n    getRouter(): Router {\n        return this.router;\n    }\n}\n","import { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { ExpressRouter } from './connectors/ExpressRouter.class';\n\nexport class RouterService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.Router, 'ExpressRouter', ExpressRouter);\n    }\n}\n","import { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, IACL } from '@sre/types/ACL.types';\n\n/**\n * The managed vault is a vault that is managed by the SRE, its keys are not visible to the user.\n * it's used to store generated tokens at runtime, like OAuth tokens\n */\n\nexport interface IManagedVaultRequest {\n    get(keyId: string): Promise<string>;\n    set(keyId: string, value: string): Promise<void>;\n    delete(keyId: string): Promise<void>;\n    exists(keyId: string): Promise<boolean>;\n}\n\nexport abstract class ManagedVaultConnector extends SecureConnector {\n    user(candidate: AccessCandidate): IManagedVaultRequest {\n        return {\n            get: async (keyId: string) => this.get(candidate.readRequest, keyId),\n            set: async (keyId: string, value: string) => this.set(candidate.writeRequest, keyId, value),\n            delete: async (keyId: string) => this.delete(candidate.writeRequest, keyId),\n            exists: async (keyId: string) => this.exists(candidate.readRequest, keyId),\n        };\n    }\n\n    public abstract getResourceACL(resourceId: string, candidate: IAccessCandidate): Promise<ACL>;\n    protected abstract get(acRequest: AccessRequest, keyId: string): Promise<string>;\n    protected abstract set(acRequest: AccessRequest, keyId: string, value: string): Promise<void>;\n    protected abstract delete(acRequest: AccessRequest, keyId: string): Promise<void>;\n    protected abstract exists(acRequest: AccessRequest, keyId: string): Promise<boolean>;\n}\n","import { ConnectorService } from '@sre/Core/ConnectorsService';\nimport { Logger } from '@sre/helpers/Log.helper';\nimport SmythRuntime from '@sre/Core/SmythRuntime.class';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { AccessRequest } from '@sre/Security/AccessControl/AccessRequest.class';\nimport { ACL } from '@sre/Security/AccessControl/ACL.class';\nimport { SecureConnector } from '@sre/Security/SecureConnector.class';\nimport { IAccessCandidate, TAccessLevel, TAccessRole } from '@sre/types/ACL.types';\nimport { OAuthConfig, SmythConfigs } from '@sre/types/Security.types';\n\nimport { getM2MToken } from '@sre/utils/oauth.utils';\nimport axios, { AxiosInstance } from 'axios';\nimport { ManagedVaultConnector } from '../ManagedVaultConnector';\n\nconst console = Logger('SmythManagedVault');\nexport class SmythManagedVault extends ManagedVaultConnector {\n    public name: string = 'SmythManagedVault';\n    private oAuthAppId: string;\n    private oAuthAppSecret: string;\n    private oAuthBaseUrl: string;\n    private oAuthResource?: string;\n    private oAuthScope?: string;\n    private smythAPI: AxiosInstance;\n    private vaultName: string;\n\n    constructor(private config: SmythConfigs & OAuthConfig & { vaultName: string }) {\n        super();\n        if (!SmythRuntime.Instance) throw new Error('SRE not initialized');\n\n        this.oAuthAppId = config.oAuthAppID;\n        this.oAuthAppSecret = config.oAuthAppSecret;\n        this.oAuthBaseUrl = config.oAuthBaseUrl;\n        this.oAuthResource = config.oAuthResource || '';\n        this.oAuthScope = config.oAuthScope || '';\n        this.smythAPI = axios.create({\n            baseURL: `${config.smythAPIBaseUrl}`,\n        });\n        this.vaultName = config.vaultName || 'vault';\n    }\n\n    @SecureConnector.AccessControl\n    protected async get(acRequest: AccessRequest, keyId: string) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n        const vaultSetting = await accountConnector.getTeamSetting(acRequest, teamId, this.vaultName);\n        const vaultData = JSON.parse(vaultSetting || '{}');\n        return vaultData[keyId];\n    }\n\n    @SecureConnector.AccessControl\n    protected async set(acRequest: AccessRequest, keyId: string, value: string) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n        const vaultSetting = await accountConnector.getTeamSetting(acRequest, teamId, this.vaultName);\n        const vaultData = JSON.parse(vaultSetting || '{}');\n        vaultData[keyId] = value;\n        await this.smythAPI.put(\n            `/v1/teams/${teamId}/settings`,\n            {\n                settingKey: this.vaultName,\n                settingValue: JSON.stringify(vaultData),\n            },\n            { headers: await this.getSmythRequestHeaders() }\n        );\n    }\n\n    @SecureConnector.AccessControl\n    protected async delete(acRequest: AccessRequest, keyId: string) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n        const vaultSetting = await accountConnector.getTeamSetting(acRequest, teamId, this.vaultName);\n        const vaultData = JSON.parse(vaultSetting || '{}');\n        delete vaultData[keyId];\n        await this.smythAPI.put(\n            `/v1/teams/${teamId}/settings`,\n            {\n                settingKey: this.vaultName,\n                settingValue: JSON.stringify(vaultData),\n            },\n            { headers: await this.getSmythRequestHeaders() }\n        );\n    }\n\n    @SecureConnector.AccessControl\n    protected async exists(acRequest: AccessRequest, keyId: string) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(acRequest.candidate);\n        const vaultSetting = await accountConnector.getTeamSetting(acRequest, teamId, this.vaultName);\n        const vaultData = JSON.parse(vaultSetting || '{}');\n        return keyId in vaultData;\n    }\n\n    public async getResourceACL(resourceId: string, candidate: IAccessCandidate) {\n        const accountConnector = ConnectorService.getAccountConnector();\n        const teamId = await accountConnector.getCandidateTeam(candidate);\n\n        const acl = new ACL();\n\n        acl.addAccess(TAccessRole.Team, teamId, TAccessLevel.Owner)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Read)\n            .addAccess(TAccessRole.Team, teamId, TAccessLevel.Write);\n\n        return acl;\n    }\n\n    private async getSmythRequestHeaders() {\n        return {\n            Authorization: `Bearer ${await getM2MToken({\n                baseUrl: this.oAuthBaseUrl,\n                oauthAppId: this.oAuthAppId,\n                oauthAppSecret: this.oAuthAppSecret,\n                resource: this.oAuthResource,\n                scope: this.oAuthScope,\n            })}`,\n        };\n    }\n}\n","import { ConnectorService, ConnectorServiceProvider } from '@sre/Core/ConnectorsService';\nimport { TConnectorService } from '@sre/types/SRE.types';\nimport { SmythManagedVault } from './connectors/SmythManagedVault';\n\nexport class ManagedVaultService extends ConnectorServiceProvider {\n    public register() {\n        ConnectorService.register(TConnectorService.ManagedVault, 'SmythManagedVault', SmythManagedVault);\n    }\n}\n","import { StorageService } from '@sre/IO/Storage.service';\nimport { LLMService } from '@sre/LLMManager/LLM.service';\nimport SystemEvents from './SystemEvents';\nimport { CacheService } from '@sre/MemoryManager/Cache.service';\nimport { Logger } from '../helpers/Log.helper';\nimport { TServiceRegistry } from '@sre/types/SRE.types';\nimport { VaultService } from '@sre/Security/Vault.service';\nimport { AccountService } from '@sre/Security/Account.service';\nimport { AgentDataService } from '@sre/AgentManager/AgentData.service';\nimport { VectorDBService } from '@sre/IO/VectorDB.service';\nimport { CLIService } from '@sre/IO/CLI.service';\nimport { NKVService } from '@sre/IO/NKV.service';\nimport { RouterService } from '@sre/IO/Router.service';\nimport { ManagedVaultService } from '@sre/Security/ManagedVault.service';\nconst console = Logger('Boot');\n\nexport function boot() {\n    console.debug('SRE Boot sequence started');\n    const service: TServiceRegistry = {};\n    service.NKV = new NKVService();\n    service.Account = new AccountService();\n    service.Vault = new VaultService();\n    service.ManagedVault = new ManagedVaultService();\n    service.Cache = new CacheService();\n    service.Storage = new StorageService();\n    service.LLM = new LLMService();\n    service.AgentData = new AgentDataService();\n    service.CLI = new CLIService();\n    service.VectorDB = new VectorDBService();\n    service.Router = new RouterService();\n\n    SystemEvents.on('SRE:Initialized', () => {\n        console.debug('SRE Initialized');\n        for (let key in service) {\n            service[key].init();\n        }\n\n        SystemEvents.emit('SRE:Booted', service);\n\n        console.debug('SRE Boot sequence completed');\n    });\n}\n","import 'source-map-support/register.js';\nimport AgentRequest from './subsystems/AgentManager/AgentRequest.class';\nimport AgentSettings from './subsystems/AgentManager/AgentSettings.class';\n//import SRE from './Core/SRE.class';\nimport Agent from './subsystems/AgentManager/Agent.class';\nimport SmythRuntime from './Core/SmythRuntime.class';\nimport { boot } from './Core/boot';\nimport { ConnectorService } from './Core/ConnectorsService';\nimport { CLIAgentDataConnector } from './subsystems/AgentManager/AgentData.service/connectors/CLIAgentDataConnector.class';\nimport { AgentProcess } from './Core/AgentProcess.helper';\nimport { Conversation } from './helpers/Conversation.helper';\nimport config from './config';\nimport { AccessCandidate } from '@sre/Security/AccessControl/AccessCandidate.class';\nimport { StorageConnector } from '@sre/IO/Storage.service/StorageConnector';\n\nboot();\n\nexport {\n    Agent,\n    AgentRequest,\n    AgentSettings,\n    AgentProcess,\n    AccessCandidate,\n    SmythRuntime,\n    Conversation,\n    ConnectorService,\n    CLIAgentDataConnector,\n    StorageConnector,\n    config,\n};\n"],"names":["e","Object","defineProperty","i","a","s","t","enumerable","configurable","writable","value","h","AgentRequest","constructor","req","__publicField","this","headers","JSON","parse","stringify","body","data","query","params","url","parsedUrl","URL","path","pathname","method","sessionID","files","_agent_authinfo","res","header","name","toLowerCase","TConnectorService","Storage","VectorDB","Cache","LLM","Vault","Account","AgentData","CLI","NKV","Router","ManagedVault","uid","Date","now","Math","random","toString","replace","toUpperCase","async","processWithConcurrencyLimit","tasks","maxConcurrentTasks","limit","pLimit","limitedTasks","map","task","Promise","allSettled","flatMap","result","status","filter","Boolean","isJSONString","str","delay","ms","r","setTimeout","isValidString","convertStringToRespectiveType","num","parseFloat","isNaN","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","trim","isValidNumber","Array","isArray","item","fromEntries","entries","key","kebabToCapitalize","input","split","word","charAt","slice","join","REQUEST_METHODS","REQUEST_CONTENT_TYPES","EMBODIMENT_TYPES","ChatBot","ChatGPT","TOOL_USE_DEFAULT_MODEL","JSON_RESPONSE_INSTRUCTION","isBase64","length","Error","_cleanUpBase64Data","Buffer","from","streamToBuffer","stream","chunks","chunk","push","concat","binaryMimeTypes","dataToBuffer","bufferData","ArrayBuffer","Uint8Array","isView","DataView","buffer","byteOffset","byteLength","isBuffer","isPlainObject","prototype","call","isUrl","test","isSmythFileObject","parseCLIArgs","argList","argv","process","args","forEach","mainArg","mainArgIndex","indexOf","values","startsWith","includes","keyValuePairs","valParts","val","isDigits","isSafeNumber","validateCharacterSet","parts","part","endsWith","validateInteger","helpers","numValue","fieldName","schema","_flags","label","state","min","max","dotenv","config","env","LOG_LEVEL","LOG_FILTER","OPENAI_API_KEY","ANTHROPIC_API_KEY","DATA_PATH","NODE_ENV","AGENT_DOMAIN","PROD_AGENT_DOMAIN","AGENT_DOMAIN_PORT","CODE_SANDBOX_URL","TOGETHER_AI_API_URL","REDIS_SENTINEL_HOSTS","REDIS_MASTER_NAME","REDIS_PASSWORD","AWS_ACCESS_KEY_ID","AWS_SECRET_ACCESS_KEY","AWS_S3_REGION","AWS_S3_BUCKET_NAME","PINECONE_API_KEY","PINECONE_INDEX_NAME","LOGTO_SERVER","SMYTH_VAULT_API_BASE_URL","agent","ENDPOINT_PREFIX","p","c","f","winston","addColors","error","warn","info","debug","logLevelMap","full","logLevel","namespaces","namespaceFilter","format","some","ns","module","ArrayTransport","Transport","opts","super","logs","log","callback","setImmediate","emit","level","message","LogHelper","_logger","labels","output","elapsedTime","startTime","formatLogMessage","verbose","stack","close","clear","printf","timestamp","colorize","MAX_LOG_MESSAGE_LENGTH","createBaseLogger","memoryStore","logger","createLogger","combine","logMessage","sensitiveWords","sensitiveWord","regex","RegExp","redactLogMessage","errors","splat","json","transports","Console","substring","stderrLevels","add","arg","String","Logger","withMemoryStore","defaultMeta","createLabeledLogger","DummyConnector","Proxy","get","target","prop","receiver","n","l","console","lCache","defaultTTL","cache","Map","expiryMap","timeouts","set","ttlMs","expiry","clearTimeout","timeout","delete","has","keys","Connector","instance","configHash","createHash","update","digest","start","started","stop","ready","_readyPromise","resolve","maxWait","interval","setInterval","clearInterval","SystemEvents","EventEmitter","Connectors","ConnectorInstances","ServiceRegistry","_ready","on","services","ConnectorService","service","register","connectorType","connectorName","connectorConstructor","subClass","superClass","getPrototypeOf","depth","isSubclassOf","init","connectorId","settings","isDefault","entry","connector","id","default","_stop","allConnectors","index","self","getInstance","getStorageConnector","getCacheConnector","getVectorDBConnector","getNKVConnector","getLLMConnector","getVaultConnector","getManagedVaultConnector","getAccountConnector","getAgentDataConnector","getCLIConnector","hasInstance","getRouterConnector","ConnectorServiceProvider","EmbodimentSettings","agentId","_embodiments","reject","embodimentType","_embodiment","find","embodiment","type","properties","o","AgentSettings","agentDataConnector","_settings","getAgentSettings","catch","embodiments","TAccessLevel","None","Owner","Read","Write","TAccessRole","Agent","User","Team","Public","RoleMap","user","team","public","LevelMap","none","owner","read","write","ReverseRoleMap","k","v","ReverseLevelMap","TAccessResult","Granted","Denied","ACLAccessDeniedError","d","AccessRequest","object","every","candidate","acReq","resourceId","clone","request","setLevel","addLevel","resource","setCandidate","AccessCandidate","role","readRequest","writeRequest","ownerRequest","teamId","userId","A","L","ACLHashAlgo","source","xxh3","xxhash","h64","ACL","acl","deserializeACL","hashAlgorithm","migrated","serializedACL","serializeACL","checkExactAccess","acRequest","entryId","access","addPublicAccess","ownerId","hashedOwner","curLevel","removePublicAccess","addAccess","_level","removeAccess","tacl","compressed","roleShort","entriesArray","hashedOwnerKey","accessLevels","accessLevelsShort","entriesObj","short","JSONContentHelper","dataString","_current","create","tryParse","strInput","extractJsonFromString","jsonrepair","tryFullParse","match","JSONContent","router","Function","SmythFS","Instance","serveTempContent","bind","_SmythFS","storage","URIParser","uri","parsed","tld","hostname","pop","hash","getStoragePath","smythURI","_candidate","toBuffer","Readable","err","metadata","isTeamMember","ContentType","getMimeType","ext","mime","getType","Blob","FileType","fileTypeFromBuffer","exists","genTempUrl","ttlSeconds","resourceMetadata","getMetadata","crypto","randomUUID","tempUserCandidate","accessCandidate","contentType","baseUrl","destroyTempUrl","delResource","cacheVal","writeHead","end","content","y","BinaryInput","_name","mimetype","load","size","_source","getUrlInfo","contentLength","response","axios","responseType","getExtension","base64FileInfo","getBase64FileInfo","getSizeFromBinary","fileType","head","base64Data","filetype","upload","_uploading","getCandidateTeam","getJsonData","readData","getName","getBuffer","InferenceStrategies","any","string","cleanedBase64Data","cleanBase64","isRawBase64","isDataUrl","number","floatVal","integer","intVal","parseInt","boolean","lowerCaseValue","array","obj","binary","binaryInput","date","errMsg","dayjs","locale","unix","isValid","toISOString","performTypeInference","inputs","inputConfig","_inputs","_inputConfig","Component","createComponentLogger","agentRuntime","validateConfig","configSchema","_templateVars","tplVar","append","Joi","valid","validate","_error","displayName","title","_debug","_input","postProcess","enable","disable","readOutput","hasOutput","VaultHelper","getTeamKey","getUserKey","vaultConnector","getAgentKey","Match","doubleCurly","singleCurly","doubleCurlyForSingleMatch","templateVariables","prefix","suffix","prefSuf","fn","TPLProcessor","vaultTeam","token","componentTemplateVar","templateSettings","matches","TemplateStringHelper","templateString","_promiseQueue","asyncResult","all","parseRaw","parseTeamKeysAsync","parseComponentTemplateVarsAsync","processor","tokens","prosessorPromises","exec","_processor","then","clean","escapeString","TemplateString","V","j","E","isEmpty","isTemplateVar","isKeyTemplateVar","parseKey","u","TLLMMessageRole","Assistant","System","Model","Tool","TLLMProvider","OpenAI","AnthropicAI","GoogleAI","Groq","TogetherAI","Bedrock","VertexAI","models","echo","llm","alias","Echo","completionTokens","enabled","components","baseURL","keyOptions","tags","hidden","m","_LLMRegistry","model","isStandardLLM","modelExists","getModelId","getBaseURL","modelId","getModelKeyOptions","getProvider","getModelInfo","hasAPIKey","modelInfo","getMaxContextTokens","getMaxCompletionTokens","adjustMaxCompletionTokens","maxTokens","validateTokensLimit","promptTokens","allowedContextTokens","totalTokens","g","LLMRegistry","customModels","supportsSystemPrompt","supportsStreamingToolUse","gemma2","gemma","codegemma","llama3_1","llama3","llama2","codestral","mixtral","phi3","qwen2","mammut","mistral","nllb","openllama","imagetext","pic2word","CustomLLMRegistry","registry","loadCustomModels","savedCustomModels","getCustomModels","teamSettings","getTeamSetting","savedCustomModelsData","foundationModel","customModelData","provider","features","LLMInference","llmInference","llmProvider","llmConnector","promptRequest","prompt","customParams","messages","_prompt","enhancePrompt","assign","prepareParams","chatRequest","finishReason","visionRequest","fileSources","promises","_fileSources","image","multimodalRequest","imageGenRequest","toolRequest","_params","streamToolRequest","streamRequest","dummyEmitter","nextTick","getConsistentMessages","clonedConfigData","preparedParams","_value","PromptGenerator","required","temperature","stopSequences","allow","topP","topK","frequencyPenalty","presencePenalty","responseFormat","Reply","details","handleJson","handleUrlEncoded","URLSearchParams","handleMultipartFormData","formData","FormData","_body","bufferStream","filename","getHeaders","handleBinary","handleNone","handleText","mimeTypeCategories","text","contentHandlers","parseText","parseBinary","parseArrayBufferResponse","cleanContentType","handlerType","handler","isBinaryMimeType","isBinaryFileSync","isBinaryData","managedVault","AccessTokenManager","clientId","clientSecret","secondaryToken","tokenUrl","expires_in","primaryToken","keyId","getAccessToken","currentTime","getTime","refreshAccessToken","post","client_id","client_secret","refresh_token","grant_type","newAccessToken","access_token","expiresInMilliseconds","expirationTimestamp","primary","save","handleOAuthHeaders","reqConfig","additionalParams","rootUrl","responseData","oauthTokens","tokenKey","componentId","tokensData","secondary","oauthService","consumerKey","consumerSecret","tokenURL","clientID","expiresIn","retrieveOAuthTokens","oAuthConfigString","oAuthConfig","accessToken","logAndThrowError","oauth_info","oauth_keys_prefix","getClientCredentialToken","Authorization","oauthHeader","oauth1Credentials","oauth","OAuth","consumer","secret","signature_method","hash_function","base_string","createHmac","requestData","signedRequest","authorize","tokenSecret","toHeader","buildOAuth1Header","U","CInstance","_SmythRuntime","_config","initialized","autoConf","configEntry","Id","Settings","Default","newConfig","hasDefault","SmythRuntime","SecureConnector","hasAccess","aclHelper","getResourceACL","publicRequest","teamRequest","teamOwnerRequest","getAccessTicket","sysAcRequest","AccessControl","propertyKey","descriptor","originalMethod","apply","VectorDBConnector","search","namespace","options","createDatasource","datasource","deleteDatasource","datasourceId","listDatasources","getDatasource","createNamespace","deleteNamespace","listNamespaces","namespaceExists","getNamespace","constructNsName","parseNsName","nsName","D","T","getOwnPropertyDescriptor","C","$","PineconeVectorDB","pineconeApiKey","indexName","client","Pinecone","apiKey","accountConnector","redisCache","nkvConnector","openaiApiKey","isCustomStorageInstance","preparedNs","getACL","nsData","isOnCustomStorage","setACL","list","Index","deleteAll","deleteACL","pineconeIndex","_vector","VectorsHelper","embedText","vector","includeMetadata","includeValues","parseMetadata","insert","sourceWrapper","helper","detectSourceType","sourceType","preparedSource","transformSource","upsert","isNewNs","_ids","deleteMany","formattedNs","chunkedText","chunkText","chunkSize","chunkOverlap","ids","_","doc","stringifyMetadata","_vIds","dsId","dsData","namespaceId","embeddingIds","vectorIds","ds","ac","aclRes","__decorateClass","_vectorDBconnector","embeddingsProvider","OpenAIEmbeddings","_vectorDimention","dimensions","_vaultConnector","cusStorageKeyName","vectorDimention","setVectorDimention","RecursiveCharacterTextSplitter","splitText","embedQuery","embedTexts","texts","embedDocuments","getTeamConnector","getCustomStorageConfig","isNamespaceOnCustomStorage","vectors","N","w","DataSourceIndexer","custom","debugOutput","outputs","con","description","vectorDbConnector","inputSchema","validateInput","providedId","idRegex","indexRes","genDsId","Source","addDSFromText","sourceId","Success","dataSource","unknown","vectorDBHelper","customTeamConnector","addDSFromUrl","R","AgentProcess","agentData","initAgent","connections","version","jsonRegex","jsonData","getAgentData","agentSettings","_loadPromise","itv","run","parseReqConfig","setRequest","pathMatches","endpointPath","reset","parseCLI","cli","usedMethod","endpoint","session","filePath","cwd","fileName","basename","fs","existsSync","fileBuffer","readFileSync","fileObj","fieldname","originalname","readDebugState","stateId","readState","M","LLMContext","_systemPrompt","llmContextStore","_llmContextStore","_messages","systemPrompt","addUserMessage","message_id","__smyth_data__","addAssistantMessage","addToolMessage","messageBlock","toolsData","getContextWindow","maxOutputTokens","maxModelContext","maxInputContext","systemMessage","encodeChat","internal_message","transformToolMessageBlocks","reverse","unshift","textContent","encoded","encode","excessPercentage","floor","dereferenceSchema","root","$ref","ref","resolved","segment","OpenAPIParser","mapReqMethods","paths","methods","pathData","operationId","mapEndpoints","operationIds","yamlToJson","yamlData","yaml","getJson","parsedData","getJsonFromUrl","isValidOpenAPI","openapi","servers","P","Conversation","_model","_specSource","_lastError","maxContextSize","_maxContextSize","_maxOutputTokens","userDefinedSystemPrompt","toolChoice","loadSpecFromSource","spec","_status","_spec","updateModel","_context","context","specSource","_currentWaitPromise","waitTime","wait","toolHeaders","reqMethods","_reqMethods","toolsConfig","_toolsConfig","endpoints","_endpoints","_baseUrl","contextWindow","llmResponse","toolsStrategy","_agentId","code","useTool","tool","parsedArgs","arguments","toolArgs","plugin_url","functionResponse","streamPrompt","concurrentToolCalls","_content","eventEmitter","experimentalCache","toolsContent","hasTools","hasError","llmMessage","tool_calls","function","toolProcessingTasks","processedToolsData","usage_data","resolveToolEndpoint","templateParams","parameters","in","parsedEndpoint","searchParams","toolHandler","_customToolsHandlers","addTool","requiredFields","toolDefinition","_customToolsDeclarations","formatToolsConfig","toolDefinitions","tools","functionDeclarations","getFunctionDeclarations","patchSpec","behavior","loadSpecFromAgent","assistantName","specUrl","defaultBaseUrl","origin","templateInfo","getOpenAPIJSON","declarations","requestBody","declaration","summary","b","cacheConnector","ForkedAgent","parent","componentData","componentID","clonedComponents","clonedConnections","cloneRecursively","rootComponentData","APIEndpointData","incomingConnections","conn","targetId","targetIndex","epInput","epOutput","expression","optional","sourceIndex","fork","debugSessionEnabled","agentRequest","JobID","jobID","currentID","newIDMap","componentToClone","clonedComponent","component","newComponent","cloneComponent","clonedConnection","_Async","forked","forkedAgent","cleanJobIDBranch","JOBS","_job_components","updateComponent","finally","reloadCtxData","AsyncComponent","jobIDOutputIndex","findIndex","removeOrphanedBranches","toDelete","removeComponent","Async","_Await","jobs_count","max_time","Results","jobs","Jobs","WAITS","workflowReqId","done","completed","_debug_time","Output","Await","cleanupResult","_temp_result","_in_progress","B","validateAndParseJson","parsedJson","I","O","Note","APIEndpoint","pattern","ai_exposed","_authInfo","inputsWithDefaultValue","defaultVal","bodyInputNames","queryInputNames","outputName","inputName","_inputWithDefaultValue","inputValue","isFile","file","APIOutput","rawOutput","agentVar","agentVariables","LLMPrompt","APICall","_templateSettings","proxy","scope","authorizationURL","oauth2CallbackURL","callbackURL","requestTokenURL","accessTokenURL","userAuthorizationURL","oauth1CallbackURL","authenticate","template","decodeURIComponent","href","parseUrl","ge_json","ge_urlEncodedFormData","ge_multipartFormData","ge_binary","ge_text","ge_none","parseData","jsonHeaders","AxiosHeaders","parseHeaders","urlObj","host","port","auth","username","password","parseProxy","Response","Headers","oauth_body_hash","extractAdditionalParamsForOAuth1","oauthHeaders","generateOAuthHeaders","VisionLLM","Images","FSleep","Input","FHash","Data","algorithm","encoding","hashAlgo","Hash","FEncDec","action","FSign","signingKey","Key","signMethod","dataTransform","hashType","RSA_padding","RSA_saltLength","querystring","Signature","signData","algo","sign","createSign","sign_options","padding","constants","saltLength","hmac","FTimestamp","Timestamp","DataSourceLookup","postprocess","strict","Query","results","existingNs","DataSourceCleaner","validateConfigData","existingnamespace","JSONFilter","fields","fieldList","field","filterObject","reduce","acc","filterFields","LogicAND","cfgInput","Verified","Unverified","LogicOR","LogicXOR","trueCount","LogicAtLeast","minSetInputs","LogicAtMost","maxSetInputs","AgentPlugin","openAiModel","descForModel","desc","logoUrl","domain","subAgentId","reqTag","Prompt","isSubAgentDeployed","isDeployed","callerSessionId","LLMAssistant","ttl","userInput","UserInput","UserId","conversationId","ConversationId","conv_uid","sessionData","filteredMessages","messageTokens","readMessagesFromSession","round","saveMessagesToSession","ForEach","Result","Loop","inputObject","inputArray","_ForEachData","getRuntimeData","_LoopData","parentId","loopIndex","loopLength","branches","updateRuntimeData","flat","Code","code_vars","code_body","codeInputs","b64encoded","HuggingFace","modelName","modelTask","disableCache","hf","HfInference","hfFunc","group","kebabToCamel","formatRequest","hfParams","_hfParams","request_parameter_name","request_parameter_type","blob","structuredInputs","formatRequestPattern","trimmedPattern","shouldNestInputs","inputsLog","use_cache","modelCallWithRetry","retryCount","retryLimit","retryDelay","ZapierAction","actionName","actionId","_pubUrlsCreated","pubUrl","GPTPlugin","ImageGenerator","sizeDalle2","sizeDalle3","quality","style","isRawInputPrompt","_finalPrompt","numberOfImages","revised_prompt","Classifier","escapeJSONString","unescapeJSONString","inputCopy","categories","excludedKeys","outputKeys","parsedValue","MultimodalLLM","outputFormat","_AgentLogger","cleanup","trIds","transactions","trId","canDelete","logData","logTask","AgentLogger","RuntimeContext","runtime","dbgFolder","os","tmpdir","mkdirSync","recursive","reqId","processID","xDebugId","ctxFile","initRuntimeContext","serialize","step","sessionResult","sessionResults","deserialize","_runtimeFileReady","endpointDBGCall","ctxData","cptId","ctx","active","cpt","writeFileSync","sync","sessionClosed","unlinkSync","incStep","resetComponent","runtimeData","getComponentData","AgentRuntimeUnavailable","_AgentRuntime","isNestedProcess","xDebugStop","xDebugRun","xDebugInject","xDebugRead","reqTagOwner","xDebugPendingInject","sessionId","tagsData","processResults","errorResults","agentContext","alwaysActiveComponents","exclusiveComponents","componentInstance","alwaysActive","saveRuntimeComponentData","exclusive","_debugActive","circularLimitReached","curStep","destroy","incTag","getWaitingComponents","getExclusiveActiveComponents","deltaOnly","dbgAllComponents","dbgActiveComponents","dbgComponent","dbgSession","remainingActiveComponents","activeAsyncComponents","checkCircularLimit","circularLimit","delta","runCycle","dbgActiveWaitingComponents","dbgActiveReadyComponents","expiredDbgSession","injectInput","callComponent","dbgResults","_missing_inputs","_ChildLoopData","finalResult","current","seen","_exclude","injectDebugOutput","allEmpty","AgentRuntime","totalMemory","totalmem","freeMemory","freemem","usedMemory","toFixed","getMemoryUsage","OSResourceMonitor","cpus","nice","sys","idle","irq","total","cpu","times","getCpuUsage","agentVersion","variables","apiBasePath","connection","sourceComponent","targetComponent","next","prev","tagAsyncComponents","dateTime","getFullYear","getMonth","padStart","getDate","getHours","getMinutes","getSeconds","getCurrentFormattedDate","sessionTags","sessionTag","dummy","kill","_kill","parseVariables","logId","workflowID","inputTimestamp","dbgResult","qosLatency","planInfo","maxLatency","circularLimitData","outputTimestamp","updateTasksCount","_result","_componentData","_component","postProcessResult","hasLoopAncestor","inputEntry","prevId","prevComponentData","clearChildLoopRuntimeComponentData","getComponentMissingInputs","missingInputs","readablePredecessors","findReadablePredecessors","readableInputNames","pred","allInputIndexes","allInputs","predComponentData","sourceComponentData","hasReadOutput","updateStep","prepareComponentInput","validationResult","callNextComponents","_is_leaf","resultsCopy","JSONExpression","propertyString","currentProperty","property","waitingComponents","waitingComponentIds","alwaysActiveIds","alwaysActiveConnections","prevComponent","outputEndpoint","targetComponents","targetComponentData","nextInput","inputEndpoint","outputExpression","outputParts","defaultOutputs","combinedInput","_mergeInputs","sourceRuntimeData","__action","__status","rData","rDataInput","getConnectionSource","getConnectionTarget","recursiveTagAsyncComponents","connected","AsyncComponents","existing","newValue","StorageConnector","setMetadata","global","getRandomValues","arr","randomBytes","S3Storage","bucket","clientConfig","region","accessKeyId","secretAccessKey","credentials","S3Client","command","GetObjectCommand","Bucket","send","Body","getS3Metadata","s3Metadata","setS3Metadata","PutObjectCommand","Metadata","serializeS3Metadata","DeleteObjectCommand","HeadObjectCommand","migrateMetadata","agentid","teamid","userid","convertibleItems","newMetadata","amzMetadata","deserializeS3Metadata","s3RawMetadata","getObjectCommand","objectData","bufferBody","putObjectCommand","StorageService","LLMConnector","newPrompt","customLLMRegistry","keyIdName","keyIDName","secretKeyName","sessionKeyName","sessionToken","jsonCredentialsName","jsonCredentials","EchoConnector","LLMHelper","hasSystemMessage","separateSystemMessages","otherMessages","countVisionPromptTokens","textObj","textTokens","images","imageTokens","imageUrl","image_url","width","height","getImageDimensions","countImageTokens","isBase64FileUrl","imageSize","detailMode","maxDimension","minDimension","scaledMinDimension","tiles","ceil","removeDuplicateUserMessages","shift","VALID_IMAGE_MIME_TYPES","MODELS_WITH_JSON_RESPONSE","OpenAIConnector","openai","chatCompletionArgs","max_tokens","top_p","frequency_penalty","presence_penalty","response_format","chat","completions","choices","finish_reason","validSources","getValidImageFileSources","promptData","getImageData","generate","tool_choice","toolCallsStream","contentStream","tee","_stream","toolCall","emitter","stream_options","include_usage","usage","messageBlocks","transformedMessageBlock","transformedToolsData","toolData","tool_call_id","_message","textBlock","fileSource","validImageMimeTypes","imageData","DEFAULT_MODEL","MODELS_SUPPORT_SYSTEM_INSTRUCTION","MODELS_SUPPORT_JSON_RESPONSE","VALID_MIME_TYPES","GoogleAIConnector","systemInstruction","responseMimeType","modelParams","generationConfig","$model","GoogleGenerativeAI","getGenerativeModel","countTokens","generateContent","candidates","fileUploadingTasks","getValidFileSources","uploadFile","uploadedFiles","getFileData","promptWithFiles","validFiles","fileData","formattedMessages","separateMessages","systemMessageContent","toolsPrompt","contents","toolConfig","functionCallingConfig","mode","toolCalls","functionCall","generateContentStream","sanitizeFunctionName","functionCalls","sanitized","tempDir","tempFilePath","writeFile","fileManager","GoogleAIFileManager","uploadResponse","mimeType","uploadedFile","getFile","FileState","PROCESSING","stdout","FAILED","unlink","validMimeTypes","fileUri","API_KEY_ERROR_MESSAGE","AnthropicAIConnector","anthropic","Anthropic","messageCreateArgs","system","top_k","stop_sequences","stop_reason","stopReason","toolUseContentBlocks","toolUseBlock","cache_control","beta","promptCaching","event","finalMessage","prompt_tokens","input_tokens","cache_creation_input_tokens","cache_read_input_tokens","completion_tokens","output_tokens","total_tokens","prompt_tokens_details","cached_tokens","completion_tokens_details","reasoning_tokens","input_schema","calls","toolResultsContent","tool_use_id","block","media_type","q","GroqConnector","groq","S","BedrockConnector","customModel","inferenceConfig","converseCommandInput","ConverseCommand","BedrockRuntimeClient","customModelInfo","toolsInfo","toolUse","toolUseId","_deserializeToolName","ConverseStreamCommand","currentMessage","currentToolCall","currentToolInput","messageStart","contentBlockDelta","contentBlockStart","contentBlockStop","messageStop","typedError","toolSpec","_serializeToolName","toolResult","VertexAIConnector","project","projectId","location","googleAuthOptions","apiEndpoint","LLMService","CacheConnector","updateTTL","getTTL","x","RedisCache","sentinels","hosts","hostName","parseSentinelHosts","redis","IORedis","_prefix","mdPrefix","_mdPrefix","del","deserializeRedisMetadata","serializeRedisMetadata","expire","_metadata","redisMetadata","strMetadata","quit","CacheService","VaultConnector","JSONFileVault","fileKey","privateKey","encryptedVault","decryptedBuffer","privateDecrypt","RSA_PKCS1_OAEP_PADDING","vaultData","getM2MToken","configs","base64Credentials","oauthAppId","oauthAppSecret","qs","SmythVault","oAuthAppId","oAuthAppID","oAuthAppSecret","oAuthBaseUrl","oAuthResource","oAuthScope","vaultAPI","vaultAPIBaseUrl","vaultAPIHeaders","getVaultRequestHeaders","legacyGlobalVaultKey","globalVaultKey","SecretsManager","secretsManager","SecretsManagerClient","awsAccessKeyId","awsSecretAccessKey","secretId","GetSecretValueCommand","SecretId","SecretString","VaultService","AccountConnector","getAllUserSettings","getUserSetting","settingKey","getAllTeamSettings","SmythAccount","smythAPI","smythAPIBaseUrl","getSmythRequestHeaders","settingsObject","setting","settingValue","accountId","DummyAccount","AWSAccount","pool","mysql","createPool","database","connectionLimit","rows","execute","row","AccountService","openapiTemplate","schemas","openapiEndpointTemplate","responses","AgentDataConnector","server_url","aiOnly","shortDescription","_version","openAPITpl","model_name","model_description","openAPIObj","openAPIEntry","parameter","getOpenAPIInputSchema","explode","getOpenAPIParameterStyle","requiredProps","input_type","items","additionalProperties","CLIAgentDataConnector","__dirname","realpathSync","getAgentIdByDomain","LocalAgentDataConnector","dev","prod","devDir","prodDir","indexDir","dir","agents","readdirSync","agentsData","indexAgentsData","devAgentsData","devAgentSettings","prodAgentsData","prodAgentSettings","SmythAgentDataConnector","agentStageDomain","agentProdDomain","agentObj","authData","tasksResponse","taskData","isLocked","deploymentsList","deployment","deployments","deployResponse","aiAgentData","migrateAgentData","isStageWildcardDomain","isProdWildcardDomain","domains","domainEntry","aiAgent","newData","connectors","receptors","outputProps","connectorProps","inputProps","receptorProps","AgentDataService","SmythManagedVectorDB","dataSourceId","errorMessage","datasources","useCustomVectorStorage","namespaceRecord","userMetadata","pageContent","VectorDBService","CLIConnector","_keys","argsList","getMainArgs","CLIService","NKVConnector","_NKVRedis","redisCacheConnector","mdKey","setKey","fetchKeysByPrefix","pipeline","cursor","scan","NamespaceAccessControl","isNamespaceSearch","finalKey","Validate","NKVRedis","NKVService","RouterConnector","ExpressRouter","handlers","put","useFn","use","getRouter","RouterService","ManagedVaultConnector","SmythManagedVault","vaultName","vaultSetting","ManagedVaultService","boot","ne","ks","rt","xr","yu","zn","Le","nl","We"],"mappings":"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"}