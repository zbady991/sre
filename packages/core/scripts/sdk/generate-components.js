import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Define the paths
const COMPONENTS_DIR = path.join(__dirname, '../../src/Components');
const SDK_OUTPUT_DIR = path.join(__dirname, '../../src/sdk/components/generated');
const COMPONENT_TEMPLATE_PATH = path.join(__dirname, './templates/Component.ts.tpl');
const INDEX_TEMPLATE_PATH = path.join(__dirname, './templates/index.ts.tpl');

/**
 * Simple template engine that replaces {{variable}} with values
 */
function renderTemplate(templateContent, variables) {
    const warning = '//!!! DO NOT EDIT THIS FILE, IT IS AUTO-GENERATED !!!//';
    let result = templateContent;

    for (const [key, value] of Object.entries(variables)) {
        const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        result = result.replace(placeholder, value);
    }

    result = warning + '\n\n' + result;

    return result;
}

/**
 * Load template file
 */
function loadTemplate(templatePath) {
    try {
        return fs.readFileSync(templatePath, 'utf-8');
    } catch (error) {
        console.error(`Error loading template from ${templatePath}:`, error);
        throw error;
    }
}

/**
 * Find matching closing brace for an opening brace
 */
function findMatchingBrace(content, startIndex) {
    let braceCount = 1;
    let index = startIndex + 1;

    while (index < content.length && braceCount > 0) {
        const char = content[index];
        if (char === '{') {
            braceCount++;
        } else if (char === '}') {
            braceCount--;
        }
        index++;
    }

    return braceCount === 0 ? index - 1 : -1;
}

/**
 * Parse a JavaScript object string into a JavaScript object
 * This is a simplified parser that handles basic object structures
 */
function parseObjectString(objStr) {
    try {
        // Clean up the string and make it valid JSON-like
        let cleanStr = objStr
            .replace(/(\w+):/g, '"$1":') // Quote property names
            .replace(/'/g, '"') // Convert single quotes to double quotes
            .replace(/,(\s*[}\]])/g, '$1') // Remove trailing commas
            .replace(/:\s*true/g, ': true')
            .replace(/:\s*false/g, ': false');

        // Try to parse as JSON first
        try {
            return JSON.parse('{' + cleanStr + '}');
        } catch (e) {
            // If JSON parsing fails, use eval (less safe but more flexible)
            // Only use this for trusted code
            return eval('({' + objStr + '})');
        }
    } catch (error) {
        console.warn('Failed to parse object string:', objStr.substring(0, 100) + '...');
        return {};
    }
}

/**
 * Extract schema from a component class file using improved parsing
 */
function extractSchemaFromFile(filePath) {
    try {
        const content = fs.readFileSync(filePath, 'utf-8');

        // Look for protected schema = { ... } pattern
        const schemaStartMatch = content.match(/protected\s+schema\s*=\s*\{/);

        if (!schemaStartMatch) {
            return null;
        }

        const schemaStartIndex = schemaStartMatch.index + schemaStartMatch[0].length - 1;
        const schemaEndIndex = findMatchingBrace(content, schemaStartIndex);

        if (schemaEndIndex === -1) {
            console.warn('Could not find matching closing brace for schema');
            return null;
        }

        const schemaContent = content.substring(schemaStartIndex + 1, schemaEndIndex);

        // Parse the schema object
        const schemaObj = parseObjectString(schemaContent);

        if (!schemaObj.name) {
            return null;
        }

        // Extract and normalize inputs
        const inputs = {};
        if (schemaObj.inputs) {
            for (const [inputName, inputDef] of Object.entries(schemaObj.inputs)) {
                inputs[inputName] = {
                    type: inputDef.type || 'Any',
                    optional: inputDef.optional || false,
                    default: inputDef.default || false,
                    description: inputDef.description,
                };
            }
        }

        // Extract and normalize outputs
        const outputs = {};
        if (schemaObj.outputs) {
            for (const [outputName, outputDef] of Object.entries(schemaObj.outputs)) {
                outputs[outputName] = {
                    ...outputDef,
                };
            }
        }

        return {
            name: schemaObj.name,
            inputs,
            outputs,
            settings: schemaObj.settings || {},
        };
    } catch (error) {
        console.error(`Error extracting schema from ${filePath}:`, error);
        return null;
    }
}

/**
 * Map schema type to TypeScript type
 */
function mapSchemaTypeToTS(schemaType) {
    switch (schemaType) {
        case 'string':
            return 'string';
        case 'number':
            return 'number';
        case 'boolean':
            return 'boolean';
        case 'object':
            return 'object';
        case 'array':
            return 'any[]';
        default:
            return 'any';
    }
}

/**
 * Generate TypeScript interface for inputs
 */
function generateInputsType(componentName, inputs) {
    if (!inputs || Object.keys(inputs).length === 0) {
        return `export type T${componentName}Inputs = {
    [key: string]: any;
};`;
    }

    const inputsEntries = Object.entries(inputs);
    const properties = inputsEntries.map(([inputName, inputDef]) => {
        const tsType = mapSchemaTypeToTS(inputDef.type);

        // Add JSDoc comment if description exists
        let jsDocComment = '';
        if (inputDef.description) {
            jsDocComment = `    /** ${inputDef.description} */\n`;
        }

        // All inputs are optional in the type
        return `${jsDocComment}    ${inputName}?: ${tsType};`;
    });

    return `export type T${componentName}Inputs = {
${properties.join('\n')}
    [key: string]: any;
};`;
}

/**
 * Generate TypeScript interface for settings
 */
function generateSettingsType(componentName, settings) {
    if (!settings || Object.keys(settings).length === 0) {
        return `export interface T${componentName}Settings {
    name?: string;
}`;
    }

    const settingsEntries = Object.entries(settings);
    const properties = settingsEntries.map(([settingName, settingDef]) => {
        const tsType = mapSchemaTypeToTS(settingDef.type);
        const isRequired = settingDef.required === true;
        const optional = isRequired ? '' : '?';

        // Add JSDoc comment if description or label exists
        let jsDocComment = '';
        const description = settingDef.description || settingDef.label;
        if (description) {
            jsDocComment = `    /** ${description} */\n`;
        }

        // Handle union types for valid values
        let finalType = tsType;
        if (settingDef.valid && Array.isArray(settingDef.valid)) {
            finalType = settingDef.valid.map((val) => `'${val}'`).join(' | ');
        }

        return `${jsDocComment}    ${settingName}${optional}: ${finalType};`;
    });

    return `export interface T${componentName}Settings {
    name?: string;
${properties.join('\n')}
}`;
}

/**
 * Generate template variables for a component schema
 */
function generateTemplateVariables(schema) {
    const { name, inputs = {}, outputs = {}, settings = {} } = schema;

    // Generate settings type
    const settingsType = generateSettingsType(name, settings);

    // Generate inputs type
    const inputsType = generateInputsType(name, inputs);

    // Generate outputs object
    const outputEntries = Object.keys(outputs);
    const outputsCode =
        outputEntries.length > 0
            ? outputEntries
                  .map(
                      (outputName) =>
                          `        ${outputName}: createSafeAccessor({}, component, '${outputName}', ${JSON.stringify(outputs[outputName])}),`,
                  )
                  .join('\n')
            : '        // No outputs defined';

    // Generate outputs type
    const outputsType =
        outputEntries.length > 0 ? `{ ${outputEntries.map((name) => `${name}: any`).join('; ')}; [key: string]: any }` : '{ [key: string]: any }';

    // Generate inputs object
    const inputEntries = Object.keys(inputs);
    const inputsCode =
        inputEntries.length > 0
            ? inputEntries
                  .map((inputName) => {
                      const input = inputs[inputName];
                      return `        ${inputName}: {
            component,
            type: '${input.type}',
            optional: ${input.optional || false},
            default: ${input.default || false},
        },`;
                  })
                  .join('\n')
            : '        // No inputs defined';

    return {
        componentName: name,
        settingsType,
        inputsType,
        outputsType,
        outputsCode,
        inputsCode,
    };
}

/**
 * Generate SDK component code using template
 */
function generateSDKComponent(schema, template) {
    const variables = generateTemplateVariables(schema);
    return renderTemplate(template, variables);
}

/**
 * Generate index file using template
 */
function generateIndexFile(componentNames, template) {
    const imports = componentNames.map((name) => `import { ${name} } from './${name}';`).join('\n');

    const exports = `const Components = { ${componentNames.map((name) => `${name},`).join(' ')} };\n export default Components;`;

    return renderTemplate(template, { imports, exports });
}

/**
 * Main generation function
 */
async function generateSDKComponents() {
    //console.log('üöÄ Starting SDK component generation...');

    // Load templates
    //console.log('üìÑ Loading templates...');
    const componentTemplate = loadTemplate(COMPONENT_TEMPLATE_PATH);
    const indexTemplate = loadTemplate(INDEX_TEMPLATE_PATH);
    //console.log('‚úÖ Templates loaded successfully');

    // Ensure output directory exists
    if (!fs.existsSync(SDK_OUTPUT_DIR)) {
        fs.mkdirSync(SDK_OUTPUT_DIR, { recursive: true });
    }

    // Get all component files
    const componentFiles = fs
        .readdirSync(COMPONENTS_DIR)
        .filter((file) => file.endsWith('.class.ts') && file !== 'Component.class.ts')
        .map((file) => path.join(COMPONENTS_DIR, file));

    const generatedComponents = [];
    const skippedComponents = [];

    const schemas = [];
    process.stdout.write(`\nüìù Reading Schemas `);
    for (const filePath of componentFiles) {
        const fileName = path.basename(filePath, '.class.ts');
        //console.log(`üìù Extracting schema for ${fileName}...`);

        const schema = extractSchemaFromFile(filePath);
        if (!schema || !schema.name) {
            process.stdout.write(`!`);
            //console.log(`‚ö†Ô∏è  No schema found in ${fileName}, skipping...`);
            skippedComponents.push(fileName);
            continue;
        } else {
            process.stdout.write(`.`);
        }
        schemas.push(schema);
    }

    //process.stdout.write(`\nüìù Processing schemas `);
    for (const schema of schemas) {
        process.stdout.write(`.`);
        // console.log(`üìã Processing schema for ${schema.name}:`);
        // console.log(`   - Inputs: ${Object.keys(schema.inputs || {}).join(', ') || 'none'}`);
        // console.log(`   - Outputs: ${Object.keys(schema.outputs || {}).join(', ') || 'none'}`);
        // console.log(`   - Settings: ${Object.keys(schema.settings || {}).join(', ') || 'none'}`);

        const hasInputsOrOutputs =
            (schema.inputs && Object.keys(schema.inputs).length > 0) || (schema.outputs && Object.keys(schema.outputs).length > 0);

        if (!hasInputsOrOutputs) {
            process.stdout.write(`!`);
            //console.log(`‚ö†Ô∏è  No inputs or outputs found in ${fileName}, skipping...`);
            skippedComponents.push(fileName);
            continue;
        }

        try {
            const sdkCode = generateSDKComponent(schema, componentTemplate);
            const outputPath = path.join(SDK_OUTPUT_DIR, `${schema.name}.ts`);

            fs.writeFileSync(outputPath, sdkCode);
            generatedComponents.push(schema.name);

            process.stdout.write(`.`);
            //console.log(`‚úÖ Generated ${schema.name}.ts`);
        } catch (error) {
            process.stdout.write(`!`);
            //console.error(`‚ùå Error generating ${schema.name}:`, error);
            skippedComponents.push(fileName);
        }
    }

    // Generate index file
    if (generatedComponents.length > 0) {
        const indexContent = generateIndexFile(generatedComponents, indexTemplate);
        fs.writeFileSync(path.join(SDK_OUTPUT_DIR, 'index.generated.ts'), indexContent);
        process.stdout.write(`.`);
        //console.log('‚úÖ Generated index.ts');
    }

    process.stdout.write(`\n`);
    // Summary

    if (generatedComponents.length > 0) {
        process.stdout.write(`‚úÖ Generated ${generatedComponents.length} components `);
    }

    if (skippedComponents.length > 0) {
        process.stdout.write(`‚ö†Ô∏è Skipped ${skippedComponents.length} components (missing schema)`);
    }

    process.stdout.write(`\n`);
}

// Run the generator
generateSDKComponents().catch(console.error);
